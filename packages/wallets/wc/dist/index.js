var V=((u)=>typeof require!=="undefined"?require:typeof Proxy!=="undefined"?new Proxy(u,{get:(N,f)=>(typeof require!=="undefined"?require:N)[f]}):u)(function(u){if(typeof require!=="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+u+'" is not supported')});import{Chain as Z}from"@swapkit/helpers";var t="wss://relay.walletconnect.com",l="eip155:1",c="eip155:56",o="eip155:43114",m="cosmos:thorchain",i="cosmos:cosmoshub-4",e="cosmos:kaiyo-1",a="cosmos:mayachain",n="eip155:42161",uu="eip155:10",fu="eip155:137",Nu="debug",ju={name:"THORSwap",description:"THORSwap multi-chain dex aggregator powered by THORChain",url:"https://app.thorswap.finance/",icons:["https://static.thorswap.net/logo.png"]},P;((Y)=>{Y.ETH_SEND_TRANSACTION="eth_sendTransaction";Y.ETH_SIGN="eth_sign";Y.PERSONAL_SIGN="personal_sign";Y.ETH_SIGN_TYPED_DATA="eth_signTypedData"})(P||={});var O;((f)=>{f.ETH_CHAIN_CHANGED="chainChanged";f.ETH_ACCOUNTS_CHANGED="accountsChanged"})(O||={});var p;((J)=>{J.COSMOS_SIGN_DIRECT="cosmos_signDirect";J.COSMOS_SIGN_AMINO="cosmos_signAmino";J.COSMOS_GET_ACCOUNTS="cosmos_getAccounts"})(p||={});var Wu;((u)=>{})(Wu||={});var C;((f)=>{f.SOL_SIGN_TRANSACTION="solana_signTransaction";f.SOL_SIGN_MESSAGE="solana_signMessage"})(C||={});var d;((u)=>{})(d||={});var D;((f)=>{f.POLKADOT_SIGN_TRANSACTION="polkadot_signTransaction";f.POLKADOT_SIGN_MESSAGE="polkadot_signMessage"})(D||={});var s;((u)=>{})(s||={});var A;((z)=>{z.NEAR_SIGN_IN="near_signIn";z.NEAR_SIGN_OUT="near_signOut";z.NEAR_GET_ACCOUNTS="near_getAccounts";z.NEAR_SIGN_AND_SEND_TRANSACTION="near_signAndSendTransaction";z.NEAR_SIGN_AND_SEND_TRANSACTIONS="near_signAndSendTransactions"})(A||={});var S;((u)=>{})(S||={});var Ju=[Z.Arbitrum,Z.Avalanche,Z.BinanceSmartChain,Z.Cosmos,Z.Ethereum,Z.Kujira,Z.Maya,Z.Optimism,Z.Polygon,Z.THORChain];import{Chain as j,ChainId as Mu,RPCUrl as xu,SwapKitError as y,WalletOption as Zu,ensureEVMApiKeys as Ku,setRequestClientConfig as Pu}from"@swapkit/helpers";import{SwapKitError as Yu,WalletOption as bu}from"@swapkit/helpers";import{AbstractSigner as vu}from"@swapkit/toolbox-evm";import{Chain as $}from"@swapkit/helpers";var H=(u,N)=>{return(N.find((Y)=>Y.startsWith(b(u)))||"")?.split(":")?.[2]||""},b=(u)=>{switch(u){case $.Avalanche:return o;case $.BinanceSmartChain:return c;case $.Ethereum:return l;case $.THORChain:return m;case $.Arbitrum:return n;case $.Optimism:return uu;case $.Polygon:return fu;case $.Maya:return a;case $.Cosmos:return i;case $.Kujira:return e;default:return""}};class T extends vu{address;chain;walletconnect;provider;constructor({chain:u,provider:N,walletconnect:f}){super(N);this.chain=u,this.walletconnect=f,this.provider=N,this.address=""}getAddress=async()=>{if(!this.walletconnect)throw new Yu("wallet_walletconnect_connection_not_established");if(!this.address)this.address=H(this.chain,this.walletconnect.accounts);return this.address};signMessage=async(u)=>{const N=await this.walletconnect?.client.request({chainId:b(this.chain),topic:this.walletconnect.session.topic,request:{method:"eth_sign",params:[u]}});return N.startsWith("0x")?N:`0x${N}`};signTransaction=()=>{throw new Error("Not implemented: signTransaction")};signTypedData=()=>{throw new Error("Not implemented: signTypedData")};sendTransaction=async({from:u,to:N,value:f,data:J})=>{const{toHexString:Y}=await import("@swapkit/toolbox-evm"),z={from:u,to:N,value:Y(BigInt(f||0)),data:J};return await this.walletconnect?.client.request({chainId:b(this.chain),topic:this.walletconnect.session.topic,request:{method:"eth_sendTransaction",params:[z]}})};connect=(u)=>{if(!u)throw new Yu({errorKey:"wallet_provider_not_found",info:{wallet:bu.WALLETCONNECT,chain:this.chain}});return new T({chain:this.chain,walletconnect:this.walletconnect,provider:u})}}var zu=async({chain:u,walletconnect:N,provider:f})=>new T({chain:u,walletconnect:N,provider:f});import{SwapKitError as Qu}from"@swapkit/helpers";var Ru=(u)=>{const N=[];for(let f of u){const[J]=f.split(":");if(J&&!N.includes(J))N.push(J)}return N},mu=(u)=>{switch(u){case"eip155":return Object.values(P);case"cosmos":return Object.values(p);case"solana":return Object.values(C);case"polkadot":return Object.values(D);case"near":return Object.values(A);default:throw new Qu({errorKey:"wallet_walletconnect_namespace_not_supported",info:{namespace:u}})}},yu=(u)=>{switch(u){case"eip155":return Object.values(O);case"cosmos":return[];case"solana":return Object.values(d);case"polkadot":return Object.values(s);case"near":return Object.values(S);default:throw new Qu({errorKey:"wallet_walletconnect_namespace_not_supported",info:{namespace:u}})}},Xu=(u)=>{const N=Ru(u);return Object.fromEntries(N.map((f)=>[f,{methods:mu(f),chains:u.filter((J)=>J.startsWith(f)),events:yu(f)}]))};async function pu({chain:u,walletconnect:N,address:f,session:J,ethplorerApiKey:Y,covalentApiKey:z}){switch(u){case j.Avalanche:case j.BinanceSmartChain:case j.Arbitrum:case j.Optimism:case j.Polygon:case j.Ethereum:{const{getProvider:Q,getToolboxByChain:I}=await import("@swapkit/toolbox-evm"),G=Ku({chain:u,ethplorerApiKey:Y,covalentApiKey:z}),r=Q(u),X=await zu({walletconnect:N,chain:u,provider:r});return I(u)({...G,provider:r,signer:X})}case j.THORChain:{const{SignMode:Q}=await import("cosmjs-types/cosmos/tx/signing/v1beta1/signing.js"),{TxRaw:I}=await import("cosmjs-types/cosmos/tx/v1beta1/tx.js"),{encodePubkey:G,makeAuthInfoBytes:r}=await import("@cosmjs/proto-signing"),{makeSignDoc:X}=await import("@cosmjs/amino"),{ThorchainToolbox:k,buildAminoMsg:U,buildEncodedTxBody:g,createStargateClient:q,fromBase64:M,getDefaultChainFee:v,prepareMessageForBroadcast:F}=await import("@swapkit/toolbox-cosmos"),x=k({stagenet:!1}),R=v(u),w=(B)=>N?.client.request({chainId:m,topic:J.topic,request:{method:"cosmos_signAmino",params:{signerAddress:f,signDoc:B}}});async function K({assetValue:B,memo:_,...$u}){const W=await x.getAccount(f);if(!W)throw new y({errorKey:"wallet_missing_params",info:{account:W}});if(!W.pubkey)throw new y({errorKey:"wallet_missing_params",info:{account:W,pubkey:W?.pubkey}});const{accountNumber:Iu,sequence:E=0}=W,h=[U({chain:j.THORChain,assetValue:B,memo:_,from:f,...$u})],Gu=X(h,R,Mu.THORChain,_,Iu?.toString(),E?.toString()||"0"),L=await w(Gu),ru=g({chain:j.THORChain,msgs:h.map(F),memo:_||""}),Bu=G(W.pubkey),qu=r([{pubkey:Bu,sequence:E}],R.amount,Number.parseInt(R.gas),void 0,void 0,Q.SIGN_MODE_LEGACY_AMINO_JSON),Vu=I.fromPartial({bodyBytes:ru,authInfoBytes:qu,signatures:[M(typeof L.signature==="string"?L.signature:L.signature.signature)]}),ku=I.encode(Vu).finish();return(await(await q(xu.THORChain)).broadcastTx(ku)).transactionHash}return{...x,transfer:(B)=>K(B),deposit:(B)=>K(B)}}default:throw new y({errorKey:"wallet_chain_not_supported",info:{chain:u,wallet:Zu.WALLETCONNECT}})}}async function Hu(u,N,f){let J;try{if(!N)throw new y("wallet_walletconnect_project_id_not_specified");const Y=Xu(u.map(b)),{WalletConnectModalSign:z}=await import("@walletconnect/modal-sign-html"),Q=new z({logger:Nu,relayUrl:t,projectId:N,metadata:f?.metadata||ju,...f?.core}),I=await Q.getSession();if(I)await Q.disconnect({topic:I.topic,reason:{code:0,message:"Resetting session"}});const G=await Q.connect({requiredNamespaces:Y}),r=Object.values(G.namespaces).flatMap((k)=>k.accounts);return{session:G,accounts:r,client:Q,disconnect:async()=>{await Q.disconnect({topic:G.topic,reason:{code:0,message:"User disconnected"}})}}}catch(Y){console.error(Y)}finally{if(J)J.closeModal()}return}function Uu({addChain:u,config:{thorswapApiKey:N,ethplorerApiKey:f,walletConnectProjectId:J,covalentApiKey:Y,stagenet:z=!1}}){return async function Q(I,G){Pu({apiKey:N});const r=I.filter((q)=>Ju.includes(q)),X=await Hu(r,J,G);if(!X)throw new y("wallet_walletconnect_connection_not_established");const{session:k,accounts:U}=X,g=r.map(async(q)=>{const M=H(q,U),v=await pu({session:k,address:M,chain:q,walletconnect:X,ethplorerApiKey:f,covalentApiKey:Y,stagenet:z});async function F(x){const R=await v.getAccount(x),[{address:w,algo:K,pubkey:B}]=await X?.client.request({chainId:m,topic:k.topic,request:{method:"cosmos_getAccounts",params:{}}});return{...R,address:w,pubkey:{type:K,value:B}}}u({...v,disconnect:X.disconnect,address:M,balance:[],chain:q,walletType:Zu.WALLETCONNECT,getAccount:q===j.THORChain?F:v.getAccount})});return await Promise.all(g),!0}}var au=[j.BinanceSmartChain,j.Ethereum,j.THORChain,j.Avalanche,j.Arbitrum,j.Optimism,j.Polygon,j.Maya,j.Cosmos,j.Kujira],nu={connectWalletconnect:Uu};export{nu as walletconnectWallet,Ju as WC_SUPPORTED_CHAINS,m as THORCHAIN_MAINNET_ID,fu as POLYGON_MAINNET_ID,uu as OPTIMISM_MAINNET_ID,a as MAYACHAIN_MAINNET_ID,e as KUJIRA_MAINNET_ID,l as ETHEREUM_MAINNET_ID,C as DEFAULT_SOLANA_METHODS,d as DEFAULT_SOLANA_EVENTS,t as DEFAULT_RELAY_URL,D as DEFAULT_POLKADOT_METHODS,s as DEFAULT_POLKADOT_EVENTS,A as DEFAULT_NEAR_METHODS,S as DEFAULT_NEAR_EVENTS,Nu as DEFAULT_LOGGER,O as DEFAULT_EIP_155_EVENTS,P as DEFAULT_EIP155_METHODS,p as DEFAULT_COSMOS_METHODS,Wu as DEFAULT_COSMOS_EVENTS,ju as DEFAULT_APP_METADATA,i as COSMOS_HUB_MAINNET_ID,c as BSC_MAINNET_ID,o as AVALACHE_MAINNET_ID,n as ARBITRUM_ONE_MAINNET_ID};

//# debugId=D56FEB7C3EF36F2B64756E2164756E21
