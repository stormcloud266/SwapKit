var L=((z)=>typeof require!=="undefined"?require:typeof Proxy!=="undefined"?new Proxy(z,{get:(Y,$)=>(typeof require!=="undefined"?require:Y)[$]}):z)(function(z){if(typeof require!=="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+z+'" is not supported')});import{Chain as Q,ChainToChainId as b,ChainToHexChainId as p,ChainToRPC as d,SwapKitError as f,WalletOption as K,ensureEVMApiKeys as C,setRequestClientConfig as l}from"@swapkit/helpers";import{Chain as q,ChainToChainId as g,EVMChains as w,RPCUrl as v,SwapKitError as D,WalletOption as I,erc20ABI as A}from"@swapkit/helpers";import{getDenom as u}from"@swapkit/toolbox-cosmos";function X(z){if(!window.xfi)throw new D("wallet_xdefi_not_found");switch(z){case q.Ethereum:case q.Avalanche:case q.BinanceSmartChain:case q.Arbitrum:case q.Optimism:case q.Polygon:case q.Sepolia:return window.xfi.ethereum;case q.Cosmos:case q.Kujira:return window.xfi.keplr;case q.Bitcoin:return window.xfi.bitcoin;case q.BitcoinCash:return window.xfi.bitcoincash;case q.Dogecoin:return window.xfi.dogecoin;case q.Litecoin:return window.xfi.litecoin;case q.THORChain:return window.xfi.thorchain;case q.Maya:return window.xfi.mayachain;case q.Solana:return window.xfi.solana;default:return}}async function m({method:z,params:Y,chain:$}){const J=X($);return new Promise((Z,G)=>{if(J&&"request"in J)J.request({method:z,params:Y},(R,_)=>{R?G(R):Z(_)})})}async function k(z){const Y=X(z);if(!Y)throw new D({errorKey:"wallet_provider_not_found",info:{wallet:I.XDEFI,chain:z}});if([q.Cosmos,q.Kujira].includes(z)){const $=X(q.Cosmos);if(!$||"request"in $)throw new D({errorKey:"wallet_provider_not_found",info:{wallet:I.XDEFI,chain:z}});const J=g[z];await $.enable(J);const Z=$.getOfflineSigner(J),[G]=await Z.getAccounts();return G?.address}if(w.includes(z)){const[$]=await Y.request({method:"eth_requestAccounts",params:[]});return $}if(z===q.Solana)return(await X(q.Solana).connect()).publicKey.toString();return new Promise(($,J)=>Y.request({method:"request_accounts",params:[]},(Z,[G])=>Z?J(Z):$(G)))}async function F({assetValue:z,recipient:Y,memo:$,gasLimit:J},Z="transfer"){if(!z)throw new D("wallet_xdefi_asset_not_defined");const G=await k(z.chain),R=[{amount:{amount:z.getBaseValue("number"),decimals:z.decimal},asset:{chain:z.chain,symbol:z.symbol.toUpperCase(),ticker:z.symbol.toUpperCase()},memo:$,from:G,recipient:Y,gasLimit:J}];return m({method:Z,params:R,chain:z.chain})}function T({chainId:z,rpcUrl:Y}){return async({from:$,recipient:J,assetValue:Z,memo:G})=>{const{createSigningStargateClient:R}=await import("@swapkit/toolbox-cosmos"),_=window.xfi?.keplr?.getOfflineSignerOnlyAmino(z),U=await R(Y||v.Cosmos,_),j=[{denom:u(`u${Z.symbol}`).toLowerCase(),amount:Z.getBaseValue("string")}];try{const{transactionHash:W}=await U.sendTokens($,J,j,2,G);return W}catch(W){throw new D("core_transaction_failed",{error:W})}}}function S(z){return{call:async({contractAddress:Y,abi:$,funcName:J,funcParams:Z=[],txOverrides:G})=>{const R=z;if(!Y)throw new D("wallet_xdefi_contract_address_not_provided");const{createContract:_,createContractTxObject:U,isStateChangingCall:j,toHexString:W}=await import("@swapkit/toolbox-evm");if(j($,J)){const{value:N,from:O,to:E,data:P}=await U(R,{contractAddress:Y,abi:$,funcName:J,funcParams:Z,txOverrides:G});return z.send("eth_sendTransaction",[{value:W(BigInt(N||0)),from:O,to:E,data:P||"0x"}])}const B=await _(Y,$,R)[J]?.(...Z);return typeof B?.hash==="string"?B?.hash:B},approve:async({assetAddress:Y,spenderAddress:$,amount:J,from:Z})=>{const{MAX_APPROVAL:G,createContractTxObject:R,toHexString:_}=await import("@swapkit/toolbox-evm"),U=[$,BigInt(J||G)],W={contractAddress:Y,abi:A,funcName:"approve",funcParams:U,txOverrides:{from:Z}},{value:M,to:H,data:B}=await R(z,W);return z.send("eth_sendTransaction",[{value:_(BigInt(M||0)),from:Z,to:H,data:B||"0x"}])},sendTransaction:async(Y)=>{const{from:$,to:J,data:Z,value:G}=Y;if(!J)throw new D("wallet_xdefi_send_transaction_no_address");const{toHexString:R}=await import("@swapkit/toolbox-evm");return z.send("eth_sendTransaction",[{value:R(BigInt(G||0)),from:$,to:J,data:Z||"0x"}])}}}async function c({chain:z,blockchairApiKey:Y,covalentApiKey:$,ethplorerApiKey:J}){switch(z){case Q.Solana:{const{SOLToolbox:Z}=await import("@swapkit/toolbox-solana");return{...Z(),transfer:F}}case Q.Maya:case Q.THORChain:{const{getToolboxByChain:Z,THORCHAIN_GAS_VALUE:G,MAYA_GAS_VALUE:R}=await import("@swapkit/toolbox-cosmos"),_=z===Q.Maya?R:G;return{...Z(z)(),deposit:(j)=>F({...j,recipient:""},"deposit"),transfer:(j)=>F({...j,gasLimit:_},"transfer")}}case Q.Cosmos:case Q.Kujira:{const{getToolboxByChain:Z}=await import("@swapkit/toolbox-cosmos");return{...Z(z)(),transfer:T({chainId:b[z],rpcUrl:d[z]})}}case Q.Bitcoin:case Q.BitcoinCash:case Q.Dogecoin:case Q.Litecoin:{const{getToolboxByChain:Z}=await import("@swapkit/toolbox-utxo");return{...Z(z)({apiKey:Y}),transfer:F}}case Q.Ethereum:case Q.Sepolia:case Q.BinanceSmartChain:case Q.Arbitrum:case Q.Optimism:case Q.Polygon:case Q.Avalanche:{const{prepareNetworkSwitch:Z,addEVMWalletNetwork:G}=await import("@swapkit/helpers"),{getProvider:R,getToolboxByChain:_,covalentApi:U,ethplorerApi:j,getBalance:W,BrowserProvider:M}=await import("@swapkit/toolbox-evm"),H=X(z);if(!H)throw new f("wallet_xdefi_not_found");const B=C({chain:z,covalentApiKey:$,ethplorerApiKey:J}),N=new M(H,"any"),O=await N.getSigner(),E=_(z)({...B,provider:N,signer:O}),P=S(N);try{z!==Q.Ethereum&&await G(H,E.getNetworkParams())}catch(y){throw new f({errorKey:"wallet_failed_to_add_or_switch_network",info:{wallet:K.XDEFI,chain:z}})}const V=z===Q.Ethereum||z===Q.Sepolia?j(B.ethplorerApiKey):U({apiKey:B.covalentApiKey,chainId:b[z]});return Z({provider:window.xfi?.ethereum,chainId:p[z],toolbox:{...E,...P,getBalance:(y,x)=>W({chain:z,provider:R(z),api:V,address:y,potentialScamFilter:x})}})}default:return null}}function s({addChain:z,config:{covalentApiKey:Y,ethplorerApiKey:$,blockchairApiKey:J,thorswapApiKey:Z}}){return async(G)=>{l({apiKey:Z});const R=G.map(async(_)=>{const U=await k(_),j=await c({chain:_,blockchairApiKey:J,covalentApiKey:Y,ethplorerApiKey:$});z({...j,address:U,balance:[],chain:_,walletType:K.XDEFI})});return await Promise.all(R),!0}}var a=[Q.Arbitrum,Q.Avalanche,Q.BinanceSmartChain,Q.Bitcoin,Q.BitcoinCash,Q.Cosmos,Q.Dogecoin,Q.Ethereum,Q.Kujira,Q.Litecoin,Q.Maya,Q.Optimism,Q.Polygon,Q.Solana,Q.THORChain,Q.Sepolia],h={connectXDEFI:s};export{h as xdefiWallet};

//# debugId=3F663FED04EC35A364756E2164756E21
