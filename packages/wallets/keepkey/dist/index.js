var F=((z)=>typeof require!=="undefined"?require:typeof Proxy!=="undefined"?new Proxy(z,{get:(J,Y)=>(typeof require!=="undefined"?require:J)[Y]}):z)(function(z){if(typeof require!=="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+z+'" is not supported')});import{Chain as X,WalletOption as $z,setRequestClientConfig as qz}from"@swapkit/helpers";import{KeepKeySdk as jz}from"@keepkey/keepkey-sdk";import{ChainId as y,DerivationPath as c,RPCUrl as d,derivationPathToString as h}from"@swapkit/helpers";function m(z){if(z==="m/")return!0;return/^m(((\/[0-9]+h)+|(\/[0-9]+H)+|(\/[0-9]+')*)((\/[0-9]+)*))$/.test(z)}function V(z){let J=z;if(!m(J))throw new Error(`Not a bip32 path: '${J}'`);if(/^m\//i.test(J))J=J.slice(2);const Y=J.split("/");if(Y.length===1&&Y[0]==="")return[];const Q=new Array(Y.length);for(let $=0;$<Y.length;$++){const j=Y[$];if(j){const Z=/(\d+)([hH']?)/.exec(j);if(Z===null)throw new Error("Invalid input");const[,W="",G=""]=Z;if(Q[$]=Number.parseInt(W,10),Q[$]>=2147483648)throw new Error("Invalid child index");if(G==="h"||G==="H"||G==="'")Q[$]+=2147483648;else if(G.length!==0)throw new Error("Invalid modifier")}}return Q}var K;((j)=>{j.BTC="Bitcoin";j.BCH="BitcoinCash";j.DOGE="Dogecoin";j.LTC="Litecoin";j.DASH="Dash"})(K||={});var v=async({sdk:z,api:J,derivationPath:Y})=>{const{DEFAULT_COSMOS_FEE_MAINNET:Q,GaiaToolbox:$,createStargateClient:j}=await import("@swapkit/toolbox-cosmos");try{const Z=Y?h(Y):`${c.GAIA}/0`,{address:W}=await z.address.cosmosGetAddress({address_n:V(Z)}),G=$({server:J});if(Q.amount[0])Q.amount[0].amount=String(await G?.getFeeRateFromThorswap?.(y.Cosmos,500));return{...G,transfer:async({assetValue:B,recipient:_,memo:M})=>{const R=B.getBaseValue("string"),q=await G.getAccount(W),L=await z.cosmos.cosmosSignAmino({signerAddress:W,signDoc:{fee:Q,memo:M||"",sequence:q?.sequence.toString()??"",chain_id:y.Cosmos,account_number:q?.accountNumber.toString()??"",msgs:[{value:{amount:[{denom:"uatom",amount:R}],to_address:_,from_address:W},type:"cosmos-sdk/MsgSend"}]}}),H=atob(L.serialized),I=new Uint8Array(H.length).map((D,O)=>H.charCodeAt(O));return(await(await j(d.Cosmos)).broadcastTx(I)).transactionHash},address:W}}catch(Z){throw console.error(Z),Z}};import{ChainToChainId as r,NetworkDerivationPath as o,derivationPathToString as n}from"@swapkit/helpers";import{AbstractSigner as s}from"@swapkit/toolbox-evm";class A extends s{sdk;chain;derivationPath;address;provider;constructor({sdk:z,chain:J,derivationPath:Y,provider:Q}){super();this.sdk=z,this.chain=J,this.derivationPath=Y||o.ETH,this.address="",this.provider=Q}signTypedData(){throw new Error("this method is not implemented")}getAddress=async()=>{if(this.address)return this.address;const{address:z}=await this.sdk.address.ethereumGetAddress({address_n:V(n(this.derivationPath))});return this.address=z,z};signMessage=(z)=>this.sdk.eth.ethSign({address:this.address,message:z});signTransaction=async({to:z,value:J,gasLimit:Y,nonce:Q,data:$,maxFeePerGas:j,maxPriorityFeePerGas:Z,gasPrice:W})=>{if(!z)throw new Error("Missing to address");if(!Y)throw new Error("Missing gasLimit");if(!$)throw new Error("Missing data");const G=!!((j||Z)&&!W);if(G&&!j)throw new Error("Missing maxFeePerGas");if(G&&!Z)throw new Error("Missing maxFeePerGas");if(!(G||W))throw new Error("Missing gasPrice");const{toHexString:U}=await import("@swapkit/toolbox-evm"),B=Q?BigInt(Q):BigInt(await this.provider.getTransactionCount(await this.getAddress(),"pending")),_={gas:U(BigInt(Y)),addressNList:[2147483692,2147483708,2147483648,0,0],from:this.address,chainId:U(BigInt(r[this.chain])),to:z.toString(),value:U(BigInt(J||0)),nonce:U(B),data:$,...G&&{maxFeePerGas:U(BigInt(j?.toString()||"0")),maxPriorityFeePerGas:U(BigInt(Z?.toString()||"0"))},...!G&&{gasPrice:U(BigInt(W?.toString()||"0"))}};return(await this.sdk.eth.ethSignTransaction(_)).serialized};sendTransaction=async(z)=>{if(!this.provider)throw new Error("No provider set");const J=await this.signTransaction(z);return await this.provider.broadcastTransaction(J)};connect=(z)=>new A({sdk:this.sdk,chain:this.chain,derivationPath:this.derivationPath,provider:z})}import{Chain as t,ChainId as a,DerivationPath as i,RPCUrl as k,derivationPathToString as e}from"@swapkit/helpers";var u=async({sdk:z,derivationPath:J})=>{const{createStargateClient:Y,getToolboxByChain:Q}=await import("@swapkit/toolbox-cosmos"),$=Q(t.Maya)(),j=J?e(J):`${i.MAYA}/0`,{address:Z}=await z.address.mayachainGetAddress({address_n:V(j)}),W=async({assetValue:B,recipient:_,from:M,memo:R})=>{const{makeSignDoc:q}=await import("@cosmjs/amino"),{getDenomWithChain:L}=await import("@swapkit/toolbox-cosmos"),H=await $.getAccount(M);if(!H)throw new Error("Account not found");const{accountNumber:I,sequence:w=0}=H,E=B.getBaseValue("string"),D=_&&_!=="",O=D?{type:"mayachain/MsgSend",value:{amount:[{amount:E,denom:B.symbol.toLowerCase()}],from_address:M,to_address:_}}:{type:"mayachain/MsgDeposit",value:{coins:[{amount:E,asset:L(B)}],memo:R,signer:M}},N=q([O],{gas:"500000000",amount:[]},a.Maya,R,I?.toString(),w),S=D?await z.mayachain.mayachainSignAminoTransfer({signDoc:N,signerAddress:M}):await z.mayachain.mayachainSignAminoDeposit({signDoc:N,signerAddress:M}),b=atob(S.serialized);return new Uint8Array(b.length).map((f,T)=>b.charCodeAt(T))};return{...$,transfer:async({assetValue:B,recipient:_,memo:M})=>{const R=await Y(k.Maya),q=await W({assetValue:B,recipient:_,memo:M,from:Z}),{transactionHash:L}=await R.broadcastTx(q);return L},deposit:async({assetValue:B,memo:_})=>{const M=await Y(k.THORChain),R=await W({assetValue:B,memo:_,from:Z}),{transactionHash:q}=await M.broadcastTx(R);return q},address:Z}};import{Chain as P,ChainId as zz,DerivationPath as Jz,RPCUrl as g,derivationPathToString as Qz}from"@swapkit/helpers";var C=async({sdk:z,derivationPath:J})=>{const{makeSignDoc:Y}=await import("@cosmjs/amino"),{buildAminoMsg:Q,getDefaultChainFee:$,createStargateClient:j,ThorchainToolbox:Z}=await import("@swapkit/toolbox-cosmos"),W=Z({stagenet:!1}),G=J?Qz(J):`${Jz.THOR}/0`,{address:U}=await z.address.thorchainGetAddress({address_n:V(G)}),B=async({assetValue:R,recipient:q,from:L,memo:H})=>{const I=await W.getAccount(L);if(!I)throw new Error("Account not found");const{accountNumber:w,sequence:E=0}=I,D=q&&q!=="",O=Q({chain:P.THORChain,from:L,recipient:q,assetValue:R,memo:H}),N=Y([O],$(P.THORChain),zz.THORChain,H,w?.toString(),E),S=D?await z.thorchain.thorchainSignAminoTransfer({signDoc:N,signerAddress:L}):await z.thorchain.thorchainSignAminoDeposit({signDoc:N,signerAddress:L}),b=atob(S.serialized);return new Uint8Array(b.length).map((f,T)=>b.charCodeAt(T))};return{...W,transfer:async({assetValue:R,recipient:q,memo:L})=>{const H=await j(g.THORChain),I=await B({assetValue:R,recipient:q,memo:L,from:U}),{transactionHash:w}=await H.broadcastTx(I);return w},deposit:async({assetValue:R,memo:q})=>{const L=await j(g.THORChain),H=await B({assetValue:R,memo:q,from:U}),{transactionHash:I}=await L.broadcastTx(H);return I},address:U}};import{Chain as x,DerivationPath as Xz,FeeOption as Yz,derivationPathToString as Zz}from"@swapkit/helpers";var l=async({sdk:z,chain:J,derivationPath:Y,apiKey:Q,apiClient:$})=>{if(!(Q||$))throw new Error("UTXO API key not found");const{getToolboxByChain:j}=await import("@swapkit/toolbox-utxo"),Z=j(J)({apiClient:$,apiKey:Q}),W=[x.Bitcoin,x.Litecoin].includes(J)?"p2wpkh":"p2pkh",G=Y?Zz(Y):`${Xz[J]}/0`,U={coin:K[J],script_type:W,address_n:V(G)},{address:B}=await z.address.utxoGetAddress(U),_=async(R,q,L="")=>{const H=R.txOutputs.map((E)=>{const{value:D,address:O,change:N}=E,S=J===x.BitcoinCash?Z.stripToCashAddress(O):O;if(N||O===B)return{addressNList:U.address_n,isChange:!0,addressType:"change",amount:D,scriptType:W};if(S)return{address:S,amount:D,addressType:"spend"};return null}).filter(Boolean),I=(E)=>{return E.filter((D)=>D!==null&&typeof D==="object"&&Object.keys(D).length!==0)};return(await z.utxo.utxoSignTransaction({coin:K[J],inputs:q,outputs:I(H),version:1,locktime:0,opReturnData:L})).serializedTx};return{...Z,signTransaction:_,transfer:async({from:R,recipient:q,feeOptionKey:L,feeRate:H,memo:I,...w})=>{if(!R)throw new Error("From address must be provided");if(!q)throw new Error("Recipient address must be provided");const{psbt:E,inputs:D}=await Z.buildTx({...w,memo:I,feeOptionKey:L,recipient:q,feeRate:H||(await Z.getFeeRates())[L||Yz.Fast],sender:R,fetchTxHex:J}),O=D.map(({value:S,index:b,hash:f,txHex:T})=>({addressNList:U.address_n,scriptType:W,amount:S.toString(),vout:b,txid:f,hex:T||""})),N=await _(E,O,I);return Z.broadcastTx(N)},address:B}};function Rz({apis:z,rpcUrls:J,addChain:Y,config:{blockchairApiKey:Q,covalentApiKey:$,ethplorerApiKey:j="freekey",keepkeyConfig:Z,thorswapApiKey:W}}){return async function G(U,B,_){if(qz({apiKey:W}),!Z)throw new Error("KeepKey config not found");await p(3);const M=await jz.create(Z),R=U.map(async(q,L)=>{const H=Array.isArray(B)?B[L]:_?.[q],I=await Wz({sdk:M,apiClient:z[q],rpcUrl:J[q],chain:q,derivationPath:H,covalentApiKey:$,ethplorerApiKey:j,blockchairApiKey:Q});Y({...I,balance:[],chain:q,walletType:$z.KEEPKEY})});return await Promise.all(R),!0}}var Pz=[X.Arbitrum,X.Avalanche,X.BinanceSmartChain,X.Bitcoin,X.BitcoinCash,X.Cosmos,X.Dogecoin,X.Dash,X.Ethereum,X.Litecoin,X.Optimism,X.Polygon,X.THORChain,X.Maya],Wz=async({sdk:z,apiClient:J,rpcUrl:Y,chain:Q,derivationPath:$,covalentApiKey:j,ethplorerApiKey:Z,blockchairApiKey:W})=>{const{getProvider:G,getToolboxByChain:U}=await import("@swapkit/toolbox-evm");switch(Q){case X.BinanceSmartChain:case X.Arbitrum:case X.Optimism:case X.Polygon:case X.Avalanche:case X.Ethereum:{if(Q===X.Ethereum&&!Z)throw new Error("Ethplorer API key not found");if(Q!==X.Ethereum&&!j)throw new Error("Covalent API key not found");const B=G(Q,Y),_=new A({sdk:z,chain:Q,derivationPath:$,provider:B}),M=await _.getAddress(),R={api:J,signer:_,provider:B,covalentApiKey:j,ethplorerApiKey:Z};return{address:M,...U(Q)(R)}}case X.Cosmos:return v({sdk:z,derivationPath:$,api:J});case X.THORChain:return C({sdk:z,derivationPath:$});case X.Maya:return u({sdk:z,derivationPath:$});case X.Bitcoin:case X.BitcoinCash:case X.Dash:case X.Dogecoin:case X.Litecoin:return l({apiKey:W,apiClient:J,sdk:z,chain:Q,derivationPath:$});default:throw new Error(`Chain not supported ${Q}`)}},Bz=async(z="http://localhost:1646/spec/swagger.json")=>{try{return(await fetch(z)).status===200}catch(J){return console.error(J),!1}},p=async(z)=>{if(z===0)alert("KeepKey desktop is required for keepkey-sdk, please go to https://keepkey.com/get-started");if(!await Bz())window.location.assign("keepkey://launch"),await new Promise((Y)=>setTimeout(Y,30000)),p(z-1)},gz={connectKeepkey:Rz};export{gz as keepkeyWallet,Bz as checkKeepkeyAvailability,Pz as KEEPKEY_SUPPORTED_CHAINS};

//# debugId=785A1C27F24A9C2E64756E2164756E21
