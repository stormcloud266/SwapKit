{
  "version": 3,
  "sources": ["../src/okxWallet.ts", "../src/helpers.ts"],
  "sourcesContent": [
    "import {\n  Chain,\n  type ConnectWalletParams,\n  WalletOption,\n  setRequestClientConfig,\n} from \"@swapkit/helpers\";\n\nimport { getWalletForChain } from \"./helpers.ts\";\n\nconst OKX_SUPPORTED_CHAINS = [\n  Chain.Arbitrum,\n  Chain.Avalanche,\n  Chain.BinanceSmartChain,\n  Chain.Optimism,\n  Chain.Polygon,\n  Chain.Bitcoin,\n  Chain.Ethereum,\n  Chain.Cosmos,\n] as const;\n\nfunction connectOkx({\n  addChain,\n  config: { thorswapApiKey, covalentApiKey, ethplorerApiKey, blockchairApiKey },\n}: ConnectWalletParams) {\n  return async function connectOkx(chains: (typeof OKX_SUPPORTED_CHAINS)[number][]) {\n    setRequestClientConfig({ apiKey: thorswapApiKey });\n\n    const promises = chains.map(async (chain) => {\n      const walletMethods = await getWalletForChain({\n        chain,\n        covalentApiKey,\n        ethplorerApiKey,\n        blockchairApiKey,\n      });\n\n      addChain({\n        ...walletMethods,\n        chain,\n        balance: [],\n        walletType: WalletOption.OKX,\n      });\n    });\n\n    await Promise.all(promises);\n\n    return true;\n  };\n}\n\nexport const okxWallet = { connectOkx } as const;\n",
    "import {\n  Chain,\n  ChainId,\n  ChainToHexChainId,\n  RPCUrl,\n  SwapKitError,\n  addEVMWalletNetwork,\n  prepareNetworkSwitch,\n} from \"@swapkit/helpers\";\nimport type { GaiaToolbox } from \"@swapkit/toolbox-cosmos\";\nimport {\n  AVAXToolbox,\n  BSCToolbox,\n  BrowserProvider,\n  ETHToolbox,\n  type Eip1193Provider,\n} from \"@swapkit/toolbox-evm\";\nimport type { BTCToolbox, Psbt, UTXOTransferParams } from \"@swapkit/toolbox-utxo\";\n\nconst cosmosTransfer =\n  (rpcUrl?: string) =>\n  async ({ from, recipient, amount, asset, memo }: Todo) => {\n    if (!(window.okxwallet && \"keplr\" in window.okxwallet)) {\n      throw new Error(\"No cosmos okxwallet found\");\n    }\n\n    const { keplr: wallet } = window.okxwallet;\n    const offlineSigner = wallet?.getOfflineSignerOnlyAmino(ChainId.Cosmos);\n\n    const { createSigningStargateClient } = await import(\"@swapkit/toolbox-cosmos\");\n    const cosmJS = await createSigningStargateClient(rpcUrl || RPCUrl.Cosmos, offlineSigner);\n\n    const coins = [\n      { denom: asset?.symbol === \"MUON\" ? \"umuon\" : \"uatom\", amount: amount.amount().toString() },\n    ];\n\n    const { transactionHash } = await cosmJS.sendTokens(from, recipient, coins, 1.6, memo);\n    return transactionHash;\n  };\n\nexport const getWalletForChain = async ({\n  chain,\n  ethplorerApiKey,\n  covalentApiKey,\n  blockchairApiKey,\n  rpcUrl,\n  api,\n}: {\n  chain: Chain;\n  ethplorerApiKey?: string;\n  covalentApiKey?: string;\n  blockchairApiKey?: string;\n  rpcUrl?: string;\n  api?: Todo;\n}): Promise<\n  (\n    | ReturnType<typeof GaiaToolbox>\n    | Awaited<ReturnType<typeof getWeb3WalletMethods>>\n    | ReturnType<typeof BTCToolbox>\n  ) & { address: string }\n> => {\n  switch (chain) {\n    case Chain.Ethereum:\n    case Chain.Avalanche:\n    case Chain.Arbitrum:\n    case Chain.Optimism:\n    case Chain.Polygon:\n    case Chain.BinanceSmartChain: {\n      if (!(window.okxwallet && \"send\" in window.okxwallet)) {\n        throw new Error(\"No okxwallet found\");\n      }\n\n      const { getProvider } = await import(\"@swapkit/toolbox-evm\");\n\n      const evmWallet = await getWeb3WalletMethods({\n        chain,\n        ethplorerApiKey,\n        covalentApiKey,\n        ethereumWindowProvider: window.okxwallet,\n      });\n\n      const address: string = (await window.okxwallet.send(\"eth_requestAccounts\", [])).result[0];\n\n      const getBalance = async (addressOverwrite?: string, potentialScamFilter = true) =>\n        evmWallet.getBalance(addressOverwrite || address, potentialScamFilter, getProvider(chain));\n\n      return { ...evmWallet, getBalance, address };\n    }\n\n    case Chain.Bitcoin: {\n      if (!(window.okxwallet && \"bitcoin\" in window.okxwallet)) {\n        throw new Error(\"No bitcoin okxwallet found\");\n      }\n      const { bitcoin: wallet } = window.okxwallet;\n\n      const { Psbt, BTCToolbox } = await import(\"@swapkit/toolbox-utxo\");\n\n      const address = (await wallet.connect()).address;\n\n      const toolbox = BTCToolbox({ rpcUrl, apiKey: blockchairApiKey, apiClient: api });\n      const signTransaction = async (psbt: Psbt) => {\n        const signedPsbt = await wallet.signPsbt(psbt.toHex(), { from: address, type: \"list\" });\n\n        return Psbt.fromHex(signedPsbt);\n      };\n\n      const transfer = (transferParams: UTXOTransferParams) => {\n        return toolbox.transfer({ ...transferParams, signTransaction });\n      };\n\n      return { ...toolbox, transfer, address };\n    }\n\n    case Chain.Cosmos: {\n      if (!(window.okxwallet && \"keplr\" in window.okxwallet)) {\n        throw new Error(\"No bitcoin okxwallet found\");\n      }\n      const { keplr: wallet } = window.okxwallet;\n\n      await wallet.enable(ChainId.Cosmos);\n      const accounts = await wallet.getOfflineSignerOnlyAmino(ChainId.Cosmos).getAccounts();\n      if (!accounts?.[0]) throw new Error(\"No cosmos account found\");\n\n      const { GaiaToolbox } = await import(\"@swapkit/toolbox-cosmos\");\n      const [{ address }] = accounts;\n\n      return {\n        address,\n        ...GaiaToolbox({ server: api }),\n        transfer: cosmosTransfer(rpcUrl),\n      };\n    }\n\n    default:\n      throw new Error(`No wallet for chain ${chain}`);\n  }\n};\n\nexport const getWeb3WalletMethods = async ({\n  ethereumWindowProvider,\n  chain,\n  covalentApiKey,\n  ethplorerApiKey,\n}: {\n  ethereumWindowProvider: Eip1193Provider | undefined;\n  chain: Chain;\n  covalentApiKey?: string;\n  ethplorerApiKey?: string;\n}) => {\n  if (!ethereumWindowProvider) throw new Error(\"Requested web3 wallet is not installed\");\n\n  if (\n    (chain !== Chain.Ethereum && !covalentApiKey) ||\n    (chain === Chain.Ethereum && !ethplorerApiKey)\n  ) {\n    throw new SwapKitError({\n      errorKey: \"wallet_missing_api_key\",\n      info: {\n        missingKey: chain === Chain.Ethereum ? \"ethplorerApiKey\" : \"covalentApiKey\",\n        chain,\n      },\n    });\n  }\n\n  const provider = new BrowserProvider(ethereumWindowProvider, \"any\");\n\n  const toolboxParams = {\n    provider,\n    signer: await provider.getSigner(),\n    ethplorerApiKey: ethplorerApiKey as string,\n    covalentApiKey: covalentApiKey as string,\n  };\n\n  const toolbox =\n    chain === Chain.Ethereum\n      ? ETHToolbox(toolboxParams)\n      : chain === Chain.Avalanche\n        ? AVAXToolbox(toolboxParams)\n        : BSCToolbox(toolboxParams);\n\n  try {\n    chain !== Chain.Ethereum &&\n      (await addEVMWalletNetwork(\n        provider,\n        (\n          toolbox as ReturnType<typeof AVAXToolbox> | ReturnType<typeof BSCToolbox>\n        ).getNetworkParams(),\n      ));\n  } catch (_error) {\n    throw new Error(`Failed to add/switch ${chain} network: ${chain}`);\n  }\n\n  return prepareNetworkSwitch<typeof toolbox>({\n    toolbox: { ...toolbox },\n    chainId: ChainToHexChainId[chain],\n    provider,\n  });\n};\n"
  ],
  "mappings": "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",
  "debugId": "90D1DC0929465F3C64756E2164756E21",
  "names": []
}