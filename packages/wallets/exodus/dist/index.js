import{Chain as s,ChainToHexChainId as v,WalletOption as B,addEVMWalletNetwork as b,ensureEVMApiKeys as A,prepareNetworkSwitch as T,setRequestClientConfig as x}from"@swapkit/helpers";import{BrowserProvider as E,getProvider as C,getToolboxByChain as W}from"@swapkit/toolbox-evm";import{BTCToolbox as O,Psbt as k}from"@swapkit/toolbox-utxo";import{AddressPurpose as S,BitcoinNetworkType as f,getAddress as M,signTransaction as K}from"sats-connect";function V({addChain:u,config:{covalentApiKey:c,ethplorerApiKey:t,thorswapApiKey:w}}){return async function y(g,p){if(!p)throw new Error("Missing Exodus Wallet instance");x({apiKey:w});const{providers:d}=p,a=g.map(async(r)=>{const o=r===s.Bitcoin?d.bitcoin:new E(d.ethereum,"any"),{address:n,...i}=await R({chain:r,ethplorerApiKey:t,covalentApiKey:c,ethereumWindowProvider:d.ethereum,walletProvider:o});u({...i,chain:r,address:n,getBalance:async(e=!0)=>i.getBalance(n,e),balance:[],walletType:B.EXODUS});return});return await Promise.all(a),!0}}export*from"@passkeys/react";export*from"@passkeys/core";var R=async({ethereumWindowProvider:u,walletProvider:c,chain:t,ethplorerApiKey:w,covalentApiKey:y,blockchairApiKey:g,rpcUrl:p,api:d})=>{switch(t){case s.Bitcoin:{const a=O({rpcUrl:p,apiKey:g,apiClient:d});let r="";const o=()=>new Promise((e)=>e(c)),n={getProvider:o,payload:{purposes:[S.Payment],message:"Address for receiving and sending payments",network:{type:f.Mainnet}},onFinish:(e)=>{if(!e.addresses[0])throw Error("No address found");r=e.addresses[0].address},onCancel:()=>{throw Error("Request canceled")}};await M(n);async function i(e){let P;const h={getProvider:o,payload:{message:"Sign transaction",network:{type:f.Mainnet},psbtBase64:e.toBase64(),broadcast:!1,inputsToSign:[{address:r,signingIndexes:e.txInputs.map((m)=>m.index)}]},onFinish:(m)=>{P=k.fromBase64(m.psbtBase64)},onCancel:()=>{throw Error("Signature canceled")}};return await K(h),P}return{...a,transfer:(e)=>{return a.transfer({...e,signTransaction:i})},address:r}}case s.Ethereum:case s.Arbitrum:case s.Avalanche:case s.BinanceSmartChain:case s.Optimism:case s.Polygon:{if(!u)throw new Error("Requested web3 wallet is not installed");const a=A({chain:t,covalentApiKey:y,ethplorerApiKey:w}),r=C(t),o=c;await o.send("eth_requestAccounts",[]);const n=await o.getSigner(),i=await n.getAddress(),l=W(t)({...a,provider:r,signer:n});try{t!==s.Ethereum&&await b(o,l.getNetworkParams())}catch(e){throw new Error(`Failed to add/switch ${t} network: ${t}`)}return{address:i,...T({toolbox:l,chainId:v[t],provider:o})}}default:throw new Error(`Unsupported chain: ${t}`)}},G={connectExodusWallet:V};export{R as getWalletMethods,G as exodusWallet};

//# debugId=E4AB47AB341A198764756E2164756E21
