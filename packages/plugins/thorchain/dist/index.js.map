{
  "version": 3,
  "sources": ["../src/tcPlugin.ts", "../src/basePlugin.ts", "../src/getSwapParams.ts", "../src/shared.ts", "../src/mayaPlugin.ts"],
  "sourcesContent": [
    "import type { QuoteResponseRoute, QuoteRoute } from \"@swapkit/api\";\nimport {\n  type AGG_CONTRACT_ADDRESS,\n  AGG_SWAP,\n  AssetValue,\n  Chain,\n  ChainToChainId,\n  type EVMChain,\n  type ErrorKeys,\n  FeeOption,\n  MemoType,\n  ProviderName,\n  SWAP_IN,\n  SWAP_OUT,\n  SwapKitError,\n  SwapKitNumber,\n  type SwapKitPluginParams,\n  type SwapParams,\n  TCAvalancheDepositABI,\n  TCBscDepositABI,\n  TCEthereumVaultAbi,\n  type UTXOChain,\n  getMemoForLoan,\n  lowercasedContractAbiMapping,\n} from \"@swapkit/helpers\";\n\nimport { basePlugin } from \"./basePlugin.ts\";\nimport { getSwapInParams } from \"./getSwapParams.ts\";\nimport { prepareTxParams, validateAddressType } from \"./shared.ts\";\nimport type {\n  AddLiquidityParams,\n  CoreTxParams,\n  CreateLiquidityParams,\n  LoanParams,\n  SwapWithRouteParams,\n} from \"./types.ts\";\n\ntype SupportedChain = EVMChain | Chain.THORChain | UTXOChain | Chain.Cosmos;\n\nfunction plugin({ getWallet, stagenet = false }: SwapKitPluginParams) {\n  const {\n    getInboundDataByChain,\n    register,\n    depositToPool,\n    addLiquidity: pluginAddLiquidity,\n    createLiquidity: pluginCreateLiquidity,\n    ...pluginMethods\n  } = basePlugin({\n    getWallet,\n    pluginChain: Chain.THORChain,\n    stagenet,\n    deposit,\n  });\n\n  // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: TODO refactor\n  async function deposit({\n    assetValue,\n    recipient,\n    router,\n    ...rest\n  }: CoreTxParams & { router?: string }) {\n    const { chain, symbol, ticker } = assetValue;\n\n    const wallet = getWallet(chain as SupportedChain);\n    if (!wallet) {\n      throw new SwapKitError(\"core_wallet_connection_not_found\");\n    }\n\n    const isAddressValidated = validateAddressType({ address: wallet.address, chain });\n    if (!isAddressValidated) {\n      throw new SwapKitError(\"core_transaction_invalid_sender_address\");\n    }\n\n    const params = prepareTxParams({\n      from: wallet.address,\n      assetValue,\n      recipient,\n      router,\n      ...rest,\n    });\n\n    try {\n      switch (chain) {\n        case Chain.THORChain: {\n          const wallet = getWallet(chain);\n          return recipient === \"\" ? wallet.deposit(params) : wallet.transfer(params);\n        }\n\n        case Chain.Ethereum:\n        case Chain.BinanceSmartChain:\n        case Chain.Avalanche: {\n          const wallet = getWallet(chain);\n          const { getChecksumAddressFromAsset } = await import(\"@swapkit/toolbox-evm\");\n\n          const abi =\n            chain === Chain.Avalanche\n              ? TCAvalancheDepositABI\n              : chain === Chain.BinanceSmartChain\n                ? TCBscDepositABI\n                : TCEthereumVaultAbi;\n\n          return wallet.call<string>({\n            abi,\n            contractAddress:\n              router || ((await getInboundDataByChain(chain as EVMChain)).router as string),\n            funcName: \"depositWithExpiry\",\n            funcParams: [\n              recipient,\n              getChecksumAddressFromAsset({ chain, symbol, ticker }, chain),\n              assetValue.getBaseValue(\"string\"),\n              params.memo,\n              rest.expiration ||\n                Number.parseInt(`${(new Date().getTime() + 15 * 60 * 1000) / 1000}`),\n            ],\n            txOverrides: {\n              from: params.from,\n              value: assetValue.isGasAsset ? assetValue.getBaseValue(\"bigint\") : undefined,\n            },\n          });\n        }\n\n        default: {\n          if (wallet) {\n            return wallet.transfer(params);\n          }\n\n          throw new SwapKitError(\"core_wallet_connection_not_found\");\n        }\n      }\n    } catch (error) {\n      const errorMessage =\n        // @ts-expect-error Fine to use error as string\n        typeof error === \"string\" ? error.toLowerCase() : error?.message.toLowerCase();\n      const isInsufficientFunds = errorMessage?.includes(\"insufficient funds\");\n      const isGas = errorMessage?.includes(\"gas\");\n      const isServer = errorMessage?.includes(\"server\");\n      const isUserRejected = errorMessage?.includes(\"user rejected\");\n      const errorKey: ErrorKeys = isInsufficientFunds\n        ? \"core_transaction_deposit_insufficient_funds_error\"\n        : isGas\n          ? \"core_transaction_deposit_gas_error\"\n          : isServer\n            ? \"core_transaction_deposit_server_error\"\n            : isUserRejected\n              ? \"core_transaction_user_rejected\"\n              : \"core_transaction_deposit_error\";\n\n      throw new SwapKitError(errorKey, error);\n    }\n  }\n\n  function loan({ assetValue, memo, minAmount, type }: LoanParams) {\n    return depositToPool({\n      assetValue,\n      memo:\n        memo ||\n        getMemoForLoan(type === \"open\" ? MemoType.OPEN_LOAN : MemoType.CLOSE_LOAN, {\n          asset: assetValue.toString(),\n          minAmount: minAmount.toString(),\n          address: getWallet(assetValue.chain).address,\n        }),\n    });\n  }\n\n  function swap({ route, ...rest }: SwapParams<\"thorchain\", QuoteResponseRoute>) {\n    if (!route) throw new SwapKitError(\"core_swap_invalid_params\");\n\n    const isV2Route = \"legs\" in route;\n\n    if (isV2Route) {\n      return swapV2({ route, ...rest });\n    }\n\n    return swapV1({ route, ...rest } as SwapWithRouteParams);\n  }\n\n  // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: remove\n  async function swapV1(swapParams: SwapWithRouteParams) {\n    if (!(\"route\" in swapParams)) throw new SwapKitError(\"core_swap_invalid_params\");\n\n    const route = swapParams.route as QuoteRoute;\n\n    const { streamSwap, recipient, feeOptionKey } = swapParams as SwapWithRouteParams;\n    const {\n      meta: { quoteMode },\n      //   evmTransactionDetails: contractCallParams,\n    } = route;\n    const evmChain = quoteMode.startsWith(\"ERC20-\")\n      ? Chain.Ethereum\n      : quoteMode.startsWith(\"ARC20-\")\n        ? Chain.Avalanche\n        : quoteMode.startsWith(\"BEP20-\")\n          ? Chain.BinanceSmartChain\n          : undefined;\n\n    if (!route.complete) throw new SwapKitError(\"core_swap_route_not_complete\");\n\n    // TODO enable when BE is ready\n    //   if (contractCallParams && evmChain) {\n    //     const walletMethods = this.connectedWallets[evmChain];\n\n    //     if (!walletMethods?.call) {\n    //       throw new SwapKitError('core_wallet_connection_not_found');\n    //     }\n\n    //     const { contractAddress, contractMethod, contractParams, contractParamsStreaming } =\n    //       contractCallParams;\n\n    //     if (!(streamSwap ? contractParamsStreaming : contractParams)) {\n    //       throw new SwapKitError('core_swap_route_transaction_not_found');\n    //     }\n\n    //     return await walletMethods.call<string>({\n    //       contractAddress,\n    //       abi: lowercasedContractAbiMapping[contractAddress.toLowerCase()],\n    //       funcName: contractMethod,\n    //       funcParams: streamSwap ? contractParamsStreaming : contractParams,\n    //     });\n    //   }\n\n    if (AGG_SWAP.includes(quoteMode) && evmChain) {\n      const wallet = getWallet(evmChain);\n\n      if (!wallet?.sendTransaction) {\n        throw new SwapKitError(\"core_wallet_connection_not_found\");\n      }\n\n      const transaction = streamSwap ? route?.streamingSwap?.transaction : route?.transaction;\n\n      if (!transaction) {\n        throw new SwapKitError(\"core_swap_route_transaction_not_found\");\n      }\n\n      const { data, from, to, value } = route.transaction;\n      const params = {\n        data,\n        from,\n        to: to.toLowerCase(),\n        chainId: BigInt(ChainToChainId[evmChain]),\n        value: value ? BigInt(value) : 0n,\n      };\n\n      return wallet.sendTransaction(params, feeOptionKey || FeeOption.Average);\n    }\n\n    if (SWAP_OUT.includes(quoteMode)) {\n      if (!route.calldata.fromAsset) {\n        throw new SwapKitError(\"core_swap_asset_not_recognized\");\n      }\n\n      const asset = await AssetValue.from({\n        asset: route.calldata.fromAsset,\n        asyncTokenLookup: true,\n      });\n      if (!asset) {\n        throw new SwapKitError(\"core_swap_asset_not_recognized\");\n      }\n\n      const { address: recipient } = await getInboundDataByChain(asset.chain);\n      const {\n        contract: router,\n        calldata: { expiration, amountIn, memo, memoStreamingSwap },\n      } = route;\n\n      const assetValue = asset.add(SwapKitNumber.fromBigInt(BigInt(amountIn), asset.decimal));\n      const swapMemo = (streamSwap ? memoStreamingSwap || memo : memo) as string;\n\n      return deposit({\n        expiration,\n        assetValue,\n        memo: swapMemo,\n        feeOptionKey,\n        router,\n        recipient,\n      });\n    }\n\n    if (SWAP_IN.includes(quoteMode) && evmChain) {\n      const { calldata, contract: contractAddress } = route;\n      if (!contractAddress) {\n        throw new SwapKitError(\"core_swap_contract_not_found\");\n      }\n\n      const wallet = getWallet(evmChain);\n      const from = wallet.address;\n\n      if (!from) {\n        throw new SwapKitError(\"core_wallet_connection_not_found\");\n      }\n\n      const { getProvider, toChecksumAddress } = await import(\"@swapkit/toolbox-evm\");\n      const provider = getProvider(evmChain);\n      const abi = lowercasedContractAbiMapping[contractAddress.toLowerCase()];\n\n      if (!abi) {\n        throw new SwapKitError(\"core_swap_contract_not_supported\", { contractAddress });\n      }\n\n      const contract = wallet.createContract(contractAddress, abi, provider);\n\n      const tx = await contract.getFunction(\"swapIn\").populateTransaction(\n        ...getSwapInParams({\n          streamSwap,\n          toChecksumAddress,\n          contractAddress: contractAddress as AGG_CONTRACT_ADDRESS,\n          recipient,\n          calldata,\n        }),\n        { from },\n      );\n\n      return wallet.sendTransaction(tx, feeOptionKey || FeeOption.Average);\n    }\n\n    throw new SwapKitError(\"core_swap_quote_mode_not_supported\", { quoteMode });\n  }\n\n  async function swapV2({ route, feeOptionKey }: SwapParams<\"thorchain\", QuoteResponseRoute>) {\n    if (!route) throw new SwapKitError(\"core_swap_invalid_params\");\n\n    const { memo, expiration, targetAddress } = route;\n\n    const assetValue = await AssetValue.from({\n      asset: route.sellAsset,\n      value: route.sellAmount,\n      asyncTokenLookup: true,\n    });\n\n    if (!assetValue) {\n      throw new SwapKitError(\"core_swap_asset_not_recognized\");\n    }\n\n    const { address: recipient } = await getInboundDataByChain(assetValue.chain);\n\n    return deposit({\n      expiration: Number(expiration),\n      assetValue,\n      memo,\n      feeOptionKey,\n      router: targetAddress,\n      recipient,\n    });\n  }\n\n  async function addLiquidity(params: AddLiquidityParams) {\n    const { baseAssetTx, assetTx } = await pluginAddLiquidity(params);\n\n    return {\n      /**\n       * @deprecated use baseAssetTx instead\n       */\n      runeTx: baseAssetTx,\n      baseAssetTx,\n      assetTx,\n    };\n  }\n\n  async function createLiquidity(params: CreateLiquidityParams) {\n    const { baseAssetTx, assetTx } = await pluginCreateLiquidity(params);\n\n    return {\n      /**\n       * @deprecated use baseAssetTx instead\n       */\n      runeTx: baseAssetTx,\n      baseAssetTx,\n      assetTx,\n    };\n  }\n\n  return {\n    ...pluginMethods,\n    addLiquidity,\n    createLiquidity,\n    deposit,\n    getInboundDataByChain,\n    loan,\n    registerTHORName: register,\n    swap,\n    supportedSwapkitProviders: [ProviderName.THORCHAIN, ProviderName.THORCHAIN_STREAMING],\n    /**\n     * @deprecated Use registerTHORName instead\n     */\n    registerThorname: register,\n  };\n}\n\nexport const ThorchainPlugin = { thorchain: { plugin } } as const;\n\n/**\n * @deprecated Use import { ThorchainPlugin } from \"@swapkit/plugin-thorchain\" instead\n */\nexport const ThorchainProvider = ThorchainPlugin;\n",
    "import { SwapKitApi, type ThornodeEndpointParams } from \"@swapkit/api\";\nimport {\n  ApproveMode,\n  type ApproveReturnType,\n  AssetValue,\n  Chain,\n  type EVMChain,\n  EVMChains,\n  FeeOption,\n  type FullWallet,\n  MemoType,\n  SwapKitError,\n  getMemoForDeposit,\n  getMemoForLeaveAndBond,\n  getMemoForNamePreferredAssetRegister,\n  getMemoForNameRegister,\n  getMemoForSaverDeposit,\n  getMemoForSaverWithdraw,\n  getMemoForUnbond,\n  getMemoForWithdraw,\n  getMinAmountByChain,\n  wrapWithThrow,\n} from \"@swapkit/helpers\";\n\nimport type {\n  AddLiquidityParams,\n  AddLiquidityPartParams,\n  ApproveParams,\n  CoreTxParams,\n  CreateLiquidityParams,\n  NodeActionParams,\n  RegisterThornameParams,\n  SavingsParams,\n  SupportedChain,\n  WithdrawParams,\n} from \"./types\";\n\nconst gasFeeMultiplier: Record<FeeOption, number> = {\n  [FeeOption.Average]: 1.2,\n  [FeeOption.Fast]: 1.5,\n  [FeeOption.Fastest]: 2,\n};\n\nfunction getInboundDataFunction(params: ThornodeEndpointParams) {\n  return async function getInboundDataByChain<T extends Chain>(chain: T) {\n    if (\n      (params.type === \"thorchain\" && chain === Chain.THORChain) ||\n      (params.type === \"mayachain\" && chain === Chain.Maya)\n    ) {\n      return { gas_rate: \"0\", router: \"\", address: \"\", halted: false, chain };\n    }\n\n    const inboundData = await SwapKitApi.getInboundAddresses(params);\n    const chainAddressData = inboundData.find((item) => item.chain === chain);\n\n    if (!chainAddressData) throw new SwapKitError(\"core_inbound_data_not_found\");\n    if (chainAddressData?.halted) throw new SwapKitError(\"core_chain_halted\");\n\n    return chainAddressData;\n  };\n}\n\nexport function basePlugin({\n  stagenet,\n  deposit,\n  pluginChain,\n  getWallet,\n}: {\n  deposit: (params: CoreTxParams & { router?: string }) => Promise<string>;\n  pluginChain: Chain.Maya | Chain.THORChain;\n  stagenet: boolean;\n  getWallet: <T extends SupportedChain>(chain: T) => FullWallet[T];\n}) {\n  const type = pluginChain === Chain.Maya ? \"mayachain\" : \"thorchain\";\n  const getInboundDataByChain = getInboundDataFunction({ stagenet, type });\n\n  async function approve<T extends ApproveMode>({\n    assetValue,\n    type = \"checkOnly\" as T,\n  }: { type: T; assetValue: AssetValue }) {\n    const router = (await getInboundDataByChain(assetValue.chain)).router as string;\n\n    const chain = assetValue.chain as EVMChain;\n\n    const isEVMChain = EVMChains.includes(chain as EVMChain);\n    const isNativeEVM = isEVMChain && assetValue.isGasAsset;\n\n    if (isNativeEVM || !isEVMChain || assetValue.isSynthetic) {\n      return Promise.resolve(type === \"checkOnly\" ? true : \"approved\") as ApproveReturnType<T>;\n    }\n\n    const wallet = getWallet(chain);\n\n    if (!wallet) {\n      throw new SwapKitError(\"core_wallet_connection_not_found\");\n    }\n\n    const walletAction = type === \"checkOnly\" ? wallet.isApproved : wallet.approve;\n\n    if (!(assetValue.address && wallet.address)) {\n      throw new SwapKitError(\"core_approve_asset_address_or_from_not_found\");\n    }\n\n    return walletAction({\n      amount: assetValue.getBaseValue(\"bigint\"),\n      assetAddress: assetValue.address,\n      from: wallet.address,\n      spenderAddress: router,\n    });\n  }\n\n  async function depositToProtocol({ memo, assetValue }: { assetValue: AssetValue; memo: string }) {\n    const mimir = await SwapKitApi.getMimirInfo({ stagenet, type });\n\n    // check if trading is halted or not\n    if (mimir.HALTCHAINGLOBAL >= 1 || mimir.HALTTHORCHAIN >= 1) {\n      throw new SwapKitError(\"thorchain_chain_halted\");\n    }\n\n    return deposit({ assetValue, recipient: \"\", memo });\n  }\n\n  async function depositToPool({\n    assetValue,\n    memo,\n    feeOptionKey = FeeOption.Fast,\n  }: { assetValue: AssetValue; memo: string; feeOptionKey?: FeeOption }) {\n    const {\n      gas_rate = \"0\",\n      router,\n      address: poolAddress,\n    } = await getInboundDataByChain(assetValue.chain);\n\n    return deposit({\n      assetValue,\n      recipient: poolAddress,\n      memo,\n      router,\n      feeRate: Number.parseInt(gas_rate) * gasFeeMultiplier[feeOptionKey],\n    });\n  }\n\n  function approveAssetValue(params: ApproveParams) {\n    return approve({ ...params, type: ApproveMode.Approve });\n  }\n\n  function isAssetValueApproved(params: ApproveParams) {\n    return approve({ ...params, type: ApproveMode.CheckOnly });\n  }\n\n  function register({ assetValue, ...params }: RegisterThornameParams) {\n    return depositToProtocol({ assetValue, memo: getMemoForNameRegister(params) });\n  }\n\n  function registerPreferredAsset({\n    assetValue,\n    payoutAddress,\n    name,\n    ownerAddress,\n  }: {\n    assetValue: AssetValue;\n    payoutAddress?: string;\n    name: string;\n    ownerAddress: string;\n  }) {\n    const payout = payoutAddress || getWallet(assetValue.chain as SupportedChain).address;\n\n    return depositToProtocol({\n      assetValue,\n      memo: getMemoForNamePreferredAssetRegister({\n        asset: assetValue.toString(),\n        chain: assetValue.chain,\n        name,\n        owner: ownerAddress,\n        payout,\n      }),\n    });\n  }\n\n  function nodeAction({ type, assetValue, address }: NodeActionParams) {\n    const memo =\n      type === MemoType.UNBOND\n        ? getMemoForUnbond({ address, unbondAmount: assetValue.getBaseValue(\"number\") })\n        : getMemoForLeaveAndBond({ type, address });\n\n    const assetToTransfer = type === MemoType.BOND ? assetValue : getMinAmountByChain(pluginChain);\n    return depositToProtocol({ memo, assetValue: assetToTransfer });\n  }\n\n  async function createLiquidity({ baseAssetValue, assetValue }: CreateLiquidityParams) {\n    if (baseAssetValue.lte(0) || assetValue.lte(0)) {\n      throw new SwapKitError(\"core_transaction_create_liquidity_invalid_params\");\n    }\n\n    const assetAddress = getWallet(assetValue.chain as SupportedChain).address;\n    const baseAssetAddress = getWallet(pluginChain).address;\n\n    const baseAssetTx = await wrapWithThrow(() => {\n      return depositToPool({\n        assetValue: baseAssetValue,\n        memo: getMemoForDeposit({ ...assetValue, address: assetAddress }),\n      });\n    }, \"core_transaction_create_liquidity_base_error\");\n\n    const assetTx = await wrapWithThrow(() => {\n      return depositToPool({\n        assetValue,\n        memo: getMemoForDeposit({ ...assetValue, address: baseAssetAddress }),\n      });\n    }, \"core_transaction_create_liquidity_asset_error\");\n\n    return { baseAssetTx, assetTx };\n  }\n\n  function addLiquidityPart({\n    assetValue,\n    poolAddress,\n    address,\n    symmetric,\n  }: AddLiquidityPartParams) {\n    if (symmetric && !address) {\n      throw new SwapKitError(\"core_transaction_add_liquidity_invalid_params\");\n    }\n    const memo = getMemoForDeposit({\n      chain: poolAddress.split(\".\")[0] as Chain,\n      symbol: poolAddress.split(\".\")[1] as string,\n      address: symmetric ? address : \"\",\n    });\n\n    return depositToPool({ assetValue, memo });\n  }\n\n  // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: TODO: Refactor\n  async function addLiquidity({\n    baseAssetValue,\n    assetValue,\n    baseAssetAddr,\n    assetAddr,\n    isPendingSymmAsset,\n    mode = \"sym\",\n  }: AddLiquidityParams) {\n    const { chain, symbol } = assetValue;\n    const isSym = mode === \"sym\";\n    const baseTransfer = baseAssetValue?.gt(0) && (isSym || mode === \"baseAsset\");\n    const assetTransfer = assetValue?.gt(0) && (isSym || mode === \"asset\");\n    const includeBaseAddress = isPendingSymmAsset || baseTransfer;\n    const baseAssetWalletAddress = getWallet(pluginChain).address;\n\n    const baseAddress = includeBaseAddress ? baseAssetAddr || baseAssetWalletAddress : \"\";\n    const assetAddress =\n      isSym || mode === \"asset\" ? assetAddr || getWallet(chain as SupportedChain).address : \"\";\n\n    if (!(baseTransfer || assetTransfer)) {\n      throw new SwapKitError(\"core_transaction_add_liquidity_invalid_params\");\n    }\n    if (includeBaseAddress && !baseAddress) {\n      throw new SwapKitError(\"core_transaction_add_liquidity_base_address\");\n    }\n\n    const baseAssetTx =\n      baseTransfer && baseAssetValue\n        ? await wrapWithThrow(() => {\n            return depositToPool({\n              assetValue: baseAssetValue,\n              memo: getMemoForDeposit({ chain, symbol, address: assetAddress }),\n            });\n          }, \"core_transaction_add_liquidity_base_error\")\n        : undefined;\n\n    const assetTx =\n      assetTransfer && assetValue\n        ? await wrapWithThrow(() => {\n            return depositToPool({\n              assetValue,\n              memo: getMemoForDeposit({ chain, symbol, address: baseAddress }),\n            });\n          }, \"core_transaction_add_liquidity_asset_error\")\n        : undefined;\n\n    return { baseAssetTx, assetTx };\n  }\n\n  function savings({ assetValue, memo, percent, type }: SavingsParams) {\n    const { chain, symbol } = assetValue;\n    const isDeposit = type === \"add\";\n    const memoString = isDeposit\n      ? getMemoForSaverDeposit({ symbol, chain })\n      : getMemoForSaverWithdraw({\n          basisPoints: Math.min(10000, Math.round(percent * 100)),\n          symbol,\n          chain,\n        });\n\n    return depositToPool({\n      memo: memo || memoString,\n      assetValue: isDeposit ? assetValue : getMinAmountByChain(chain),\n    });\n  }\n\n  function withdraw({ memo, assetValue, percent, from, to }: WithdrawParams) {\n    const targetAsset =\n      to === \"baseAsset\" && from !== \"baseAsset\"\n        ? AssetValue.from({ chain: pluginChain })\n        : (from === \"sym\" && to === \"sym\") || from === \"baseAsset\" || from === \"asset\"\n          ? undefined\n          : assetValue;\n\n    const value = getMinAmountByChain(from === \"asset\" ? assetValue.chain : pluginChain);\n    const memoString =\n      memo ||\n      getMemoForWithdraw({\n        symbol: assetValue.symbol,\n        chain: assetValue.chain,\n        ticker: assetValue.ticker,\n        basisPoints: Math.min(10000, Math.round(percent * 100)),\n        targetAsset: targetAsset?.toString(),\n      });\n\n    return depositToPool({ assetValue: value, memo: memoString });\n  }\n\n  return {\n    addLiquidity,\n    addLiquidityPart,\n    approveAssetValue,\n    createLiquidity,\n    depositToPool,\n    getInboundDataByChain,\n    isAssetValueApproved,\n    nodeAction,\n    register,\n    registerPreferredAsset,\n    savings,\n    withdraw,\n  };\n}\n",
    "import type { QuoteRoute } from \"@swapkit/api\";\nimport {\n  type AGG_CONTRACT_ADDRESS,\n  SwapKitError,\n  lowercasedGenericAbiMappings,\n} from \"@swapkit/helpers\";\n\ntype SwapInParams = {\n  calldata: QuoteRoute[\"calldata\"];\n  recipient: string;\n  streamSwap?: boolean;\n  contractAddress: AGG_CONTRACT_ADDRESS;\n  toChecksumAddress: (address: string) => string;\n};\n\nexport const getSwapInParams = ({\n  streamSwap,\n  contractAddress,\n  recipient,\n  toChecksumAddress,\n  calldata,\n}: SwapInParams) => {\n  const isGeneric = !!lowercasedGenericAbiMappings[contractAddress.toLowerCase()];\n  const {\n    amount,\n    amountOutMin = \"\",\n    data = \"\",\n    deadline,\n    memo,\n    router,\n    memoStreamingSwap,\n    tcMemo,\n    tcRouter,\n    tcVault,\n    vault,\n    token,\n  } = calldata;\n\n  if (isGeneric && !router) {\n    throw new SwapKitError({ errorKey: \"thorchain_swapin_router_required\", info: calldata });\n  }\n\n  /**\n   * Data structure for contract calls\n   * GENERIC: tcRouter, tcVault, tcMemo, token, amount, router, data, deadline\n   * ETH_UNISWAP: tcRouter, tcVault, tcMemo, token, amount, amountOutMin, deadline\n   * AVAX_PANGOLIN: tcRouter, tcVault, tcMemo, token, amount, amountOutMin, deadline\n   * AVAX_WOOFI: router, vault, memo, token, amount, amountOutMin, deadline\n   */\n\n  const baseMemo = tcMemo || memo;\n  const transactionMemo = streamSwap ? memoStreamingSwap || baseMemo : baseMemo;\n\n  if (!(tcVault || vault)) {\n    throw new SwapKitError({ errorKey: \"thorchain_swapin_vault_required\", info: calldata });\n  }\n  if (!(tcRouter || router)) {\n    throw new SwapKitError({ errorKey: \"thorchain_swapin_router_required\", info: calldata });\n  }\n  if (!transactionMemo) {\n    throw new SwapKitError({ errorKey: \"thorchain_swapin_memo_required\", info: calldata });\n  }\n  if (!token) {\n    throw new SwapKitError({ errorKey: \"thorchain_swapin_token_required\", info: calldata });\n  }\n\n  const baseParams = [\n    // v2 contracts don't have tcVault, tcRouter, tcMemo but vault, router, memo\n    toChecksumAddress((tcRouter || router) as string),\n    toChecksumAddress((tcVault || vault) as string),\n    transactionMemo.replace(\"{recipientAddress}\", recipient),\n    toChecksumAddress(token),\n    amount,\n  ];\n\n  const contractParams = isGeneric\n    ? [toChecksumAddress(router as string), data, deadline]\n    : [amountOutMin, deadline];\n\n  return [...baseParams, ...contractParams];\n};\n",
    "import { Chain } from \"@swapkit/helpers\";\nimport type { CoreTxParams } from \"./types\";\n\nexport const validateAddressType = ({\n  chain,\n  address,\n}: {\n  chain: Chain;\n  address?: string;\n}) => {\n  if (!address) return false;\n\n  switch (chain) {\n    case Chain.Bitcoin:\n      // filter out taproot addresses\n      return !address.startsWith(\"bc1p\");\n    default:\n      return true;\n  }\n};\n\nexport function prepareTxParams({\n  assetValue,\n  from,\n  memo = \"\",\n  ...restTxParams\n}: CoreTxParams & { from: string; router?: string }) {\n  return {\n    ...restTxParams,\n    memo,\n    from,\n    assetValue,\n  };\n}\n",
    "import type { QuoteResponseRoute } from \"@swapkit/api\";\nimport {\n  AssetValue,\n  Chain,\n  type CosmosChain,\n  type EVMChain,\n  type ErrorKeys,\n  MayaArbitrumVaultAbi,\n  MayaEthereumVaultAbi,\n  ProviderName,\n  SwapKitError,\n  type SwapKitPluginParams,\n  type SwapParams,\n  type UTXOChain,\n} from \"@swapkit/helpers\";\nimport { basePlugin } from \"./basePlugin.ts\";\nimport { prepareTxParams, validateAddressType } from \"./shared.ts\";\nimport type { AddLiquidityParams, CoreTxParams, CreateLiquidityParams } from \"./types.ts\";\n\ntype SupportedChain = EVMChain | CosmosChain | UTXOChain;\n\nfunction plugin({ getWallet, stagenet = false }: SwapKitPluginParams) {\n  const {\n    getInboundDataByChain,\n    register,\n    addLiquidity: pluginAddLiquidity,\n    createLiquidity: pluginCreateLiquidity,\n    ...pluginMethods\n  } = basePlugin({\n    deposit,\n    pluginChain: Chain.Maya,\n    stagenet,\n    getWallet,\n  });\n\n  // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: TODO refactor\n  async function deposit({\n    assetValue,\n    recipient,\n    router,\n    ...rest\n  }: CoreTxParams & { router?: string }) {\n    const { chain, symbol, ticker } = assetValue;\n\n    const wallet = getWallet(chain as SupportedChain);\n    if (!wallet) {\n      throw new SwapKitError(\"core_wallet_connection_not_found\");\n    }\n\n    const address = wallet.address;\n\n    const isAddressValidated = validateAddressType({ address, chain });\n    if (!isAddressValidated) {\n      throw new SwapKitError(\"core_transaction_invalid_sender_address\");\n    }\n\n    const params = prepareTxParams({ from: address, assetValue, recipient, router, ...rest });\n\n    try {\n      switch (chain) {\n        case Chain.Maya: {\n          const wallet = getWallet(chain);\n          return recipient === \"\" ? wallet.deposit(params) : wallet.transfer(params);\n        }\n\n        case Chain.Arbitrum:\n        case Chain.Ethereum: {\n          const { getChecksumAddressFromAsset } = await import(\"@swapkit/toolbox-evm\");\n          const wallet = getWallet(chain);\n\n          const abi = chain === Chain.Arbitrum ? MayaArbitrumVaultAbi : MayaEthereumVaultAbi;\n          const funcParams = [\n            recipient,\n            getChecksumAddressFromAsset({ chain, symbol, ticker }, chain),\n            assetValue.getBaseValue(\"string\"),\n            params.memo,\n            rest.expiration || Number.parseInt(`${(new Date().getTime() + 15 * 60 * 1000) / 1000}`),\n          ];\n          const txOverrides = {\n            from: params.from,\n            value: assetValue.isGasAsset ? assetValue.getBaseValue(\"bigint\") : undefined,\n          };\n\n          const tx = await wallet.call<string>({\n            abi,\n            funcName: \"depositWithExpiry\",\n            funcParams,\n            txOverrides,\n            contractAddress:\n              router || ((await getInboundDataByChain(chain as EVMChain)).router as string),\n          });\n\n          return tx;\n        }\n\n        default: {\n          if (wallet) {\n            return wallet.transfer(params);\n          }\n\n          throw new SwapKitError(\"core_wallet_connection_not_found\");\n        }\n      }\n    } catch (error) {\n      const errorMessage =\n        // @ts-expect-error Fine to use error as string\n        typeof error === \"string\" ? error.toLowerCase() : error?.message.toLowerCase();\n      const isInsufficientFunds = errorMessage?.includes(\"insufficient funds\");\n      const isGas = errorMessage?.includes(\"gas\");\n      const isServer = errorMessage?.includes(\"server\");\n      const isUserRejected = errorMessage?.includes(\"user rejected\");\n      const errorKey: ErrorKeys = isInsufficientFunds\n        ? \"core_transaction_deposit_insufficient_funds_error\"\n        : isGas\n          ? \"core_transaction_deposit_gas_error\"\n          : isServer\n            ? \"core_transaction_deposit_server_error\"\n            : isUserRejected\n              ? \"core_transaction_user_rejected\"\n              : \"core_transaction_deposit_error\";\n\n      throw new SwapKitError(errorKey, error);\n    }\n  }\n\n  async function swap(swapParams: SwapParams<\"mayaprotocol\", QuoteResponseRoute>) {\n    const { feeOptionKey, route } = swapParams;\n\n    const { memo, expiration, targetAddress } = route;\n\n    const assetValue = await AssetValue.from({\n      asset: route.sellAsset,\n      value: route.sellAmount,\n      asyncTokenLookup: true,\n    });\n    const evmChain = assetValue.chain;\n\n    if (!assetValue) {\n      throw new SwapKitError(\"core_swap_asset_not_recognized\");\n    }\n\n    const { address: recipient } = await getInboundDataByChain(evmChain);\n\n    return deposit({\n      expiration: Number(expiration),\n      assetValue,\n      memo,\n      feeOptionKey,\n      router: targetAddress,\n      recipient,\n    });\n  }\n\n  async function addLiquidity(params: AddLiquidityParams) {\n    const { baseAssetTx, assetTx } = await pluginAddLiquidity(params);\n\n    return {\n      /**\n       * @deprecated use baseAssetTx instead\n       */\n      cacaoTx: baseAssetTx,\n      baseAssetTx,\n      assetTx,\n    };\n  }\n\n  async function createLiquidity(params: CreateLiquidityParams) {\n    const { baseAssetTx, assetTx } = await pluginCreateLiquidity(params);\n\n    return {\n      /**\n       * @deprecated use baseAssetTx instead\n       */\n      cacaoTx: baseAssetTx,\n      baseAssetTx,\n      assetTx,\n    };\n  }\n\n  return {\n    ...pluginMethods,\n    addLiquidity,\n    createLiquidity,\n    getInboundDataByChain,\n    deposit,\n    registerMAYAName: register,\n    swap,\n    supportedSwapkitProviders: [ProviderName.MAYACHAIN, ProviderName.MAYACHAIN_STREAMING],\n    /**\n     * @deprecated use registerMAYAName instead\n     */\n    registerMayaname: register,\n  };\n}\n\nexport const MayachainPlugin = { mayachain: { plugin } } as const;\n"
  ],
  "mappings": "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",
  "debugId": "CB22D64ABA171B0464756E2164756E21",
  "names": []
}