var n=((U)=>typeof require!=="undefined"?require:typeof Proxy!=="undefined"?new Proxy(U,{get:(D,_)=>(typeof require!=="undefined"?require:D)[_]}):U)(function(U){if(typeof require!=="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+U+'" is not supported')});import{AGG_SWAP as I1,AssetValue as a,Chain as W,ChainToChainId as k1,FeeOption as e,MemoType as z1,ProviderName as H1,SWAP_IN as D1,SWAP_OUT as F1,SwapKitError as k,SwapKitNumber as f1,TCAvalancheDepositABI as v1,TCBscDepositABI as E1,TCEthereumVaultAbi as P1,getMemoForLoan as W1,lowercasedContractAbiMapping as K1}from"@swapkit/helpers";import{SwapKitApi as t}from"@swapkit/api";import{ApproveMode as i,AssetValue as $1,Chain as l,EVMChains as Y1,FeeOption as c,MemoType as r,SwapKitError as T,getMemoForDeposit as y,getMemoForLeaveAndBond as j1,getMemoForNamePreferredAssetRegister as U1,getMemoForNameRegister as _1,getMemoForSaverDeposit as G1,getMemoForSaverWithdraw as R1,getMemoForUnbond as N1,getMemoForWithdraw as L1,getMinAmountByChain as u,wrapWithThrow as V}from"@swapkit/helpers";function q1(U){return async function D(_){if(U.type==="thorchain"&&_===l.THORChain||U.type==="mayachain"&&_===l.Maya)return{gas_rate:"0",router:"",address:"",halted:!1,chain:_};const x=(await t.getInboundAddresses(U)).find((f)=>f.chain===_);if(!x)throw new T("core_inbound_data_not_found");if(x?.halted)throw new T("core_chain_halted");return x}}function m({stagenet:U,deposit:D,pluginChain:_,getWallet:N}){const x=_===l.Maya?"mayachain":"thorchain",f=q1({stagenet:U,type:x});async function M({assetValue:z,type:H="checkOnly"}){const X=(await f(z.chain)).router,J=z.chain,Z=Y1.includes(J);if(Z&&z.isGasAsset||!Z||z.isSynthetic)return Promise.resolve(H==="checkOnly"?!0:"approved");const Y=N(J);if(!Y)throw new T("core_wallet_connection_not_found");const R=H==="checkOnly"?Y.isApproved:Y.approve;if(!(z.address&&Y.address))throw new T("core_approve_asset_address_or_from_not_found");return R({amount:z.getBaseValue("bigint"),assetAddress:z.address,from:Y.address,spenderAddress:X})}async function E({memo:z,assetValue:H}){const X=await t.getMimirInfo({stagenet:U,type:x});if(X.HALTCHAINGLOBAL>=1||X.HALTTHORCHAIN>=1)throw new T("thorchain_chain_halted");return D({assetValue:H,recipient:"",memo:z})}async function B({assetValue:z,memo:H,feeOptionKey:X=c.Fast}){const{gas_rate:J="0",router:Z,address:j}=await f(z.chain);return D({assetValue:z,recipient:j,memo:H,router:Z,feeRate:Number.parseInt(J)*O1[X]})}function S(z){return M({...z,type:i.Approve})}function b(z){return M({...z,type:i.CheckOnly})}function L({assetValue:z,...H}){return E({assetValue:z,memo:_1(H)})}function I({assetValue:z,payoutAddress:H,name:X,ownerAddress:J}){const Z=H||N(z.chain).address;return E({assetValue:z,memo:U1({asset:z.toString(),chain:z.chain,name:X,owner:J,payout:Z})})}function F({type:z,assetValue:H,address:X}){const J=z===r.UNBOND?N1({address:X,unbondAmount:H.getBaseValue("number")}):j1({type:z,address:X}),Z=z===r.BOND?H:u(_);return E({memo:J,assetValue:Z})}async function P({baseAssetValue:z,assetValue:H}){if(z.lte(0)||H.lte(0))throw new T("core_transaction_create_liquidity_invalid_params");const X=N(H.chain).address,J=N(_).address,Z=await V(()=>{return B({assetValue:z,memo:y({...H,address:X})})},"core_transaction_create_liquidity_base_error"),j=await V(()=>{return B({assetValue:H,memo:y({...H,address:J})})},"core_transaction_create_liquidity_asset_error");return{baseAssetTx:Z,assetTx:j}}function Q({assetValue:z,poolAddress:H,address:X,symmetric:J}){if(J&&!X)throw new T("core_transaction_add_liquidity_invalid_params");const Z=y({chain:H.split(".")[0],symbol:H.split(".")[1],address:J?X:""});return B({assetValue:z,memo:Z})}async function $({baseAssetValue:z,assetValue:H,baseAssetAddr:X,assetAddr:J,isPendingSymmAsset:Z,mode:j="sym"}){const{chain:Y,symbol:R}=H,q=j==="sym",v=z?.gt(0)&&(q||j==="baseAsset"),K=H?.gt(0)&&(q||j==="asset"),C=Z||v,g=N(_).address,o=C?X||g:"",Q1=q||j==="asset"?J||N(Y).address:"";if(!(v||K))throw new T("core_transaction_add_liquidity_invalid_params");if(C&&!o)throw new T("core_transaction_add_liquidity_base_address");const X1=v&&z?await V(()=>{return B({assetValue:z,memo:y({chain:Y,symbol:R,address:Q1})})},"core_transaction_add_liquidity_base_error"):void 0,Z1=K&&H?await V(()=>{return B({assetValue:H,memo:y({chain:Y,symbol:R,address:o})})},"core_transaction_add_liquidity_asset_error"):void 0;return{baseAssetTx:X1,assetTx:Z1}}function G({assetValue:z,memo:H,percent:X,type:J}){const{chain:Z,symbol:j}=z,Y=J==="add",R=Y?G1({symbol:j,chain:Z}):R1({basisPoints:Math.min(1e4,Math.round(X*100)),symbol:j,chain:Z});return B({memo:H||R,assetValue:Y?z:u(Z)})}function O({memo:z,assetValue:H,percent:X,from:J,to:Z}){const j=Z==="baseAsset"&&J!=="baseAsset"?$1.from({chain:_}):J==="sym"&&Z==="sym"||J==="baseAsset"||J==="asset"?void 0:H,Y=u(J==="asset"?H.chain:_),R=z||L1({symbol:H.symbol,chain:H.chain,ticker:H.ticker,basisPoints:Math.min(1e4,Math.round(X*100)),targetAsset:j?.toString()});return B({assetValue:Y,memo:R})}return{addLiquidity:$,addLiquidityPart:Q,approveAssetValue:S,createLiquidity:P,depositToPool:B,getInboundDataByChain:f,isAssetValueApproved:b,nodeAction:F,register:L,registerPreferredAsset:I,savings:G,withdraw:O}}var O1={[c.Average]:1.2,[c.Fast]:1.5,[c.Fastest]:2};import{SwapKitError as w,lowercasedGenericAbiMappings as x1}from"@swapkit/helpers";var s=({streamSwap:U,contractAddress:D,recipient:_,toChecksumAddress:N,calldata:x})=>{const f=!!x1[D.toLowerCase()],{amount:M,amountOutMin:E="",data:B="",deadline:S,memo:b,router:L,memoStreamingSwap:I,tcMemo:F,tcRouter:P,tcVault:Q,vault:$,token:G}=x;if(f&&!L)throw new w({errorKey:"thorchain_swapin_router_required",info:x});const O=F||b,z=U?I||O:O;if(!(Q||$))throw new w({errorKey:"thorchain_swapin_vault_required",info:x});if(!(P||L))throw new w({errorKey:"thorchain_swapin_router_required",info:x});if(!z)throw new w({errorKey:"thorchain_swapin_memo_required",info:x});if(!G)throw new w({errorKey:"thorchain_swapin_token_required",info:x});const H=[N(P||L),N(Q||$),z.replace("{recipientAddress}",_),N(G),M],X=f?[N(L),B,S]:[E,S];return[...H,...X]};import{Chain as B1}from"@swapkit/helpers";function d({assetValue:U,from:D,memo:_="",...N}){return{...N,memo:_,from:D,assetValue:U}}var p=({chain:U,address:D})=>{if(!D)return!1;switch(U){case B1.Bitcoin:return!D.startsWith("bc1p");default:return!0}};function T1({getWallet:U,stagenet:D=!1}){const{getInboundDataByChain:_,register:N,depositToPool:x,addLiquidity:f,createLiquidity:M,...E}=m({getWallet:U,pluginChain:W.THORChain,stagenet:D,deposit:B});async function B({assetValue:Q,recipient:$,router:G,...O}){const{chain:z,symbol:H,ticker:X}=Q,J=U(z);if(!J)throw new k("core_wallet_connection_not_found");if(!p({address:J.address,chain:z}))throw new k("core_transaction_invalid_sender_address");const j=d({from:J.address,assetValue:Q,recipient:$,router:G,...O});try{switch(z){case W.THORChain:{const Y=U(z);return $===""?Y.deposit(j):Y.transfer(j)}case W.Ethereum:case W.BinanceSmartChain:case W.Avalanche:{const Y=U(z),{getChecksumAddressFromAsset:R}=await import("@swapkit/toolbox-evm"),q=z===W.Avalanche?v1:z===W.BinanceSmartChain?E1:P1;return Y.call({abi:q,contractAddress:G||(await _(z)).router,funcName:"depositWithExpiry",funcParams:[$,R({chain:z,symbol:H,ticker:X},z),Q.getBaseValue("string"),j.memo,O.expiration||Number.parseInt(`${(new Date().getTime()+900000)/1000}`)],txOverrides:{from:j.from,value:Q.isGasAsset?Q.getBaseValue("bigint"):void 0}})}default:{if(J)return J.transfer(j);throw new k("core_wallet_connection_not_found")}}}catch(Y){const R=typeof Y==="string"?Y.toLowerCase():Y?.message.toLowerCase(),q=R?.includes("insufficient funds"),v=R?.includes("gas"),K=R?.includes("server"),C=R?.includes("user rejected");throw new k(q?"core_transaction_deposit_insufficient_funds_error":v?"core_transaction_deposit_gas_error":K?"core_transaction_deposit_server_error":C?"core_transaction_user_rejected":"core_transaction_deposit_error",Y)}}function S({assetValue:Q,memo:$,minAmount:G,type:O}){return x({assetValue:Q,memo:$||W1(O==="open"?z1.OPEN_LOAN:z1.CLOSE_LOAN,{asset:Q.toString(),minAmount:G.toString(),address:U(Q.chain).address})})}function b({route:Q,...$}){if(!Q)throw new k("core_swap_invalid_params");if("legs"in Q)return I({route:Q,...$});return L({route:Q,...$})}async function L(Q){if(!("route"in Q))throw new k("core_swap_invalid_params");const $=Q.route,{streamSwap:G,recipient:O,feeOptionKey:z}=Q,{meta:{quoteMode:H}}=$,X=H.startsWith("ERC20-")?W.Ethereum:H.startsWith("ARC20-")?W.Avalanche:H.startsWith("BEP20-")?W.BinanceSmartChain:void 0;if(!$.complete)throw new k("core_swap_route_not_complete");if(I1.includes(H)&&X){const J=U(X);if(!J?.sendTransaction)throw new k("core_wallet_connection_not_found");if(!(G?$?.streamingSwap?.transaction:$?.transaction))throw new k("core_swap_route_transaction_not_found");const{data:j,from:Y,to:R,value:q}=$.transaction,v={data:j,from:Y,to:R.toLowerCase(),chainId:BigInt(k1[X]),value:q?BigInt(q):0n};return J.sendTransaction(v,z||e.Average)}if(F1.includes(H)){if(!$.calldata.fromAsset)throw new k("core_swap_asset_not_recognized");const J=await a.from({asset:$.calldata.fromAsset,asyncTokenLookup:!0});if(!J)throw new k("core_swap_asset_not_recognized");const{address:Z}=await _(J.chain),{contract:j,calldata:{expiration:Y,amountIn:R,memo:q,memoStreamingSwap:v}}=$,K=J.add(f1.fromBigInt(BigInt(R),J.decimal));return B({expiration:Y,assetValue:K,memo:G?v||q:q,feeOptionKey:z,router:j,recipient:Z})}if(D1.includes(H)&&X){const{calldata:J,contract:Z}=$;if(!Z)throw new k("core_swap_contract_not_found");const j=U(X),Y=j.address;if(!Y)throw new k("core_wallet_connection_not_found");const{getProvider:R,toChecksumAddress:q}=await import("@swapkit/toolbox-evm"),v=R(X),K=K1[Z.toLowerCase()];if(!K)throw new k("core_swap_contract_not_supported",{contractAddress:Z});const g=await j.createContract(Z,K,v).getFunction("swapIn").populateTransaction(...s({streamSwap:G,toChecksumAddress:q,contractAddress:Z,recipient:O,calldata:J}),{from:Y});return j.sendTransaction(g,z||e.Average)}throw new k("core_swap_quote_mode_not_supported",{quoteMode:H})}async function I({route:Q,feeOptionKey:$}){if(!Q)throw new k("core_swap_invalid_params");const{memo:G,expiration:O,targetAddress:z}=Q,H=await a.from({asset:Q.sellAsset,value:Q.sellAmount,asyncTokenLookup:!0});if(!H)throw new k("core_swap_asset_not_recognized");const{address:X}=await _(H.chain);return B({expiration:Number(O),assetValue:H,memo:G,feeOptionKey:$,router:z,recipient:X})}async function F(Q){const{baseAssetTx:$,assetTx:G}=await f(Q);return{runeTx:$,baseAssetTx:$,assetTx:G}}async function P(Q){const{baseAssetTx:$,assetTx:G}=await M(Q);return{runeTx:$,baseAssetTx:$,assetTx:G}}return{...E,addLiquidity:F,createLiquidity:P,deposit:B,getInboundDataByChain:_,loan:S,registerTHORName:N,swap:b,supportedSwapkitProviders:[H1.THORCHAIN,H1.THORCHAIN_STREAMING],registerThorname:N}}var M1={thorchain:{plugin:T1}},o1=M1;import{AssetValue as S1,Chain as A,MayaArbitrumVaultAbi as b1,MayaEthereumVaultAbi as C1,ProviderName as J1,SwapKitError as h}from"@swapkit/helpers";function y1({getWallet:U,stagenet:D=!1}){const{getInboundDataByChain:_,register:N,addLiquidity:x,createLiquidity:f,...M}=m({deposit:E,pluginChain:A.Maya,stagenet:D,getWallet:U});async function E({assetValue:L,recipient:I,router:F,...P}){const{chain:Q,symbol:$,ticker:G}=L,O=U(Q);if(!O)throw new h("core_wallet_connection_not_found");const z=O.address;if(!p({address:z,chain:Q}))throw new h("core_transaction_invalid_sender_address");const X=d({from:z,assetValue:L,recipient:I,router:F,...P});try{switch(Q){case A.Maya:{const J=U(Q);return I===""?J.deposit(X):J.transfer(X)}case A.Arbitrum:case A.Ethereum:{const{getChecksumAddressFromAsset:J}=await import("@swapkit/toolbox-evm"),Z=U(Q),j=Q===A.Arbitrum?b1:C1,Y=[I,J({chain:Q,symbol:$,ticker:G},Q),L.getBaseValue("string"),X.memo,P.expiration||Number.parseInt(`${(new Date().getTime()+900000)/1000}`)],R={from:X.from,value:L.isGasAsset?L.getBaseValue("bigint"):void 0};return await Z.call({abi:j,funcName:"depositWithExpiry",funcParams:Y,txOverrides:R,contractAddress:F||(await _(Q)).router})}default:{if(O)return O.transfer(X);throw new h("core_wallet_connection_not_found")}}}catch(J){const Z=typeof J==="string"?J.toLowerCase():J?.message.toLowerCase(),j=Z?.includes("insufficient funds"),Y=Z?.includes("gas"),R=Z?.includes("server"),q=Z?.includes("user rejected");throw new h(j?"core_transaction_deposit_insufficient_funds_error":Y?"core_transaction_deposit_gas_error":R?"core_transaction_deposit_server_error":q?"core_transaction_user_rejected":"core_transaction_deposit_error",J)}}async function B(L){const{feeOptionKey:I,route:F}=L,{memo:P,expiration:Q,targetAddress:$}=F,G=await S1.from({asset:F.sellAsset,value:F.sellAmount,asyncTokenLookup:!0}),O=G.chain;if(!G)throw new h("core_swap_asset_not_recognized");const{address:z}=await _(O);return E({expiration:Number(Q),assetValue:G,memo:P,feeOptionKey:I,router:$,recipient:z})}async function S(L){const{baseAssetTx:I,assetTx:F}=await x(L);return{cacaoTx:I,baseAssetTx:I,assetTx:F}}async function b(L){const{baseAssetTx:I,assetTx:F}=await f(L);return{cacaoTx:I,baseAssetTx:I,assetTx:F}}return{...M,addLiquidity:S,createLiquidity:b,getInboundDataByChain:_,deposit:E,registerMAYAName:N,swap:B,supportedSwapkitProviders:[J1.MAYACHAIN,J1.MAYACHAIN_STREAMING],registerMayaname:N}}var a1={mayachain:{plugin:y1}};export{s as getSwapInParams,o1 as ThorchainProvider,M1 as ThorchainPlugin,a1 as MayachainPlugin};

//# debugId=CB22D64ABA171B0464756E2164756E21
