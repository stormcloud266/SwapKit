var i=((Q)=>typeof require!=="undefined"?require:typeof Proxy!=="undefined"?new Proxy(Q,{get:(G,Y)=>(typeof require!=="undefined"?require:G)[Y]}):Q)(function(Q){if(typeof require!=="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+Q+'" is not supported')});export*from"@swapkit/api";export*from"@swapkit/helpers";import{stripToCashAddress as B$}from"@swapkit/toolbox-utxo";import{ApproveMode as H,AssetValue as k,Chain as R,EVMChains as s,ProviderName as E,SwapKitError as U}from"@swapkit/helpers";import{estimateTransactionFee as t,cosmosValidateAddress as l}from"@swapkit/toolbox-cosmos";import{evmValidateAddress as e}from"@swapkit/toolbox-evm";import{substrateValidateAddress as a}from"@swapkit/toolbox-substrate";import{utxoValidateAddress as $$}from"@swapkit/toolbox-utxo";import{Chain as D,ChainToExplorerUrl as M,SwapKitError as n}from"@swapkit/helpers";function f({chain:Q,txHash:G}){const Y=M[Q];switch(Q){case D.Maya:case D.Kujira:case D.Cosmos:case D.THORChain:case D.Solana:return`${Y}/tx/${G.startsWith("0x")?G.slice(2):G}`;case D.Arbitrum:case D.Avalanche:case D.BinanceSmartChain:case D.Ethereum:case D.Optimism:case D.Polkadot:case D.Polygon:return`${Y}/tx/${G.startsWith("0x")?G:`0x${G}`}`;case D.Litecoin:case D.Bitcoin:case D.BitcoinCash:case D.Dogecoin:return`${Y}/transaction/${G.toLowerCase()}`;default:throw new n({errorKey:"core_explorer_unsupported_chain",info:{chain:Q}})}}function O({chain:Q,address:G}){const Y=M[Q];switch(Q){case D.Solana:return`${Y}/account/${G}`;default:return`${Y}/address/${G}`}}function Q$({apis:Q={},config:G={},plugins:Y,rpcUrls:N={},stagenet:S=!1,wallets:b={}}={}){const j={},B=Object.entries(Y||{}).reduce(($,[_,{plugin:L,config:q}])=>{const z=L({getWallet:J,stagenet:S,config:q??G});return $[_]=z,$},{}),v=Object.entries(b).reduce(($,[_,L])=>{const q=L({addChain:A,config:G,apis:Q,rpcUrls:N});return $[_]=q,$},{});function K($){const _=B[$]||Object.values(B)[0];if(!_)throw new U("core_plugin_not_found");return _}function y($){const _=Object.values(B).find((L)=>L.supportedSwapkitProviders?.includes($));if(!_)throw new U("core_plugin_not_found");return _}function A($){const _=J($.chain);j[$.chain]={..._,...$}}function x({assetValue:$,type:_="checkOnly",contractAddress:L}){const q=B[L];if(q){if(_===H.CheckOnly&&"isAssetValueApproved"in q)return q.isAssetValueApproved({assetValue:$});if(_===H.Approve&&"approveAssetValue"in q)return q.approveAssetValue({assetValue:$});throw new U({errorKey:"core_approve_asset_target_invalid",info:{message:`Target ${String(L)} cannot be used for approve operation`}})}const z=$.chain,T=s.includes(z);if(T&&$.isGasAsset||!T||$.isSynthetic)return Promise.resolve(_==="checkOnly"?!0:"approved");const X=J(z),Z=_==="checkOnly"?X.isApproved:X.approve;if(!Z)throw new U("core_wallet_connection_not_found");if(!($.address&&X.address&&typeof L==="string"))throw new U("core_approve_asset_address_or_from_not_found");return Z({amount:$.getBaseValue("bigint"),assetAddress:$.address,from:X.address,spenderAddress:L})}function J($){return j[$]}function W(){return{...j}}function C($){return J($)?.address||""}function m($,_){return x({assetValue:$,contractAddress:_,type:H.Approve})}function V($,_){return x({assetValue:$,contractAddress:_,type:H.CheckOnly})}function F($){J($)?.disconnect?.(),delete j[$]}function w(){for(let $ of Object.keys(j))F($)}function o($,_){return _?P($).then(({balance:L})=>L):J($)?.balance||[]}function u({address:$,chain:_}){switch(_){case R.Arbitrum:case R.Avalanche:case R.Optimism:case R.BinanceSmartChain:case R.Polygon:case R.Ethereum:return e({address:$});case R.Litecoin:case R.Dash:case R.Dogecoin:case R.BitcoinCash:case R.Bitcoin:return $$({address:$,chain:_});case R.Cosmos:case R.Kujira:case R.Maya:case R.THORChain:return l({address:$,chain:_});case R.Polkadot:return a({address:$,chain:_});default:return!1}}async function P($,_=!0){const L=[k.from({chain:$})],q=J($);if(!q)throw new U("core_wallet_connection_not_found");if("getBalance"in q){const z=await q.getBalance(q.address,_);q.balance=z?.length?z:L}return q}function g({route:$,pluginName:_,...L}){const q=_&&K(_)||y($.providers[0]);if(!q)throw new U("core_swap_route_not_complete");if("swap"in q)return q.swap({...L,route:$});throw new U("core_plugin_swap_not_found")}function h({assetValue:$,..._}){const L=$.chain,q=J(L);if(!q)throw new U("core_wallet_connection_not_found");return q.transfer({..._,assetValue:$})}function d({chain:$,message:_}){const L=J($);if(!L)throw new U("core_wallet_connection_not_found");if("signMessage"in L)return L.signMessage?.(_);throw new U({errorKey:"core_wallet_sign_message_not_supported",info:{chain:$,wallet:L.walletType}})}async function r({address:$,chain:_,message:L,signature:q}){switch(_){case R.THORChain:{const{getToolboxByChain:z}=await import("@swapkit/toolbox-cosmos");return z(_)().verifySignature({signature:q,message:L,address:$})}default:throw new U({errorKey:"core_verify_message_not_supported",info:{chain:_}})}}async function c({type:$,feeOptionKey:_,params:L}){const{assetValue:q}=L,{chain:z}=q;if(!J(z))throw new U("core_wallet_connection_not_found");const T=k.from({chain:z});switch(z){case R.Arbitrum:case R.Avalanche:case R.Ethereum:case R.BinanceSmartChain:case R.Polygon:{const I=J(z);if($==="transfer"){const X=await I.createTransferTx(L);return I.estimateTransactionFee(X,_)}if($==="approve"&&!q.isGasAsset)return I.estimateTransactionFee(await I.createApprovalTx({assetAddress:q.address,spenderAddress:L.contractAddress,amount:q.getBaseValue("bigint"),from:I.address}),_);if($==="swap"){if(L.route.providers[0]===E.CHAINFLIP){const p=await I.createTransferTx({from:I.address,recipient:I.address,assetValue:q});return I.estimateTransactionFee(p,_)}const{tx:Z}=L.route;if(!Z)return;return I.estimateTransactionFee({...Z,value:BigInt(Z.value)},_)}return k.from({chain:z})}case R.Bitcoin:case R.BitcoinCash:case R.Dogecoin:case R.Dash:case R.Litecoin:{const{estimateTransactionFee:I,address:X}=J(z);return I({...L,feeOptionKey:_,from:X,recipient:X})}case R.THORChain:case R.Maya:case R.Kujira:case R.Cosmos:return t(L);case R.Polkadot:{const{address:I,estimateTransactionFee:X}=J(z);return X({...L,recipient:I})}default:return T}}return{...B,...v,disconnectAll:w,disconnectChain:F,estimateTransactionFee:c,getAddress:C,getAllWallets:W,getBalance:o,getExplorerAddressUrl:O,getExplorerTxUrl:f,getWallet:J,getWalletWithBalance:P,approveAssetValue:m,isAssetValueApproved:V,signMessage:d,swap:g,transfer:h,validateAddress:u,verifyMessage:r}}export{B$ as stripToCashAddress,Q$ as SwapKit};

//# debugId=9E7AAF68EDC6571C64756E2164756E21
