{
  "version": 3,
  "sources": ["../src/toolbox.ts"],
  "sourcesContent": [
    "import { CoreApiClient } from \"@radixdlt/babylon-core-api-sdk\";\n\nimport {\n  LTSRadixEngineToolkit,\n  NetworkId,\n  PrivateKey,\n  type PublicKey,\n  type Signature,\n  type SignatureWithPublicKey,\n  SimpleTransactionBuilder,\n} from \"@radixdlt/radix-engine-toolkit\";\nimport { mnemonicToSeed } from \"@scure/bip39\";\nimport { AssetValue, Chain, RPCUrl, SwapKitError } from \"@swapkit/helpers\";\nimport type { RadixNetwork } from \"./types\";\n\n// TODO combine this type with the more general SK type\ntype SubstrateTransferParams = {\n  recipient: string;\n  assetValue: AssetValue;\n  from: string;\n};\n\nexport type RadixSigner = {\n  publicKey(): PublicKey;\n  publicKeyBytes(): Uint8Array;\n  publicKeyHex(): string;\n  sign(messageHash: Uint8Array): Uint8Array;\n  signToSignature(messageHash: Uint8Array): Signature;\n  signToSignatureWithPublicKey(messageHash: Uint8Array): SignatureWithPublicKey;\n};\n\nexport async function createPrivateKey(phrase: string) {\n  const seed = await mnemonicToSeed(phrase);\n\n  return new PrivateKey.Ed25519(seed.slice(0, 32));\n}\n\nfunction getAddress(signer: RadixSigner, network: RadixNetwork) {\n  return LTSRadixEngineToolkit.Derive.virtualAccountAddress(signer.publicKey(), network.networkId);\n}\n\n// Could not find anything sync in SDK, ask Radix team\nfunction validateAddress(address: string) {\n  return address.startsWith(\"account_rdx1\") && address.length === 66;\n}\n\nfunction transfer({\n  api,\n  signer,\n  network,\n}: {\n  api: CoreApiClient;\n  signer: RadixSigner;\n  network: RadixNetwork;\n}) {\n  return async function transfer({ assetValue, from, recipient }: SubstrateTransferParams) {\n    if (!assetValue.address) throw new Error(\"Asset value must have an address\");\n\n    const constructionMetadata = await api.LTS.getConstructionMetadata();\n    const builder = await SimpleTransactionBuilder.new({\n      networkId: network.networkId,\n      validFromEpoch: constructionMetadata.current_epoch,\n      fromAccount: from,\n      signerPublicKey: signer.publicKey(),\n    });\n\n    const unsignedTransaction = builder\n      .transferFungible({\n        toAccount: recipient,\n        resourceAddress: assetValue.address,\n        amount: assetValue.getBaseValue(\"number\"),\n      })\n      .compileIntent();\n\n    const notarySignature = signer.signToSignature(unsignedTransaction.hashToNotarize);\n\n    const notarizedTransaction = unsignedTransaction.compileNotarized(notarySignature);\n\n    const intentHashTransactionId = notarizedTransaction.transactionId.id;\n\n    try {\n      await api.LTS.submitTransaction({\n        notarized_transaction_hex: notarizedTransaction.toHex(),\n      });\n    } catch (error) {\n      throw new Error(`Failed to submit transaction: ${error}`);\n    }\n\n    return intentHashTransactionId;\n  };\n}\n\nfunction getBalance({ api, address: walletAddress }: { api: CoreApiClient; address: string }) {\n  return async function getBalance(address = walletAddress) {\n    const balancesRaw = await api.LTS.getAccountAllFungibleResourceBalances({\n      account_address: address,\n    });\n\n    const balances = balancesRaw.fungible_resource_balances.map((balance) => {\n      const assetWithoutAddress = new AssetValue({\n        value: balance.amount,\n        chain: Chain.Radix,\n        decimal: 8,\n        symbol: balance.fungible_resource_address,\n      });\n\n      assetWithoutAddress.address = balance.fungible_resource_address;\n\n      return assetWithoutAddress;\n    });\n\n    return balances;\n  };\n}\n\nfunction signMessage(_signer: RadixSigner) {\n  return function signMessage(_message: string) {\n    throw new SwapKitError(\"not_implemented\", { method: \"signMessage\", toolbox: \"radix\" });\n\n    // TODO: convert message to Uint8Array\n    // return signer.signToSignatureWithPublicKey(message);\n  };\n}\n\nfunction validateSignature(_signer: RadixSigner) {\n  return function validateSignature(_signature: SignatureWithPublicKey) {\n    throw new SwapKitError(\"not_implemented\", { method: \"validateSignature\", toolbox: \"radix\" });\n\n    // TODO: validate signature\n    // return\n  };\n}\n\nexport async function getRadixCoreApiClient(\n  coreApiBase: string = RPCUrl.Radix,\n  network: RadixNetwork = {\n    networkId: NetworkId.Mainnet,\n    networkName: \"mainnet\",\n    dashboardBase: \"https://dashboard.radixdlt.com\",\n  },\n) {\n  return await CoreApiClient.initialize({\n    basePath: coreApiBase,\n    logicalNetworkName: network.networkName,\n    fetch,\n  });\n}\n\nexport const RadixToolbox = async ({\n  api,\n  network = {\n    networkId: NetworkId.Mainnet,\n    networkName: \"mainnet\",\n    dashboardBase: \"https://dashboard.radixdlt.com\",\n  },\n  signer,\n}: {\n  api: CoreApiClient;\n  network?: RadixNetwork;\n  signer: RadixSigner;\n}) => {\n  const address = await getAddress(signer, network);\n\n  return {\n    api,\n    createPrivateKey,\n    validateAddress,\n    getAddress: () => address,\n    transfer: transfer({ api, signer, network }),\n    signMessage: signMessage(signer),\n    validateSignature: validateSignature(signer),\n    getBalance: getBalance({ address, api }),\n  };\n};\n\nexport const RadixMainnet = {\n  networkId: NetworkId.Mainnet,\n  networkName: \"mainnet\",\n  dashboardBase: \"https://dashboard.radixdlt.com\",\n};\n\nexport type RadixWallet = ReturnType<typeof RadixToolbox>;\n"
  ],
  "mappings": "AAAA,wBAAS,uCAET,gCACE,eACA,gBACA,8BAIA,uCAEF,yBAAS,qBACT,qBAAS,WAAY,YAAO,kBAAQ,yBAmBpC,eAAsB,CAAgB,CAAC,EAAgB,CACrD,MAAM,EAAO,MAAM,EAAe,CAAM,EAExC,OAAO,IAAI,EAAW,QAAQ,EAAK,MAAM,EAAG,EAAE,CAAC,EAGjD,SAAS,CAAU,CAAC,EAAqB,EAAuB,CAC9D,OAAO,EAAsB,OAAO,sBAAsB,EAAO,UAAU,EAAG,EAAQ,SAAS,EAIjG,SAAS,CAAe,CAAC,EAAiB,CACxC,OAAO,EAAQ,WAAW,cAAc,GAAK,EAAQ,SAAW,GAGlE,SAAS,CAAQ,EACf,MACA,SACA,WAKC,CACD,OAAO,eAAe,CAAQ,EAAG,aAAY,OAAM,aAAsC,CACvF,IAAK,EAAW,QAAS,MAAM,IAAI,MAAM,kCAAkC,EAE3E,MAAM,EAAuB,MAAM,EAAI,IAAI,wBAAwB,EAQ7D,GAPU,MAAM,EAAyB,IAAI,CACjD,UAAW,EAAQ,UACnB,eAAgB,EAAqB,cACrC,YAAa,EACb,gBAAiB,EAAO,UAAU,CACpC,CAAC,GAGE,iBAAiB,CAChB,UAAW,EACX,gBAAiB,EAAW,QAC5B,OAAQ,EAAW,aAAa,QAAQ,CAC1C,CAAC,EACA,cAAc,EAEX,EAAkB,EAAO,gBAAgB,EAAoB,cAAc,EAE3E,EAAuB,EAAoB,iBAAiB,CAAe,EAE3E,EAA0B,EAAqB,cAAc,GAEnE,GAAI,CACF,MAAM,EAAI,IAAI,kBAAkB,CAC9B,0BAA2B,EAAqB,MAAM,CACxD,CAAC,QACM,EAAP,CACA,MAAM,IAAI,MAAM,iCAAiC,GAAO,EAG1D,OAAO,GAIX,SAAS,CAAU,EAAG,MAAK,QAAS,GAA0D,CAC5F,OAAO,eAAe,CAAU,CAAC,EAAU,EAAe,CAkBxD,OAjBoB,MAAM,EAAI,IAAI,sCAAsC,CACtE,gBAAiB,CACnB,CAAC,GAE4B,2BAA2B,IAAI,CAAC,IAAY,CACvE,MAAM,EAAsB,IAAI,EAAW,CACzC,MAAO,EAAQ,OACf,MAAO,EAAM,MACb,QAAS,EACT,OAAQ,EAAQ,yBAClB,CAAC,EAID,OAFA,EAAoB,QAAU,EAAQ,0BAE/B,EACR,GAML,SAAS,CAAW,CAAC,EAAsB,CACzC,gBAAgB,CAAW,CAAC,EAAkB,CAC5C,MAAM,IAAI,EAAa,kBAAmB,CAAE,OAAQ,cAAe,QAAS,OAAQ,CAAC,GAOzF,SAAS,CAAiB,CAAC,EAAsB,CAC/C,gBAAgB,CAAiB,CAAC,EAAoC,CACpE,MAAM,IAAI,EAAa,kBAAmB,CAAE,OAAQ,oBAAqB,QAAS,OAAQ,CAAC,GAO/F,eAAsB,CAAqB,CACzC,EAAsB,EAAO,MAC7B,EAAwB,CACtB,UAAW,EAAU,QACrB,YAAa,UACb,cAAe,gCACjB,EACA,CACA,OAAO,MAAM,EAAc,WAAW,CACpC,SAAU,EACV,mBAAoB,EAAQ,YAC5B,KACF,CAAC,EAGI,IAAM,EAAe,OAC1B,MACA,UAAU,CACR,UAAW,EAAU,QACrB,YAAa,UACb,cAAe,gCACjB,EACA,YAKI,CACJ,MAAM,EAAU,MAAM,EAAW,EAAQ,CAAO,EAEhD,MAAO,CACL,MACA,mBACA,kBACA,WAAY,IAAM,EAClB,SAAU,EAAS,CAAE,MAAK,SAAQ,SAAQ,CAAC,EAC3C,YAAa,EAAY,CAAM,EAC/B,kBAAmB,EAAkB,CAAM,EAC3C,WAAY,EAAW,CAAE,UAAS,KAAI,CAAC,CACzC,GAGW,EAAe,CAC1B,UAAW,EAAU,QACrB,YAAa,UACb,cAAe,gCACjB",
  "debugId": "77F33A0F73B6DBE464756E2164756E21",
  "names": []
}