{
  "version": 3,
  "sources": ["../src/thorchainUtils/addressFormat.ts", "../src/thorchainUtils/messages.ts", "../src/util.ts", "../src/thorchainUtils/registry.ts", "../src/thorchainUtils/types/proto/MsgCompiled.ts", "../src/toolbox/BaseCosmosToolbox.ts", "../src/cosmosClient.ts", "../src/toolbox/gaia.ts", "../src/toolbox/getToolboxByChain.ts", "../src/toolbox/kujira.ts", "../src/toolbox/thorchain.ts"],
  "sourcesContent": [
    "import { toBech32 } from \"@cosmjs/encoding\";\nimport { base64, bech32 } from \"@scure/base\";\nimport { fromByteArray, toByteArray } from \"base64-js\";\n\nexport function bech32ToBase64(address: string) {\n  return base64.encode(Uint8Array.from(bech32.fromWords(bech32.decode(address).words)));\n}\n\nexport function base64ToBech32(address: string, prefix = \"thor\") {\n  return toBech32(prefix, base64.decode(address));\n}\n\nexport function toBase64(data: Uint8Array) {\n  return fromByteArray(data);\n}\n\nexport function fromBase64(base64String: string) {\n  if (!base64String.match(/^[a-zA-Z0-9+/]*={0,2}$/)) {\n    throw new Error(\"Invalid base64 string format\");\n  }\n  return toByteArray(base64String);\n}\n",
    "import type { TxBodyEncodeObject } from \"@cosmjs/proto-signing\";\nimport { AssetValue, Chain, ChainToChainId, RPCUrl } from \"@swapkit/helpers\";\n\nimport { createStargateClient, getDenom } from \"../util.ts\";\n\nimport { createDefaultAminoTypes, createDefaultRegistry } from \"./registry.ts\";\n\ntype MsgSend = ReturnType<typeof transferMsgAmino>;\ntype MsgDeposit = ReturnType<typeof depositMsgAmino>;\ntype MsgSendForBroadcast = ReturnType<typeof prepareMessageForBroadcast>;\ntype MsgDepositForBroadcast = ReturnType<typeof prepareMessageForBroadcast>;\n\nexport const getDefaultChainFee = (chain: Chain.THORChain | Chain.Maya) => {\n  switch (chain) {\n    case Chain.Maya:\n      return { amount: [], gas: \"10000000000\" };\n    default:\n      return { amount: [], gas: \"500000000\" };\n  }\n};\n\nexport const THORCHAIN_GAS_VALUE = getDefaultChainFee(Chain.THORChain).gas;\nexport const MAYA_GAS_VALUE = getDefaultChainFee(Chain.Maya).gas;\n\nexport const transferMsgAmino = ({\n  from,\n  recipient,\n  assetValue,\n  chain,\n}: {\n  from: string;\n  recipient?: string;\n  assetValue: AssetValue;\n  chain: Chain.THORChain | Chain.Maya;\n}) => ({\n  type: `${chain === Chain.Maya ? \"mayachain\" : \"thorchain\"}/MsgSend`,\n  value: {\n    from_address: from,\n    to_address: recipient,\n    amount: [\n      {\n        amount: assetValue.getBaseValue(\"string\"),\n        denom: getDenom(assetValue.symbol, true),\n      },\n    ],\n  },\n});\n\nexport const depositMsgAmino = ({\n  from,\n  assetValue,\n  memo = \"\",\n  chain,\n}: {\n  from: string;\n  assetValue: AssetValue;\n  memo?: string;\n  chain: Chain.THORChain | Chain.Maya;\n}) => {\n  return {\n    type: `${chain === Chain.Maya ? \"mayachain\" : \"thorchain\"}/MsgDeposit`,\n    value: {\n      coins: [\n        {\n          amount: assetValue.getBaseValue(\"string\"),\n          asset: getDenomWithChain(assetValue),\n        },\n      ],\n      signer: from,\n      memo,\n    },\n  };\n};\n\nexport const buildAminoMsg = ({\n  from,\n  recipient,\n  assetValue,\n  memo,\n  chain,\n}: {\n  from: string;\n  recipient?: string;\n  assetValue: AssetValue;\n  memo?: string;\n  chain: Chain.THORChain | Chain.Maya;\n}) => {\n  const isDeposit = !recipient;\n  const msg = isDeposit\n    ? depositMsgAmino({ from, assetValue, memo, chain })\n    : transferMsgAmino({ from, recipient, assetValue, chain });\n\n  return msg;\n};\n\nexport const convertToSignable = (\n  msg: MsgDepositForBroadcast | MsgSendForBroadcast,\n  chain: Chain.THORChain | Chain.Maya,\n) => {\n  const aminoTypes = createDefaultAminoTypes(chain);\n\n  return aminoTypes.fromAmino(msg);\n};\n\nexport const buildTransaction = async ({\n  from,\n  recipient,\n  assetValue,\n  memo = \"\",\n  isStagenet = false,\n  chain,\n}: {\n  isStagenet?: boolean;\n  from: string;\n  recipient: string;\n  assetValue: AssetValue;\n  memo?: string;\n  chain: Chain.THORChain | Chain.Maya;\n}) => {\n  const client = await createStargateClient(\n    isStagenet ? RPCUrl.THORChainStagenet : RPCUrl.THORChain,\n  );\n\n  const account = await client.getAccount(from);\n\n  if (!account) {\n    throw new Error(\"Account does not exist\");\n  }\n\n  const msg = buildAminoMsg({ from, recipient, assetValue, memo, chain });\n\n  const transaction = {\n    chainId: ChainToChainId[chain],\n    accountNumber: account.accountNumber,\n    sequence: account.sequence,\n    msgs: [msg],\n    fee: getDefaultChainFee(assetValue.chain as Chain.THORChain | Chain.Maya),\n    memo,\n  };\n\n  return transaction;\n};\n\nexport const prepareMessageForBroadcast = (msg: MsgDeposit | MsgSend) => {\n  if (msg.type === \"thorchain/MsgSend\" || msg.type === \"mayachain/MsgSend\") return msg;\n\n  return {\n    ...msg,\n    value: {\n      ...msg.value,\n      coins: (msg as MsgDeposit).value.coins.map((coin: { asset: string; amount: string }) => {\n        const assetValue = AssetValue.from({ asset: coin.asset });\n\n        const symbol = (\n          assetValue.isSynthetic ? assetValue.symbol.split(\"/\")?.[1] : assetValue.symbol\n        )?.toUpperCase();\n        const chain = (\n          assetValue.isSynthetic ? assetValue.symbol.split(\"/\")?.[0] : assetValue.chain\n        )?.toUpperCase();\n\n        return {\n          ...coin,\n          asset: {\n            chain,\n            symbol,\n            ticker: symbol,\n            synth: assetValue.isSynthetic,\n          },\n        };\n      }),\n    },\n  };\n};\n\nexport const buildEncodedTxBody = ({\n  chain,\n  memo,\n  msgs,\n}: {\n  msgs: MsgSendForBroadcast[] | MsgDepositForBroadcast[];\n  memo: string;\n  chain: Chain.THORChain | Chain.Maya;\n}) => {\n  const registry = createDefaultRegistry();\n  const aminoTypes = createDefaultAminoTypes(chain);\n\n  const signedTxBody: TxBodyEncodeObject = {\n    typeUrl: \"/cosmos.tx.v1beta1.TxBody\",\n    value: { memo, messages: msgs.map((msg) => aminoTypes.fromAmino(msg)) },\n  };\n\n  return registry.encode(signedTxBody);\n};\n\nexport const getDenomWithChain = ({ symbol, chain }: AssetValue) => {\n  if (chain === Chain.Maya) {\n    return (symbol.toUpperCase() !== \"CACAO\" ? symbol : `${Chain.Maya}.${symbol}`).toUpperCase();\n  }\n  return (symbol.toUpperCase() !== \"RUNE\" ? symbol : `${Chain.THORChain}.${symbol}`).toUpperCase();\n};\n",
    "import type { OfflineSigner } from \"@cosmjs/proto-signing\";\nimport {\n  GasPrice,\n  SigningStargateClient,\n  type SigningStargateClientOptions,\n  StargateClient,\n} from \"@cosmjs/stargate\";\nimport {\n  AssetValue,\n  Chain,\n  ChainId,\n  FeeOption,\n  RPCUrl,\n  defaultRequestHeaders,\n} from \"@swapkit/helpers\";\n\nimport type { CosmosMaxSendableAmountParams } from \"./types.ts\";\n\nexport const USK_KUJIRA_FACTORY_DENOM =\n  \"FACTORY/KUJIRA1QK00H5ATUTPSV900X202PXX42NPJR9THG58DNQPA72F2P7M2LUASE444A7/UUSK\";\n\nexport const YUM_KUJIRA_FACTORY_DENOM =\n  \"FACTORY/KUJIRA1YGFXN0ER40KLCNCK8THLTUPRDXLCK6WVNPKF2K/UYUM\";\n\nexport const DEFAULT_COSMOS_FEE_MAINNET = {\n  amount: [{ denom: \"uatom\", amount: \"500\" }],\n  gas: \"200000\",\n};\n\nexport const getDenom = (symbol: string, isThorchain = false) => {\n  if (isThorchain) {\n    return symbol.toLowerCase();\n  }\n  switch (symbol) {\n    case \"uUSK\":\n      return USK_KUJIRA_FACTORY_DENOM;\n    case \"uYUM\":\n      return YUM_KUJIRA_FACTORY_DENOM;\n    default:\n      return symbol;\n  }\n};\n\nexport const createStargateClient = (url: string) => {\n  return StargateClient.connect({ url, headers: defaultRequestHeaders });\n};\n\nexport const createSigningStargateClient = (\n  url: string,\n  signer: Todo,\n  optionsOrBaseGas: string | SigningStargateClientOptions = {},\n) => {\n  const gasPrice = typeof optionsOrBaseGas === \"string\" ? optionsOrBaseGas : \"0.0003uatom\";\n  const options = typeof optionsOrBaseGas === \"string\" ? {} : optionsOrBaseGas;\n\n  return SigningStargateClient.connectWithSigner({ url, headers: defaultRequestHeaders }, signer, {\n    gasPrice: GasPrice.fromString(gasPrice),\n    ...options,\n  });\n};\n\nexport const createOfflineStargateClient = (\n  wallet: OfflineSigner,\n  registry?: SigningStargateClientOptions,\n) => {\n  return SigningStargateClient.offline(wallet, registry);\n};\n\nexport const getRPC = (chainId: ChainId, stagenet?: boolean) => {\n  switch (chainId) {\n    case ChainId.Cosmos:\n      return RPCUrl.Cosmos;\n    case ChainId.Kujira:\n      return RPCUrl.Kujira;\n\n    case ChainId.THORChain:\n      return stagenet ? RPCUrl.THORChainStagenet : RPCUrl.THORChain;\n    case ChainId.Maya:\n      return stagenet ? RPCUrl.MayaStagenet : RPCUrl.Maya;\n\n    default:\n      return RPCUrl.Cosmos;\n  }\n};\n\nexport const estimateMaxSendableAmount = async ({\n  from,\n  toolbox,\n  asset,\n  feeOptionKey = FeeOption.Fast,\n}: CosmosMaxSendableAmountParams): Promise<AssetValue> => {\n  const assetEntity =\n    typeof asset === \"string\" ? await AssetValue.from({ asyncTokenLookup: true, asset }) : asset;\n  const balances = await toolbox.getBalance(from);\n  const balance = balances.find(({ symbol, chain }) =>\n    asset ? symbol === assetEntity?.symbol : symbol === AssetValue.from({ chain }).symbol,\n  );\n\n  const fees = await toolbox.getFees();\n\n  if (!balance) {\n    return AssetValue.from({ chain: assetEntity?.chain || balances[0]?.chain || Chain.Cosmos });\n  }\n\n  return balance.sub(fees[feeOptionKey]);\n};\n",
    "import { Registry } from \"@cosmjs/proto-signing\";\nimport { AminoTypes, defaultRegistryTypes } from \"@cosmjs/stargate\";\nimport { Chain } from \"@swapkit/helpers\";\nimport * as types from \"../thorchainUtils/types/proto/MsgCompiled.ts\";\nimport { base64ToBech32, bech32ToBase64 } from \"./addressFormat.ts\";\n\nexport const createDefaultRegistry = () => {\n  return new Registry([\n    ...defaultRegistryTypes,\n    [\"/types.MsgSend\", { ...types.default.types.MsgSend }],\n    [\"/types.MsgDeposit\", { ...types.default.types.MsgDeposit }],\n  ]);\n};\n\nexport const createDefaultAminoTypes = (chain: Chain.THORChain | Chain.Maya) => {\n  return new AminoTypes({\n    \"/types.MsgSend\": {\n      aminoType: `${chain === Chain.Maya ? \"mayachain\" : \"thorchain\"}/MsgSend`,\n      toAmino: (params: NotWorth) => ({\n        from_address: base64ToBech32(params.fromAddress),\n        to_address: base64ToBech32(params.toAddress),\n        amount: [...params.amount],\n      }),\n      fromAmino: (params: NotWorth) => ({\n        fromAddress: bech32ToBase64(params.from_address),\n        toAddress: bech32ToBase64(params.to_address),\n        amount: [...params.amount],\n      }),\n    },\n    \"/types.MsgDeposit\": {\n      aminoType: `${chain === Chain.Maya ? \"mayachain\" : \"thorchain\"}/MsgDeposit`,\n      toAmino: (params: NotWorth) => ({\n        signer: base64ToBech32(params.signer),\n        memo: params.memo,\n        coins: [...params.coins],\n      }),\n      fromAmino: (params: NotWorth) => ({\n        signer: bech32ToBase64(params.signer),\n        memo: params.memo,\n        coins: [...params.coins],\n      }),\n    },\n  });\n};\n",
    "// @ts-nocheck\nimport $protobuf from \"protobufjs/minimal.js\";\n\n// Common aliases\nconst $Reader = $protobuf.Reader;\nconst $Writer = $protobuf.Writer;\nconst $util = $protobuf.util;\n\n// Exported root namespace\n\nconst $root = ($protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {})) as any;\n\n$root.common = (() => {\n  /**\n   * Namespace common.\n   * @exports common\n   * @namespace\n   */\n  const common = {};\n\n  common.Asset = (() => {\n    /**\n     * Properties of an Asset.\n     * @memberof common\n     * @interface IAsset\n     * @property {string|null} [chain] Asset chain\n     * @property {string|null} [symbol] Asset symbol\n     * @property {string|null} [ticker] Asset ticker\n     * @property {boolean|null} [synth] Asset synth\n     */\n\n    /**\n     * Constructs a new Asset.\n     * @memberof common\n     * @classdesc Represents an Asset.\n     * @implements IAsset\n     * @constructor\n     * @param {common.IAsset=} [properties] Properties to set\n     */\n    function Asset(properties) {\n      if (properties)\n        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Asset chain.\n     * @member {string} chain\n     * @memberof common.Asset\n     * @instance\n     */\n    Asset.prototype.chain = \"\";\n\n    /**\n     * Asset symbol.\n     * @member {string} symbol\n     * @memberof common.Asset\n     * @instance\n     */\n    Asset.prototype.symbol = \"\";\n\n    /**\n     * Asset ticker.\n     * @member {string} ticker\n     * @memberof common.Asset\n     * @instance\n     */\n    Asset.prototype.ticker = \"\";\n\n    /**\n     * Asset synth.\n     * @member {boolean} synth\n     * @memberof common.Asset\n     * @instance\n     */\n    Asset.prototype.synth = false;\n\n    /**\n     * Creates a new Asset instance using the specified properties.\n     * @function create\n     * @memberof common.Asset\n     * @static\n     * @param {common.IAsset=} [properties] Properties to set\n     * @returns {common.Asset} Asset instance\n     */\n    Asset.create = function create(properties) {\n      return new Asset(properties);\n    };\n\n    /**\n     * Encodes the specified Asset message. Does not implicitly {@link common.Asset.verify|verify} messages.\n     * @function encode\n     * @memberof common.Asset\n     * @static\n     * @param {common.IAsset} message Asset message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Asset.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.chain != null && Object.hasOwnProperty.call(message, \"chain\"))\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.chain);\n      if (message.symbol != null && Object.hasOwnProperty.call(message, \"symbol\"))\n        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.symbol);\n      if (message.ticker != null && Object.hasOwnProperty.call(message, \"ticker\"))\n        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.ticker);\n      if (message.synth != null && Object.hasOwnProperty.call(message, \"synth\"))\n        writer.uint32(/* id 4, wireType 0 =*/ 32).bool(message.synth);\n      return writer;\n    };\n\n    /**\n     * Encodes the specified Asset message, length delimited. Does not implicitly {@link common.Asset.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof common.Asset\n     * @static\n     * @param {common.IAsset} message Asset message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Asset.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes an Asset message from the specified reader or buffer.\n     * @function decode\n     * @memberof common.Asset\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {common.Asset} Asset\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Asset.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      const end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.common.Asset();\n      while (reader.pos < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.chain = reader.string();\n            break;\n          case 2:\n            message.symbol = reader.string();\n            break;\n          case 3:\n            message.ticker = reader.string();\n            break;\n          case 4:\n            message.synth = reader.bool();\n            break;\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes an Asset message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof common.Asset\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {common.Asset} Asset\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Asset.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies an Asset message.\n     * @function verify\n     * @memberof common.Asset\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Asset.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.chain != null && message.hasOwnProperty(\"chain\"))\n        if (!$util.isString(message.chain)) return \"chain: string expected\";\n      if (message.symbol != null && message.hasOwnProperty(\"symbol\"))\n        if (!$util.isString(message.symbol)) return \"symbol: string expected\";\n      if (message.ticker != null && message.hasOwnProperty(\"ticker\"))\n        if (!$util.isString(message.ticker)) return \"ticker: string expected\";\n      if (message.synth != null && message.hasOwnProperty(\"synth\"))\n        if (typeof message.synth !== \"boolean\") return \"synth: boolean expected\";\n      return null;\n    };\n\n    /**\n     * Creates an Asset message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof common.Asset\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {common.Asset} Asset\n     */\n    Asset.fromObject = function fromObject(object) {\n      if (object instanceof $root.common.Asset) return object;\n      const message = new $root.common.Asset();\n      if (object.chain != null) message.chain = String(object.chain);\n      if (object.symbol != null) message.symbol = String(object.symbol);\n      if (object.ticker != null) message.ticker = String(object.ticker);\n      if (object.synth != null) message.synth = Boolean(object.synth);\n      return message;\n    };\n\n    /**\n     * Creates a plain object from an Asset message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof common.Asset\n     * @static\n     * @param {common.Asset} message Asset\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Asset.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      const object = {};\n      if (options.defaults) {\n        object.chain = \"\";\n        object.symbol = \"\";\n        object.ticker = \"\";\n        object.synth = false;\n      }\n      if (message.chain != null && message.hasOwnProperty(\"chain\")) object.chain = message.chain;\n      if (message.symbol != null && message.hasOwnProperty(\"symbol\"))\n        object.symbol = message.symbol;\n      if (message.ticker != null && message.hasOwnProperty(\"ticker\"))\n        object.ticker = message.ticker;\n      if (message.synth != null && message.hasOwnProperty(\"synth\")) object.synth = message.synth;\n      return object;\n    };\n\n    /**\n     * Converts this Asset to JSON.\n     * @function toJSON\n     * @memberof common.Asset\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Asset.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Asset;\n  })();\n\n  common.Coin = (() => {\n    /**\n     * Properties of a Coin.\n     * @memberof common\n     * @interface ICoin\n     * @property {common.IAsset|null} [asset] Coin asset\n     * @property {string|null} [amount] Coin amount\n     * @property {number|Long|null} [decimals] Coin decimals\n     */\n\n    /**\n     * Constructs a new Coin.\n     * @memberof common\n     * @classdesc Represents a Coin.\n     * @implements ICoin\n     * @constructor\n     * @param {common.ICoin=} [properties] Properties to set\n     */\n    function Coin(properties) {\n      if (properties)\n        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Coin asset.\n     * @member {common.IAsset|null|undefined} asset\n     * @memberof common.Coin\n     * @instance\n     */\n    Coin.prototype.asset = null;\n\n    /**\n     * Coin amount.\n     * @member {string} amount\n     * @memberof common.Coin\n     * @instance\n     */\n    Coin.prototype.amount = \"\";\n\n    /**\n     * Coin decimals.\n     * @member {number|Long} decimals\n     * @memberof common.Coin\n     * @instance\n     */\n    Coin.prototype.decimals = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n\n    /**\n     * Creates a new Coin instance using the specified properties.\n     * @function create\n     * @memberof common.Coin\n     * @static\n     * @param {common.ICoin=} [properties] Properties to set\n     * @returns {common.Coin} Coin instance\n     */\n    Coin.create = function create(properties) {\n      return new Coin(properties);\n    };\n\n    /**\n     * Encodes the specified Coin message. Does not implicitly {@link common.Coin.verify|verify} messages.\n     * @function encode\n     * @memberof common.Coin\n     * @static\n     * @param {common.ICoin} message Coin message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Coin.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.asset != null && Object.hasOwnProperty.call(message, \"asset\"))\n        $root.common.Asset.encode(\n          message.asset,\n          writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),\n        ).ldelim();\n      if (message.amount != null && Object.hasOwnProperty.call(message, \"amount\"))\n        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.amount);\n      if (message.decimals != null && Object.hasOwnProperty.call(message, \"decimals\"))\n        writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.decimals);\n      return writer;\n    };\n\n    /**\n     * Encodes the specified Coin message, length delimited. Does not implicitly {@link common.Coin.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof common.Coin\n     * @static\n     * @param {common.ICoin} message Coin message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Coin.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Coin message from the specified reader or buffer.\n     * @function decode\n     * @memberof common.Coin\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {common.Coin} Coin\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Coin.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      const end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.common.Coin();\n      while (reader.pos < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.asset = $root.common.Asset.decode(reader, reader.uint32());\n            break;\n          case 2:\n            message.amount = reader.string();\n            break;\n          case 3:\n            message.decimals = reader.int64();\n            break;\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a Coin message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof common.Coin\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {common.Coin} Coin\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Coin.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Coin message.\n     * @function verify\n     * @memberof common.Coin\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Coin.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.asset != null && message.hasOwnProperty(\"asset\")) {\n        const error = $root.common.Asset.verify(message.asset);\n        if (error) return \"asset.\" + error;\n      }\n      if (message.amount != null && message.hasOwnProperty(\"amount\"))\n        if (!$util.isString(message.amount)) return \"amount: string expected\";\n      if (message.decimals != null && message.hasOwnProperty(\"decimals\"))\n        if (\n          !$util.isInteger(message.decimals) &&\n          !(\n            message.decimals &&\n            $util.isInteger(message.decimals.low) &&\n            $util.isInteger(message.decimals.high)\n          )\n        )\n          return \"decimals: integer|Long expected\";\n      return null;\n    };\n\n    /**\n     * Creates a Coin message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof common.Coin\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {common.Coin} Coin\n     */\n    Coin.fromObject = function fromObject(object) {\n      if (object instanceof $root.common.Coin) return object;\n      const message = new $root.common.Coin();\n      if (object.asset != null) {\n        if (typeof object.asset !== \"object\")\n          throw TypeError(\".common.Coin.asset: object expected\");\n        message.asset = $root.common.Asset.fromObject(object.asset);\n      }\n      if (object.amount != null) message.amount = String(object.amount);\n      if (object.decimals != null)\n        if ($util.Long) (message.decimals = $util.Long.fromValue(object.decimals)).unsigned = false;\n        else if (typeof object.decimals === \"string\")\n          message.decimals = parseInt(object.decimals, 10);\n        else if (typeof object.decimals === \"number\") message.decimals = object.decimals;\n        else if (typeof object.decimals === \"object\")\n          message.decimals = new $util.LongBits(\n            object.decimals.low >>> 0,\n            object.decimals.high >>> 0,\n          ).toNumber();\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a Coin message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof common.Coin\n     * @static\n     * @param {common.Coin} message Coin\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Coin.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      const object = {};\n      if (options.defaults) {\n        object.asset = null;\n        object.amount = \"\";\n        if ($util.Long) {\n          const long = new $util.Long(0, 0, false);\n          object.decimals =\n            options.longs === String\n              ? long.toString()\n              : options.longs === Number\n                ? long.toNumber()\n                : long;\n        } else object.decimals = options.longs === String ? \"0\" : 0;\n      }\n      if (message.asset != null && message.hasOwnProperty(\"asset\"))\n        object.asset = $root.common.Asset.toObject(message.asset, options);\n      if (message.amount != null && message.hasOwnProperty(\"amount\"))\n        object.amount = message.amount;\n      if (message.decimals != null && message.hasOwnProperty(\"decimals\"))\n        if (typeof message.decimals === \"number\")\n          object.decimals = options.longs === String ? String(message.decimals) : message.decimals;\n        else\n          object.decimals =\n            options.longs === String\n              ? $util.Long.prototype.toString.call(message.decimals)\n              : options.longs === Number\n                ? new $util.LongBits(\n                    message.decimals.low >>> 0,\n                    message.decimals.high >>> 0,\n                  ).toNumber()\n                : message.decimals;\n      return object;\n    };\n\n    /**\n     * Converts this Coin to JSON.\n     * @function toJSON\n     * @memberof common.Coin\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Coin.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Coin;\n  })();\n\n  common.PubKeySet = (() => {\n    /**\n     * Properties of a PubKeySet.\n     * @memberof common\n     * @interface IPubKeySet\n     * @property {string|null} [secp256k1] PubKeySet secp256k1\n     * @property {string|null} [ed25519] PubKeySet ed25519\n     */\n\n    /**\n     * Constructs a new PubKeySet.\n     * @memberof common\n     * @classdesc Represents a PubKeySet.\n     * @implements IPubKeySet\n     * @constructor\n     * @param {common.IPubKeySet=} [properties] Properties to set\n     */\n    function PubKeySet(properties) {\n      if (properties)\n        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * PubKeySet secp256k1.\n     * @member {string} secp256k1\n     * @memberof common.PubKeySet\n     * @instance\n     */\n    PubKeySet.prototype.secp256k1 = \"\";\n\n    /**\n     * PubKeySet ed25519.\n     * @member {string} ed25519\n     * @memberof common.PubKeySet\n     * @instance\n     */\n    PubKeySet.prototype.ed25519 = \"\";\n\n    /**\n     * Creates a new PubKeySet instance using the specified properties.\n     * @function create\n     * @memberof common.PubKeySet\n     * @static\n     * @param {common.IPubKeySet=} [properties] Properties to set\n     * @returns {common.PubKeySet} PubKeySet instance\n     */\n    PubKeySet.create = function create(properties) {\n      return new PubKeySet(properties);\n    };\n\n    /**\n     * Encodes the specified PubKeySet message. Does not implicitly {@link common.PubKeySet.verify|verify} messages.\n     * @function encode\n     * @memberof common.PubKeySet\n     * @static\n     * @param {common.IPubKeySet} message PubKeySet message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PubKeySet.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.secp256k1 != null && Object.hasOwnProperty.call(message, \"secp256k1\"))\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.secp256k1);\n      if (message.ed25519 != null && Object.hasOwnProperty.call(message, \"ed25519\"))\n        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.ed25519);\n      return writer;\n    };\n\n    /**\n     * Encodes the specified PubKeySet message, length delimited. Does not implicitly {@link common.PubKeySet.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof common.PubKeySet\n     * @static\n     * @param {common.IPubKeySet} message PubKeySet message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PubKeySet.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a PubKeySet message from the specified reader or buffer.\n     * @function decode\n     * @memberof common.PubKeySet\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {common.PubKeySet} PubKeySet\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PubKeySet.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      const end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.common.PubKeySet();\n      while (reader.pos < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.secp256k1 = reader.string();\n            break;\n          case 2:\n            message.ed25519 = reader.string();\n            break;\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a PubKeySet message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof common.PubKeySet\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {common.PubKeySet} PubKeySet\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PubKeySet.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a PubKeySet message.\n     * @function verify\n     * @memberof common.PubKeySet\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    PubKeySet.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.secp256k1 != null && message.hasOwnProperty(\"secp256k1\"))\n        if (!$util.isString(message.secp256k1)) return \"secp256k1: string expected\";\n      if (message.ed25519 != null && message.hasOwnProperty(\"ed25519\"))\n        if (!$util.isString(message.ed25519)) return \"ed25519: string expected\";\n      return null;\n    };\n\n    /**\n     * Creates a PubKeySet message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof common.PubKeySet\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {common.PubKeySet} PubKeySet\n     */\n    PubKeySet.fromObject = function fromObject(object) {\n      if (object instanceof $root.common.PubKeySet) return object;\n      const message = new $root.common.PubKeySet();\n      if (object.secp256k1 != null) message.secp256k1 = String(object.secp256k1);\n      if (object.ed25519 != null) message.ed25519 = String(object.ed25519);\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a PubKeySet message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof common.PubKeySet\n     * @static\n     * @param {common.PubKeySet} message PubKeySet\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    PubKeySet.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      const object = {};\n      if (options.defaults) {\n        object.secp256k1 = \"\";\n        object.ed25519 = \"\";\n      }\n      if (message.secp256k1 != null && message.hasOwnProperty(\"secp256k1\"))\n        object.secp256k1 = message.secp256k1;\n      if (message.ed25519 != null && message.hasOwnProperty(\"ed25519\"))\n        object.ed25519 = message.ed25519;\n      return object;\n    };\n\n    /**\n     * Converts this PubKeySet to JSON.\n     * @function toJSON\n     * @memberof common.PubKeySet\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    PubKeySet.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return PubKeySet;\n  })();\n\n  common.Tx = (() => {\n    /**\n     * Properties of a Tx.\n     * @memberof common\n     * @interface ITx\n     * @property {string|null} [id] Tx id\n     * @property {string|null} [chain] Tx chain\n     * @property {string|null} [fromAddress] Tx fromAddress\n     * @property {string|null} [toAddress] Tx toAddress\n     * @property {Array.<common.ICoin>|null} [coins] Tx coins\n     * @property {Array.<common.ICoin>|null} [gas] Tx gas\n     * @property {string|null} [memo] Tx memo\n     */\n\n    /**\n     * Constructs a new Tx.\n     * @memberof common\n     * @classdesc Represents a Tx.\n     * @implements ITx\n     * @constructor\n     * @param {common.ITx=} [properties] Properties to set\n     */\n    function Tx(properties) {\n      this.coins = [];\n      this.gas = [];\n      if (properties)\n        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Tx id.\n     * @member {string} id\n     * @memberof common.Tx\n     * @instance\n     */\n    Tx.prototype.id = \"\";\n\n    /**\n     * Tx chain.\n     * @member {string} chain\n     * @memberof common.Tx\n     * @instance\n     */\n    Tx.prototype.chain = \"\";\n\n    /**\n     * Tx fromAddress.\n     * @member {string} fromAddress\n     * @memberof common.Tx\n     * @instance\n     */\n    Tx.prototype.fromAddress = \"\";\n\n    /**\n     * Tx toAddress.\n     * @member {string} toAddress\n     * @memberof common.Tx\n     * @instance\n     */\n    Tx.prototype.toAddress = \"\";\n\n    /**\n     * Tx coins.\n     * @member {Array.<common.ICoin>} coins\n     * @memberof common.Tx\n     * @instance\n     */\n    Tx.prototype.coins = $util.emptyArray;\n\n    /**\n     * Tx gas.\n     * @member {Array.<common.ICoin>} gas\n     * @memberof common.Tx\n     * @instance\n     */\n    Tx.prototype.gas = $util.emptyArray;\n\n    /**\n     * Tx memo.\n     * @member {string} memo\n     * @memberof common.Tx\n     * @instance\n     */\n    Tx.prototype.memo = \"\";\n\n    /**\n     * Creates a new Tx instance using the specified properties.\n     * @function create\n     * @memberof common.Tx\n     * @static\n     * @param {common.ITx=} [properties] Properties to set\n     * @returns {common.Tx} Tx instance\n     */\n    Tx.create = function create(properties) {\n      return new Tx(properties);\n    };\n\n    /**\n     * Encodes the specified Tx message. Does not implicitly {@link common.Tx.verify|verify} messages.\n     * @function encode\n     * @memberof common.Tx\n     * @static\n     * @param {common.ITx} message Tx message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Tx.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);\n      if (message.chain != null && Object.hasOwnProperty.call(message, \"chain\"))\n        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.chain);\n      if (message.fromAddress != null && Object.hasOwnProperty.call(message, \"fromAddress\"))\n        writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.fromAddress);\n      if (message.toAddress != null && Object.hasOwnProperty.call(message, \"toAddress\"))\n        writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.toAddress);\n      if (message.coins?.length)\n        for (let i = 0; i < message.coins.length; ++i)\n          $root.common.Coin.encode(\n            message.coins[i],\n            writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),\n          ).ldelim();\n      if (message.gas?.length)\n        for (let j = 0; j < message.gas.length; ++j)\n          $root.common.Coin.encode(\n            message.gas[j],\n            writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),\n          ).ldelim();\n      if (message.memo != null && Object.hasOwnProperty.call(message, \"memo\"))\n        writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.memo);\n      return writer;\n    };\n\n    /**\n     * Encodes the specified Tx message, length delimited. Does not implicitly {@link common.Tx.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof common.Tx\n     * @static\n     * @param {common.ITx} message Tx message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Tx.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Tx message from the specified reader or buffer.\n     * @function decode\n     * @memberof common.Tx\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {common.Tx} Tx\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Tx.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      const end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.common.Tx();\n      while (reader.pos < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.id = reader.string();\n            break;\n          case 2:\n            message.chain = reader.string();\n            break;\n          case 3:\n            message.fromAddress = reader.string();\n            break;\n          case 4:\n            message.toAddress = reader.string();\n            break;\n          case 5:\n            if (!message.coins?.length) message.coins = [];\n            message.coins.push($root.common.Coin.decode(reader, reader.uint32()));\n            break;\n          case 6:\n            if (!message.gas?.length) message.gas = [];\n            message.gas.push($root.common.Coin.decode(reader, reader.uint32()));\n            break;\n          case 7:\n            message.memo = reader.string();\n            break;\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a Tx message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof common.Tx\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {common.Tx} Tx\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Tx.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Tx message.\n     * @function verify\n     * @memberof common.Tx\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Tx.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.id != null && message.hasOwnProperty(\"id\"))\n        if (!$util.isString(message.id)) return \"id: string expected\";\n      if (message.chain != null && message.hasOwnProperty(\"chain\"))\n        if (!$util.isString(message.chain)) return \"chain: string expected\";\n      if (message.fromAddress != null && message.hasOwnProperty(\"fromAddress\"))\n        if (!$util.isString(message.fromAddress)) return \"fromAddress: string expected\";\n      if (message.toAddress != null && message.hasOwnProperty(\"toAddress\"))\n        if (!$util.isString(message.toAddress)) return \"toAddress: string expected\";\n      if (message.coins != null && message.hasOwnProperty(\"coins\")) {\n        if (!Array.isArray(message.coins)) return \"coins: array expected\";\n        for (let i = 0; i < message.coins.length; ++i) {\n          const error = $root.common.Coin.verify(message.coins[i]);\n          if (error) return \"coins.\" + error;\n        }\n      }\n      if (message.gas != null && message.hasOwnProperty(\"gas\")) {\n        if (!Array.isArray(message.gas)) return \"gas: array expected\";\n        for (let j = 0; j < message.gas.length; ++j) {\n          const error = $root.common.Coin.verify(message.gas[j]);\n          if (error) return \"gas.\" + error;\n        }\n      }\n      if (message.memo != null && message.hasOwnProperty(\"memo\"))\n        if (!$util.isString(message.memo)) return \"memo: string expected\";\n      return null;\n    };\n\n    /**\n     * Creates a Tx message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof common.Tx\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {common.Tx} Tx\n     */\n    Tx.fromObject = function fromObject(object) {\n      if (object instanceof $root.common.Tx) return object;\n      const message = new $root.common.Tx();\n      if (object.id != null) message.id = String(object.id);\n      if (object.chain != null) message.chain = String(object.chain);\n      if (object.fromAddress != null) message.fromAddress = String(object.fromAddress);\n      if (object.toAddress != null) message.toAddress = String(object.toAddress);\n      if (object.coins) {\n        if (!Array.isArray(object.coins)) throw TypeError(\".common.Tx.coins: array expected\");\n        message.coins = [];\n        for (let i = 0; i < object.coins.length; ++i) {\n          if (typeof object.coins[i] !== \"object\")\n            throw TypeError(\".common.Tx.coins: object expected\");\n          message.coins[i] = $root.common.Coin.fromObject(object.coins[i]);\n        }\n      }\n      if (object.gas) {\n        if (!Array.isArray(object.gas)) throw TypeError(\".common.Tx.gas: array expected\");\n        message.gas = [];\n        for (let i = 0; i < object.gas.length; ++i) {\n          if (typeof object.gas[i] !== \"object\") throw TypeError(\".common.Tx.gas: object expected\");\n          message.gas[i] = $root.common.Coin.fromObject(object.gas[i]);\n        }\n      }\n      if (object.memo != null) message.memo = String(object.memo);\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a Tx message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof common.Tx\n     * @static\n     * @param {common.Tx} message Tx\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Tx.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      const object = {};\n      if (options.arrays || options.defaults) {\n        object.coins = [];\n        object.gas = [];\n      }\n      if (options.defaults) {\n        object.id = \"\";\n        object.chain = \"\";\n        object.fromAddress = \"\";\n        object.toAddress = \"\";\n        object.memo = \"\";\n      }\n      if (message.id != null && message.hasOwnProperty(\"id\")) object.id = message.id;\n      if (message.chain != null && message.hasOwnProperty(\"chain\")) object.chain = message.chain;\n      if (message.fromAddress != null && message.hasOwnProperty(\"fromAddress\"))\n        object.fromAddress = message.fromAddress;\n      if (message.toAddress != null && message.hasOwnProperty(\"toAddress\"))\n        object.toAddress = message.toAddress;\n      if (message.coins?.length) {\n        object.coins = [];\n        for (let j = 0; j < message.coins.length; ++j)\n          object.coins[j] = $root.common.Coin.toObject(message.coins[j], options);\n      }\n      if (message.gas?.length) {\n        object.gas = [];\n        for (let j = 0; j < message.gas.length; ++j)\n          object.gas[j] = $root.common.Coin.toObject(message.gas[j], options);\n      }\n      if (message.memo != null && message.hasOwnProperty(\"memo\")) object.memo = message.memo;\n      return object;\n    };\n\n    /**\n     * Converts this Tx to JSON.\n     * @function toJSON\n     * @memberof common.Tx\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Tx.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Tx;\n  })();\n\n  common.Fee = (() => {\n    /**\n     * Properties of a Fee.\n     * @memberof common\n     * @interface IFee\n     * @property {Array.<common.ICoin>|null} [coins] Fee coins\n     * @property {string|null} [poolDeduct] Fee poolDeduct\n     */\n\n    /**\n     * Constructs a new Fee.\n     * @memberof common\n     * @classdesc Represents a Fee.\n     * @implements IFee\n     * @constructor\n     * @param {common.IFee=} [properties] Properties to set\n     */\n    function Fee(properties) {\n      this.coins = [];\n      if (properties)\n        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Fee coins.\n     * @member {Array.<common.ICoin>} coins\n     * @memberof common.Fee\n     * @instance\n     */\n    Fee.prototype.coins = $util.emptyArray;\n\n    /**\n     * Fee poolDeduct.\n     * @member {string} poolDeduct\n     * @memberof common.Fee\n     * @instance\n     */\n    Fee.prototype.poolDeduct = \"\";\n\n    /**\n     * Creates a new Fee instance using the specified properties.\n     * @function create\n     * @memberof common.Fee\n     * @static\n     * @param {common.IFee=} [properties] Properties to set\n     * @returns {common.Fee} Fee instance\n     */\n    Fee.create = function create(properties) {\n      return new Fee(properties);\n    };\n\n    /**\n     * Encodes the specified Fee message. Does not implicitly {@link common.Fee.verify|verify} messages.\n     * @function encode\n     * @memberof common.Fee\n     * @static\n     * @param {common.IFee} message Fee message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Fee.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.coins?.length)\n        for (let i = 0; i < message.coins.length; ++i)\n          $root.common.Coin.encode(\n            message.coins[i],\n            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),\n          ).ldelim();\n      if (message.poolDeduct != null && Object.hasOwnProperty.call(message, \"poolDeduct\"))\n        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.poolDeduct);\n      return writer;\n    };\n\n    /**\n     * Encodes the specified Fee message, length delimited. Does not implicitly {@link common.Fee.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof common.Fee\n     * @static\n     * @param {common.IFee} message Fee message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Fee.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Fee message from the specified reader or buffer.\n     * @function decode\n     * @memberof common.Fee\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {common.Fee} Fee\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Fee.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      const end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.common.Fee();\n      while (reader.pos < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            if (!message.coins?.length) message.coins = [];\n            message.coins.push($root.common.Coin.decode(reader, reader.uint32()));\n            break;\n          case 2:\n            message.poolDeduct = reader.string();\n            break;\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a Fee message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof common.Fee\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {common.Fee} Fee\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Fee.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Fee message.\n     * @function verify\n     * @memberof common.Fee\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Fee.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.coins != null && message.hasOwnProperty(\"coins\")) {\n        if (!Array.isArray(message.coins)) return \"coins: array expected\";\n        for (let i = 0; i < message.coins.length; ++i) {\n          const error = $root.common.Coin.verify(message.coins[i]);\n          if (error) return \"coins.\" + error;\n        }\n      }\n      if (message.poolDeduct != null && message.hasOwnProperty(\"poolDeduct\"))\n        if (!$util.isString(message.poolDeduct)) return \"poolDeduct: string expected\";\n      return null;\n    };\n\n    /**\n     * Creates a Fee message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof common.Fee\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {common.Fee} Fee\n     */\n    Fee.fromObject = function fromObject(object) {\n      if (object instanceof $root.common.Fee) return object;\n      const message = new $root.common.Fee();\n      if (object.coins) {\n        if (!Array.isArray(object.coins)) throw TypeError(\".common.Fee.coins: array expected\");\n        message.coins = [];\n        for (let i = 0; i < object.coins.length; ++i) {\n          if (typeof object.coins[i] !== \"object\")\n            throw TypeError(\".common.Fee.coins: object expected\");\n          message.coins[i] = $root.common.Coin.fromObject(object.coins[i]);\n        }\n      }\n      if (object.poolDeduct != null) message.poolDeduct = String(object.poolDeduct);\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a Fee message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof common.Fee\n     * @static\n     * @param {common.Fee} message Fee\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Fee.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      const object = {};\n      if (options.arrays || options.defaults) object.coins = [];\n      if (options.defaults) object.poolDeduct = \"\";\n      if (message.coins?.length) {\n        object.coins = [];\n        for (let j = 0; j < message.coins.length; ++j)\n          object.coins[j] = $root.common.Coin.toObject(message.coins[j], options);\n      }\n      if (message.poolDeduct != null && message.hasOwnProperty(\"poolDeduct\"))\n        object.poolDeduct = message.poolDeduct;\n      return object;\n    };\n\n    /**\n     * Converts this Fee to JSON.\n     * @function toJSON\n     * @memberof common.Fee\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Fee.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Fee;\n  })();\n\n  common.ProtoUint = (() => {\n    /**\n     * Properties of a ProtoUint.\n     * @memberof common\n     * @interface IProtoUint\n     * @property {string|null} [value] ProtoUint value\n     */\n\n    /**\n     * Constructs a new ProtoUint.\n     * @memberof common\n     * @classdesc Represents a ProtoUint.\n     * @implements IProtoUint\n     * @constructor\n     * @param {common.IProtoUint=} [properties] Properties to set\n     */\n    function ProtoUint(properties) {\n      if (properties)\n        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ProtoUint value.\n     * @member {string} value\n     * @memberof common.ProtoUint\n     * @instance\n     */\n    ProtoUint.prototype.value = \"\";\n\n    /**\n     * Creates a new ProtoUint instance using the specified properties.\n     * @function create\n     * @memberof common.ProtoUint\n     * @static\n     * @param {common.IProtoUint=} [properties] Properties to set\n     * @returns {common.ProtoUint} ProtoUint instance\n     */\n    ProtoUint.create = function create(properties) {\n      return new ProtoUint(properties);\n    };\n\n    /**\n     * Encodes the specified ProtoUint message. Does not implicitly {@link common.ProtoUint.verify|verify} messages.\n     * @function encode\n     * @memberof common.ProtoUint\n     * @static\n     * @param {common.IProtoUint} message ProtoUint message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ProtoUint.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.value != null && Object.hasOwnProperty.call(message, \"value\"))\n        writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.value);\n      return writer;\n    };\n\n    /**\n     * Encodes the specified ProtoUint message, length delimited. Does not implicitly {@link common.ProtoUint.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof common.ProtoUint\n     * @static\n     * @param {common.IProtoUint} message ProtoUint message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ProtoUint.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a ProtoUint message from the specified reader or buffer.\n     * @function decode\n     * @memberof common.ProtoUint\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {common.ProtoUint} ProtoUint\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ProtoUint.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      const end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.common.ProtoUint();\n      while (reader.pos < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.string();\n            break;\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a ProtoUint message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof common.ProtoUint\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {common.ProtoUint} ProtoUint\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ProtoUint.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a ProtoUint message.\n     * @function verify\n     * @memberof common.ProtoUint\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ProtoUint.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.value != null && message.hasOwnProperty(\"value\"))\n        if (!$util.isString(message.value)) return \"value: string expected\";\n      return null;\n    };\n\n    /**\n     * Creates a ProtoUint message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof common.ProtoUint\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {common.ProtoUint} ProtoUint\n     */\n    ProtoUint.fromObject = function fromObject(object) {\n      if (object instanceof $root.common.ProtoUint) return object;\n      const message = new $root.common.ProtoUint();\n      if (object.value != null) message.value = String(object.value);\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a ProtoUint message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof common.ProtoUint\n     * @static\n     * @param {common.ProtoUint} message ProtoUint\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ProtoUint.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      const object = {};\n      if (options.defaults) object.value = \"\";\n      if (message.value != null && message.hasOwnProperty(\"value\")) object.value = message.value;\n      return object;\n    };\n\n    /**\n     * Converts this ProtoUint to JSON.\n     * @function toJSON\n     * @memberof common.ProtoUint\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ProtoUint.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ProtoUint;\n  })();\n\n  return common;\n})();\n\n$root.types = (() => {\n  /**\n   * Namespace types.\n   * @exports types\n   * @namespace\n   */\n  const types = {};\n\n  types.MsgDeposit = (() => {\n    /**\n     * Properties of a MsgDeposit.\n     * @memberof types\n     * @interface IMsgDeposit\n     * @property {Array.<common.ICoin>|null} [coins] MsgDeposit coins\n     * @property {string|null} [memo] MsgDeposit memo\n     * @property {Uint8Array|null} [signer] MsgDeposit signer\n     */\n\n    /**\n     * Constructs a new MsgDeposit.\n     * @memberof types\n     * @classdesc Represents a MsgDeposit.\n     * @implements IMsgDeposit\n     * @constructor\n     * @param {types.IMsgDeposit=} [properties] Properties to set\n     */\n    function MsgDeposit(properties) {\n      this.coins = [];\n      if (properties)\n        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * MsgDeposit coins.\n     * @member {Array.<common.ICoin>} coins\n     * @memberof types.MsgDeposit\n     * @instance\n     */\n    MsgDeposit.prototype.coins = $util.emptyArray;\n\n    /**\n     * MsgDeposit memo.\n     * @member {string} memo\n     * @memberof types.MsgDeposit\n     * @instance\n     */\n    MsgDeposit.prototype.memo = \"\";\n\n    /**\n     * MsgDeposit signer.\n     * @member {Uint8Array} signer\n     * @memberof types.MsgDeposit\n     * @instance\n     */\n    MsgDeposit.prototype.signer = $util.newBuffer([]);\n\n    /**\n     * Creates a new MsgDeposit instance using the specified properties.\n     * @function create\n     * @memberof types.MsgDeposit\n     * @static\n     * @param {types.IMsgDeposit=} [properties] Properties to set\n     * @returns {types.MsgDeposit} MsgDeposit instance\n     */\n    MsgDeposit.create = function create(properties) {\n      return new MsgDeposit(properties);\n    };\n\n    /**\n     * Encodes the specified MsgDeposit message. Does not implicitly {@link types.MsgDeposit.verify|verify} messages.\n     * @function encode\n     * @memberof types.MsgDeposit\n     * @static\n     * @param {types.IMsgDeposit} message MsgDeposit message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    MsgDeposit.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.coins?.length)\n        for (let i = 0; i < message.coins.length; ++i)\n          $root.common.Coin.encode(\n            message.coins[i],\n            writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),\n          ).ldelim();\n      if (message.memo != null && Object.hasOwnProperty.call(message, \"memo\"))\n        writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.memo);\n      if (message.signer != null && Object.hasOwnProperty.call(message, \"signer\"))\n        writer.uint32(/* id 3, wireType 2 =*/ 26).bytes(message.signer);\n      return writer;\n    };\n\n    /**\n     * Encodes the specified MsgDeposit message, length delimited. Does not implicitly {@link types.MsgDeposit.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof types.MsgDeposit\n     * @static\n     * @param {types.IMsgDeposit} message MsgDeposit message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    MsgDeposit.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a MsgDeposit message from the specified reader or buffer.\n     * @function decode\n     * @memberof types.MsgDeposit\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {types.MsgDeposit} MsgDeposit\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    MsgDeposit.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      const end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.types.MsgDeposit();\n      while (reader.pos < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            if (!message.coins?.length) message.coins = [];\n            message.coins.push($root.common.Coin.decode(reader, reader.uint32()));\n            break;\n          case 2:\n            message.memo = reader.string();\n            break;\n          case 3:\n            message.signer = reader.bytes();\n            break;\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a MsgDeposit message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof types.MsgDeposit\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {types.MsgDeposit} MsgDeposit\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    MsgDeposit.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a MsgDeposit message.\n     * @function verify\n     * @memberof types.MsgDeposit\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    MsgDeposit.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.coins != null && message.hasOwnProperty(\"coins\")) {\n        if (!Array.isArray(message.coins)) return \"coins: array expected\";\n        for (let i = 0; i < message.coins.length; ++i) {\n          const error = $root.common.Coin.verify(message.coins[i]);\n          if (error) return \"coins.\" + error;\n        }\n      }\n      if (message.memo != null && message.hasOwnProperty(\"memo\"))\n        if (!$util.isString(message.memo)) return \"memo: string expected\";\n      if (message.signer != null && message.hasOwnProperty(\"signer\"))\n        if (\n          !(\n            (message.signer && typeof message.signer.length === \"number\") ||\n            $util.isString(message.signer)\n          )\n        )\n          return \"signer: buffer expected\";\n      return null;\n    };\n\n    /**\n     * Creates a MsgDeposit message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof types.MsgDeposit\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {types.MsgDeposit} MsgDeposit\n     */\n    MsgDeposit.fromObject = function fromObject(object) {\n      if (object instanceof $root.types.MsgDeposit) return object;\n      const message = new $root.types.MsgDeposit();\n      if (object.coins) {\n        if (!Array.isArray(object.coins))\n          throw TypeError(\".types.MsgDeposit.coins: array expected\");\n        message.coins = [];\n        for (let i = 0; i < object.coins.length; ++i) {\n          if (typeof object.coins[i] !== \"object\")\n            throw TypeError(\".types.MsgDeposit.coins: object expected\");\n          message.coins[i] = $root.common.Coin.fromObject(object.coins[i]);\n        }\n      }\n      if (object.memo != null) message.memo = String(object.memo);\n      if (object.signer != null)\n        if (typeof object.signer === \"string\")\n          $util.base64.decode(\n            object.signer,\n            (message.signer = $util.newBuffer($util.base64.length(object.signer))),\n            0,\n          );\n        else if (object.signer.length) message.signer = object.signer;\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a MsgDeposit message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof types.MsgDeposit\n     * @static\n     * @param {types.MsgDeposit} message MsgDeposit\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    MsgDeposit.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      const object = {};\n      if (options.arrays || options.defaults) object.coins = [];\n      if (options.defaults) {\n        object.memo = \"\";\n        if (options.bytes === String) object.signer = \"\";\n        else {\n          object.signer = [];\n          if (options.bytes !== Array) object.signer = $util.newBuffer(object.signer);\n        }\n      }\n      if (message.coins?.length) {\n        object.coins = [];\n        for (let j = 0; j < message.coins.length; ++j)\n          object.coins[j] = $root.common.Coin.toObject(message.coins[j], options);\n      }\n      if (message.memo != null && message.hasOwnProperty(\"memo\")) object.memo = message.memo;\n      if (message.signer != null && message.hasOwnProperty(\"signer\"))\n        object.signer =\n          options.bytes === String\n            ? $util.base64.encode(message.signer, 0, message.signer.length)\n            : options.bytes === Array\n              ? Array.prototype.slice.call(message.signer)\n              : message.signer;\n      return object;\n    };\n\n    /**\n     * Converts this MsgDeposit to JSON.\n     * @function toJSON\n     * @memberof types.MsgDeposit\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    MsgDeposit.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return MsgDeposit;\n  })();\n\n  types.MsgSend = (() => {\n    /**\n     * Properties of a MsgSend.\n     * @memberof types\n     * @interface IMsgSend\n     * @property {Uint8Array|null} [fromAddress] MsgSend fromAddress\n     * @property {Uint8Array|null} [toAddress] MsgSend toAddress\n     * @property {Array.<cosmos.base.v1beta1.ICoin>|null} [amount] MsgSend amount\n     */\n\n    /**\n     * Constructs a new MsgSend.\n     * @memberof types\n     * @classdesc Represents a MsgSend.\n     * @implements IMsgSend\n     * @constructor\n     * @param {types.IMsgSend=} [properties] Properties to set\n     */\n    function MsgSend(properties) {\n      this.amount = [];\n      if (properties)\n        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n          if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * MsgSend fromAddress.\n     * @member {Uint8Array} fromAddress\n     * @memberof types.MsgSend\n     * @instance\n     */\n    MsgSend.prototype.fromAddress = $util.newBuffer([]);\n\n    /**\n     * MsgSend toAddress.\n     * @member {Uint8Array} toAddress\n     * @memberof types.MsgSend\n     * @instance\n     */\n    MsgSend.prototype.toAddress = $util.newBuffer([]);\n\n    /**\n     * MsgSend amount.\n     * @member {Array.<cosmos.base.v1beta1.ICoin>} amount\n     * @memberof types.MsgSend\n     * @instance\n     */\n    MsgSend.prototype.amount = $util.emptyArray;\n\n    /**\n     * Creates a new MsgSend instance using the specified properties.\n     * @function create\n     * @memberof types.MsgSend\n     * @static\n     * @param {types.IMsgSend=} [properties] Properties to set\n     * @returns {types.MsgSend} MsgSend instance\n     */\n    MsgSend.create = function create(properties) {\n      return new MsgSend(properties);\n    };\n\n    /**\n     * Encodes the specified MsgSend message. Does not implicitly {@link types.MsgSend.verify|verify} messages.\n     * @function encode\n     * @memberof types.MsgSend\n     * @static\n     * @param {types.IMsgSend} message MsgSend message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    MsgSend.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.fromAddress != null && Object.hasOwnProperty.call(message, \"fromAddress\"))\n        writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.fromAddress);\n      if (message.toAddress != null && Object.hasOwnProperty.call(message, \"toAddress\"))\n        writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.toAddress);\n      if (message.amount?.length)\n        for (let i = 0; i < message.amount.length; ++i)\n          $root.cosmos.base.v1beta1.Coin.encode(\n            message.amount[i],\n            writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),\n          ).ldelim();\n      return writer;\n    };\n\n    /**\n     * Encodes the specified MsgSend message, length delimited. Does not implicitly {@link types.MsgSend.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof types.MsgSend\n     * @static\n     * @param {types.IMsgSend} message MsgSend message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    MsgSend.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a MsgSend message from the specified reader or buffer.\n     * @function decode\n     * @memberof types.MsgSend\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {types.MsgSend} MsgSend\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    MsgSend.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      const end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.types.MsgSend();\n      while (reader.pos < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.fromAddress = reader.bytes();\n            break;\n          case 2:\n            message.toAddress = reader.bytes();\n            break;\n          case 3:\n            if (!message.amount?.length) message.amount = [];\n            message.amount.push($root.cosmos.base.v1beta1.Coin.decode(reader, reader.uint32()));\n            break;\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Decodes a MsgSend message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof types.MsgSend\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {types.MsgSend} MsgSend\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    MsgSend.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a MsgSend message.\n     * @function verify\n     * @memberof types.MsgSend\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    MsgSend.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.fromAddress != null && message.hasOwnProperty(\"fromAddress\"))\n        if (\n          !(\n            (message.fromAddress && typeof message.fromAddress.length === \"number\") ||\n            $util.isString(message.fromAddress)\n          )\n        )\n          return \"fromAddress: buffer expected\";\n      if (message.toAddress != null && message.hasOwnProperty(\"toAddress\"))\n        if (\n          !(\n            (message.toAddress && typeof message.toAddress.length === \"number\") ||\n            $util.isString(message.toAddress)\n          )\n        )\n          return \"toAddress: buffer expected\";\n      if (message.amount != null && message.hasOwnProperty(\"amount\")) {\n        if (!Array.isArray(message.amount)) return \"amount: array expected\";\n        for (let i = 0; i < message.amount.length; ++i) {\n          const error = $root.cosmos.base.v1beta1.Coin.verify(message.amount[i]);\n          if (error) return \"amount.\" + error;\n        }\n      }\n      return null;\n    };\n\n    /**\n     * Creates a MsgSend message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof types.MsgSend\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {types.MsgSend} MsgSend\n     */\n    MsgSend.fromObject = function fromObject(object) {\n      if (object instanceof $root.types.MsgSend) return object;\n      const message = new $root.types.MsgSend();\n      if (object.fromAddress != null)\n        if (typeof object.fromAddress === \"string\")\n          $util.base64.decode(\n            object.fromAddress,\n            (message.fromAddress = $util.newBuffer($util.base64.length(object.fromAddress))),\n            0,\n          );\n        else if (object.fromAddress.length) message.fromAddress = object.fromAddress;\n      if (object.toAddress != null)\n        if (typeof object.toAddress === \"string\")\n          $util.base64.decode(\n            object.toAddress,\n            (message.toAddress = $util.newBuffer($util.base64.length(object.toAddress))),\n            0,\n          );\n        else if (object.toAddress.length) message.toAddress = object.toAddress;\n      if (object.amount) {\n        if (!Array.isArray(object.amount)) throw TypeError(\".types.MsgSend.amount: array expected\");\n        message.amount = [];\n        for (let i = 0; i < object.amount.length; ++i) {\n          if (typeof object.amount[i] !== \"object\")\n            throw TypeError(\".types.MsgSend.amount: object expected\");\n          message.amount[i] = $root.cosmos.base.v1beta1.Coin.fromObject(object.amount[i]);\n        }\n      }\n      return message;\n    };\n\n    /**\n     * Creates a plain object from a MsgSend message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof types.MsgSend\n     * @static\n     * @param {types.MsgSend} message MsgSend\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    MsgSend.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      const object = {};\n      if (options.arrays || options.defaults) object.amount = [];\n      if (options.defaults) {\n        if (options.bytes === String) object.fromAddress = \"\";\n        else {\n          object.fromAddress = [];\n          if (options.bytes !== Array) object.fromAddress = $util.newBuffer(object.fromAddress);\n        }\n        if (options.bytes === String) object.toAddress = \"\";\n        else {\n          object.toAddress = [];\n          if (options.bytes !== Array) object.toAddress = $util.newBuffer(object.toAddress);\n        }\n      }\n      if (message.fromAddress != null && message.hasOwnProperty(\"fromAddress\"))\n        object.fromAddress =\n          options.bytes === String\n            ? $util.base64.encode(message.fromAddress, 0, message.fromAddress.length)\n            : options.bytes === Array\n              ? Array.prototype.slice.call(message.fromAddress)\n              : message.fromAddress;\n      if (message.toAddress != null && message.hasOwnProperty(\"toAddress\"))\n        object.toAddress =\n          options.bytes === String\n            ? $util.base64.encode(message.toAddress, 0, message.toAddress.length)\n            : options.bytes === Array\n              ? Array.prototype.slice.call(message.toAddress)\n              : message.toAddress;\n      if (message.amount?.length) {\n        object.amount = [];\n        for (let j = 0; j < message.amount.length; ++j)\n          object.amount[j] = $root.cosmos.base.v1beta1.Coin.toObject(message.amount[j], options);\n      }\n      return object;\n    };\n\n    /**\n     * Converts this MsgSend to JSON.\n     * @function toJSON\n     * @memberof types.MsgSend\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    MsgSend.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return MsgSend;\n  })();\n\n  return types;\n})();\n\n$root.cosmos = (() => {\n  /**\n   * Namespace cosmos.\n   * @exports cosmos\n   * @namespace\n   */\n  const cosmos = {};\n\n  cosmos.base = (() => {\n    /**\n     * Namespace base.\n     * @memberof cosmos\n     * @namespace\n     */\n    const base = {};\n\n    base.v1beta1 = (() => {\n      /**\n       * Namespace v1beta1.\n       * @memberof cosmos.base\n       * @namespace\n       */\n      const v1beta1 = {};\n\n      v1beta1.Coin = (() => {\n        /**\n         * Properties of a Coin.\n         * @memberof cosmos.base.v1beta1\n         * @interface ICoin\n         * @property {string|null} [denom] Coin denom\n         * @property {string|null} [amount] Coin amount\n         */\n\n        /**\n         * Constructs a new Coin.\n         * @memberof cosmos.base.v1beta1\n         * @classdesc Represents a Coin.\n         * @implements ICoin\n         * @constructor\n         * @param {cosmos.base.v1beta1.ICoin=} [properties] Properties to set\n         */\n        function Coin(properties) {\n          if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Coin denom.\n         * @member {string} denom\n         * @memberof cosmos.base.v1beta1.Coin\n         * @instance\n         */\n        Coin.prototype.denom = \"\";\n\n        /**\n         * Coin amount.\n         * @member {string} amount\n         * @memberof cosmos.base.v1beta1.Coin\n         * @instance\n         */\n        Coin.prototype.amount = \"\";\n\n        /**\n         * Creates a new Coin instance using the specified properties.\n         * @function create\n         * @memberof cosmos.base.v1beta1.Coin\n         * @static\n         * @param {cosmos.base.v1beta1.ICoin=} [properties] Properties to set\n         * @returns {cosmos.base.v1beta1.Coin} Coin instance\n         */\n        Coin.create = function create(properties) {\n          return new Coin(properties);\n        };\n\n        /**\n         * Encodes the specified Coin message. Does not implicitly {@link cosmos.base.v1beta1.Coin.verify|verify} messages.\n         * @function encode\n         * @memberof cosmos.base.v1beta1.Coin\n         * @static\n         * @param {cosmos.base.v1beta1.ICoin} message Coin message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Coin.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.denom != null && Object.hasOwnProperty.call(message, \"denom\"))\n            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.denom);\n          if (message.amount != null && Object.hasOwnProperty.call(message, \"amount\"))\n            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.amount);\n          return writer;\n        };\n\n        /**\n         * Encodes the specified Coin message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.Coin.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof cosmos.base.v1beta1.Coin\n         * @static\n         * @param {cosmos.base.v1beta1.ICoin} message Coin message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Coin.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a Coin message from the specified reader or buffer.\n         * @function decode\n         * @memberof cosmos.base.v1beta1.Coin\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {cosmos.base.v1beta1.Coin} Coin\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Coin.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          const end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.cosmos.base.v1beta1.Coin();\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n              case 1:\n                message.denom = reader.string();\n                break;\n              case 2:\n                message.amount = reader.string();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n\n        /**\n         * Decodes a Coin message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof cosmos.base.v1beta1.Coin\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {cosmos.base.v1beta1.Coin} Coin\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Coin.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a Coin message.\n         * @function verify\n         * @memberof cosmos.base.v1beta1.Coin\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Coin.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.denom != null && message.hasOwnProperty(\"denom\"))\n            if (!$util.isString(message.denom)) return \"denom: string expected\";\n          if (message.amount != null && message.hasOwnProperty(\"amount\"))\n            if (!$util.isString(message.amount)) return \"amount: string expected\";\n          return null;\n        };\n\n        /**\n         * Creates a Coin message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof cosmos.base.v1beta1.Coin\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {cosmos.base.v1beta1.Coin} Coin\n         */\n        Coin.fromObject = function fromObject(object) {\n          if (object instanceof $root.cosmos.base.v1beta1.Coin) return object;\n          const message = new $root.cosmos.base.v1beta1.Coin();\n          if (object.denom != null) message.denom = String(object.denom);\n          if (object.amount != null) message.amount = String(object.amount);\n          return message;\n        };\n\n        /**\n         * Creates a plain object from a Coin message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof cosmos.base.v1beta1.Coin\n         * @static\n         * @param {cosmos.base.v1beta1.Coin} message Coin\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Coin.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          const object = {};\n          if (options.defaults) {\n            object.denom = \"\";\n            object.amount = \"\";\n          }\n          if (message.denom != null && message.hasOwnProperty(\"denom\"))\n            object.denom = message.denom;\n          if (message.amount != null && message.hasOwnProperty(\"amount\"))\n            object.amount = message.amount;\n          return object;\n        };\n\n        /**\n         * Converts this Coin to JSON.\n         * @function toJSON\n         * @memberof cosmos.base.v1beta1.Coin\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Coin.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Coin;\n      })();\n\n      v1beta1.DecCoin = (() => {\n        /**\n         * Properties of a DecCoin.\n         * @memberof cosmos.base.v1beta1\n         * @interface IDecCoin\n         * @property {string|null} [denom] DecCoin denom\n         * @property {string|null} [amount] DecCoin amount\n         */\n\n        /**\n         * Constructs a new DecCoin.\n         * @memberof cosmos.base.v1beta1\n         * @classdesc Represents a DecCoin.\n         * @implements IDecCoin\n         * @constructor\n         * @param {cosmos.base.v1beta1.IDecCoin=} [properties] Properties to set\n         */\n        function DecCoin(properties) {\n          if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * DecCoin denom.\n         * @member {string} denom\n         * @memberof cosmos.base.v1beta1.DecCoin\n         * @instance\n         */\n        DecCoin.prototype.denom = \"\";\n\n        /**\n         * DecCoin amount.\n         * @member {string} amount\n         * @memberof cosmos.base.v1beta1.DecCoin\n         * @instance\n         */\n        DecCoin.prototype.amount = \"\";\n\n        /**\n         * Creates a new DecCoin instance using the specified properties.\n         * @function create\n         * @memberof cosmos.base.v1beta1.DecCoin\n         * @static\n         * @param {cosmos.base.v1beta1.IDecCoin=} [properties] Properties to set\n         * @returns {cosmos.base.v1beta1.DecCoin} DecCoin instance\n         */\n        DecCoin.create = function create(properties) {\n          return new DecCoin(properties);\n        };\n\n        /**\n         * Encodes the specified DecCoin message. Does not implicitly {@link cosmos.base.v1beta1.DecCoin.verify|verify} messages.\n         * @function encode\n         * @memberof cosmos.base.v1beta1.DecCoin\n         * @static\n         * @param {cosmos.base.v1beta1.IDecCoin} message DecCoin message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        DecCoin.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.denom != null && Object.hasOwnProperty.call(message, \"denom\"))\n            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.denom);\n          if (message.amount != null && Object.hasOwnProperty.call(message, \"amount\"))\n            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.amount);\n          return writer;\n        };\n\n        /**\n         * Encodes the specified DecCoin message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.DecCoin.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof cosmos.base.v1beta1.DecCoin\n         * @static\n         * @param {cosmos.base.v1beta1.IDecCoin} message DecCoin message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        DecCoin.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a DecCoin message from the specified reader or buffer.\n         * @function decode\n         * @memberof cosmos.base.v1beta1.DecCoin\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {cosmos.base.v1beta1.DecCoin} DecCoin\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        DecCoin.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          const end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.cosmos.base.v1beta1.DecCoin();\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n              case 1:\n                message.denom = reader.string();\n                break;\n              case 2:\n                message.amount = reader.string();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n\n        /**\n         * Decodes a DecCoin message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof cosmos.base.v1beta1.DecCoin\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {cosmos.base.v1beta1.DecCoin} DecCoin\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        DecCoin.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a DecCoin message.\n         * @function verify\n         * @memberof cosmos.base.v1beta1.DecCoin\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        DecCoin.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.denom != null && message.hasOwnProperty(\"denom\"))\n            if (!$util.isString(message.denom)) return \"denom: string expected\";\n          if (message.amount != null && message.hasOwnProperty(\"amount\"))\n            if (!$util.isString(message.amount)) return \"amount: string expected\";\n          return null;\n        };\n\n        /**\n         * Creates a DecCoin message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof cosmos.base.v1beta1.DecCoin\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {cosmos.base.v1beta1.DecCoin} DecCoin\n         */\n        DecCoin.fromObject = function fromObject(object) {\n          if (object instanceof $root.cosmos.base.v1beta1.DecCoin) return object;\n          const message = new $root.cosmos.base.v1beta1.DecCoin();\n          if (object.denom != null) message.denom = String(object.denom);\n          if (object.amount != null) message.amount = String(object.amount);\n          return message;\n        };\n\n        /**\n         * Creates a plain object from a DecCoin message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof cosmos.base.v1beta1.DecCoin\n         * @static\n         * @param {cosmos.base.v1beta1.DecCoin} message DecCoin\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        DecCoin.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          const object = {};\n          if (options.defaults) {\n            object.denom = \"\";\n            object.amount = \"\";\n          }\n          if (message.denom != null && message.hasOwnProperty(\"denom\"))\n            object.denom = message.denom;\n          if (message.amount != null && message.hasOwnProperty(\"amount\"))\n            object.amount = message.amount;\n          return object;\n        };\n\n        /**\n         * Converts this DecCoin to JSON.\n         * @function toJSON\n         * @memberof cosmos.base.v1beta1.DecCoin\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        DecCoin.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return DecCoin;\n      })();\n\n      v1beta1.IntProto = (() => {\n        /**\n         * Properties of an IntProto.\n         * @memberof cosmos.base.v1beta1\n         * @interface IIntProto\n         * @property {string|null} [int] IntProto int\n         */\n\n        /**\n         * Constructs a new IntProto.\n         * @memberof cosmos.base.v1beta1\n         * @classdesc Represents an IntProto.\n         * @implements IIntProto\n         * @constructor\n         * @param {cosmos.base.v1beta1.IIntProto=} [properties] Properties to set\n         */\n        function IntProto(properties) {\n          if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * IntProto int.\n         * @member {string} int\n         * @memberof cosmos.base.v1beta1.IntProto\n         * @instance\n         */\n        IntProto.prototype.int = \"\";\n\n        /**\n         * Creates a new IntProto instance using the specified properties.\n         * @function create\n         * @memberof cosmos.base.v1beta1.IntProto\n         * @static\n         * @param {cosmos.base.v1beta1.IIntProto=} [properties] Properties to set\n         * @returns {cosmos.base.v1beta1.IntProto} IntProto instance\n         */\n        IntProto.create = function create(properties) {\n          return new IntProto(properties);\n        };\n\n        /**\n         * Encodes the specified IntProto message. Does not implicitly {@link cosmos.base.v1beta1.IntProto.verify|verify} messages.\n         * @function encode\n         * @memberof cosmos.base.v1beta1.IntProto\n         * @static\n         * @param {cosmos.base.v1beta1.IIntProto} message IntProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        IntProto.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.int != null && Object.hasOwnProperty.call(message, \"int\"))\n            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.int);\n          return writer;\n        };\n\n        /**\n         * Encodes the specified IntProto message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.IntProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof cosmos.base.v1beta1.IntProto\n         * @static\n         * @param {cosmos.base.v1beta1.IIntProto} message IntProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        IntProto.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an IntProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof cosmos.base.v1beta1.IntProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {cosmos.base.v1beta1.IntProto} IntProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        IntProto.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          const end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.cosmos.base.v1beta1.IntProto();\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n              case 1:\n                message.int = reader.string();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n\n        /**\n         * Decodes an IntProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof cosmos.base.v1beta1.IntProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {cosmos.base.v1beta1.IntProto} IntProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        IntProto.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an IntProto message.\n         * @function verify\n         * @memberof cosmos.base.v1beta1.IntProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        IntProto.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.int != null && message.hasOwnProperty(\"int\"))\n            if (!$util.isString(message.int)) return \"int: string expected\";\n          return null;\n        };\n\n        /**\n         * Creates an IntProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof cosmos.base.v1beta1.IntProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {cosmos.base.v1beta1.IntProto} IntProto\n         */\n        IntProto.fromObject = function fromObject(object) {\n          if (object instanceof $root.cosmos.base.v1beta1.IntProto) return object;\n          const message = new $root.cosmos.base.v1beta1.IntProto();\n          if (object.int != null) message.int = String(object.int);\n          return message;\n        };\n\n        /**\n         * Creates a plain object from an IntProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof cosmos.base.v1beta1.IntProto\n         * @static\n         * @param {cosmos.base.v1beta1.IntProto} message IntProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        IntProto.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          const object = {};\n          if (options.defaults) object.int = \"\";\n          if (message.int != null && message.hasOwnProperty(\"int\")) object.int = message.int;\n          return object;\n        };\n\n        /**\n         * Converts this IntProto to JSON.\n         * @function toJSON\n         * @memberof cosmos.base.v1beta1.IntProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        IntProto.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return IntProto;\n      })();\n\n      v1beta1.DecProto = (() => {\n        /**\n         * Properties of a DecProto.\n         * @memberof cosmos.base.v1beta1\n         * @interface IDecProto\n         * @property {string|null} [dec] DecProto dec\n         */\n\n        /**\n         * Constructs a new DecProto.\n         * @memberof cosmos.base.v1beta1\n         * @classdesc Represents a DecProto.\n         * @implements IDecProto\n         * @constructor\n         * @param {cosmos.base.v1beta1.IDecProto=} [properties] Properties to set\n         */\n        function DecProto(properties) {\n          if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * DecProto dec.\n         * @member {string} dec\n         * @memberof cosmos.base.v1beta1.DecProto\n         * @instance\n         */\n        DecProto.prototype.dec = \"\";\n\n        /**\n         * Creates a new DecProto instance using the specified properties.\n         * @function create\n         * @memberof cosmos.base.v1beta1.DecProto\n         * @static\n         * @param {cosmos.base.v1beta1.IDecProto=} [properties] Properties to set\n         * @returns {cosmos.base.v1beta1.DecProto} DecProto instance\n         */\n        DecProto.create = function create(properties) {\n          return new DecProto(properties);\n        };\n\n        /**\n         * Encodes the specified DecProto message. Does not implicitly {@link cosmos.base.v1beta1.DecProto.verify|verify} messages.\n         * @function encode\n         * @memberof cosmos.base.v1beta1.DecProto\n         * @static\n         * @param {cosmos.base.v1beta1.IDecProto} message DecProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        DecProto.encode = function encode(message, writer) {\n          if (!writer) writer = $Writer.create();\n          if (message.dec != null && Object.hasOwnProperty.call(message, \"dec\"))\n            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.dec);\n          return writer;\n        };\n\n        /**\n         * Encodes the specified DecProto message, length delimited. Does not implicitly {@link cosmos.base.v1beta1.DecProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof cosmos.base.v1beta1.DecProto\n         * @static\n         * @param {cosmos.base.v1beta1.IDecProto} message DecProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        DecProto.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a DecProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof cosmos.base.v1beta1.DecProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {cosmos.base.v1beta1.DecProto} DecProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        DecProto.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          const end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.cosmos.base.v1beta1.DecProto();\n          while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n              case 1:\n                message.dec = reader.string();\n                break;\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n\n        /**\n         * Decodes a DecProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof cosmos.base.v1beta1.DecProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {cosmos.base.v1beta1.DecProto} DecProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        DecProto.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a DecProto message.\n         * @function verify\n         * @memberof cosmos.base.v1beta1.DecProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        DecProto.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null) return \"object expected\";\n          if (message.dec != null && message.hasOwnProperty(\"dec\"))\n            if (!$util.isString(message.dec)) return \"dec: string expected\";\n          return null;\n        };\n\n        /**\n         * Creates a DecProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof cosmos.base.v1beta1.DecProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {cosmos.base.v1beta1.DecProto} DecProto\n         */\n        DecProto.fromObject = function fromObject(object) {\n          if (object instanceof $root.cosmos.base.v1beta1.DecProto) return object;\n          const message = new $root.cosmos.base.v1beta1.DecProto();\n          if (object.dec != null) message.dec = String(object.dec);\n          return message;\n        };\n\n        /**\n         * Creates a plain object from a DecProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof cosmos.base.v1beta1.DecProto\n         * @static\n         * @param {cosmos.base.v1beta1.DecProto} message DecProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        DecProto.toObject = function toObject(message, options) {\n          if (!options) options = {};\n          const object = {};\n          if (options.defaults) object.dec = \"\";\n          if (message.dec != null && message.hasOwnProperty(\"dec\")) object.dec = message.dec;\n          return object;\n        };\n\n        /**\n         * Converts this DecProto to JSON.\n         * @function toJSON\n         * @memberof cosmos.base.v1beta1.DecProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        DecProto.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return DecProto;\n      })();\n\n      return v1beta1;\n    })();\n\n    return base;\n  })();\n\n  return cosmos;\n})();\n\nexport default $root;\n",
    "import { Bip39, EnglishMnemonic, Slip10, Slip10Curve, stringToPath } from \"@cosmjs/crypto\";\nimport { DirectSecp256k1HdWallet, DirectSecp256k1Wallet } from \"@cosmjs/proto-signing\";\nimport { SwapKitApi } from \"@swapkit/api\";\nimport { AssetValue, Chain, ChainId, type DerivationPath } from \"@swapkit/helpers\";\n\nimport { CosmosClient } from \"../cosmosClient.ts\";\nimport type { ToolboxParams } from \"../index.ts\";\nimport type { BaseCosmosToolboxType } from \"../thorchainUtils/types/client-types.ts\";\nimport { USK_KUJIRA_FACTORY_DENOM } from \"../util.ts\";\n\ntype Params = {\n  client: CosmosClient;\n  decimal: number;\n  derivationPath: DerivationPath;\n};\n\nexport const getFeeRateFromThorswap = async (chainId: ChainId, safeDefault: number) => {\n  try {\n    const response = await SwapKitApi.getGasRates();\n\n    return response.find((gas) => gas.chainId === chainId)?.gas || safeDefault;\n  } catch (e) {\n    console.error(e);\n    return safeDefault;\n  }\n};\n\n// TODO: figure out some better way to initialize from base value\nexport const getAssetFromDenom = (denom: string, amount: string) => {\n  switch (denom) {\n    case \"rune\":\n      return AssetValue.from({ chain: Chain.THORChain, value: Number.parseInt(amount) / 1e8 });\n    case \"uatom\":\n    case \"atom\":\n      return AssetValue.from({ chain: Chain.Cosmos, value: Number.parseInt(amount) / 1e6 });\n    case \"cacao\":\n      return AssetValue.from({ chain: Chain.Maya, value: Number.parseInt(amount) / 1e10 });\n    case \"maya\":\n      return AssetValue.from({\n        asset: `${Chain.Maya}.${Chain.Maya}`,\n        value: Number.parseInt(amount) / 1e4,\n      });\n    case \"ukuji\":\n    case \"kuji\":\n      return AssetValue.from({ chain: Chain.Kujira, value: Number.parseInt(amount) / 1e6 });\n    case USK_KUJIRA_FACTORY_DENOM:\n      // USK on Kujira\n      return AssetValue.from({\n        asset: `${Chain.Kujira}.USK`,\n        value: Number.parseInt(amount) / 1e6,\n      });\n\n    default:\n      return AssetValue.from({ asset: denom, value: Number.parseInt(amount) / 1e8 });\n  }\n};\n\nexport const BaseCosmosToolbox = ({\n  derivationPath,\n  client: cosmosClient,\n}: Params): BaseCosmosToolboxType => ({\n  transfer: cosmosClient.transfer,\n  getSigner: (phrase: string) => {\n    return DirectSecp256k1HdWallet.fromMnemonic(phrase, {\n      prefix: cosmosClient.prefix,\n      hdPaths: [stringToPath(`${derivationPath}/0`)],\n    });\n  },\n  getSignerFromPrivateKey: (privateKey: Uint8Array) => {\n    return DirectSecp256k1Wallet.fromKey(privateKey, cosmosClient.prefix);\n  },\n  createPrivateKeyFromPhrase: async (phrase: string) => {\n    const derivationPathString = stringToPath(`${derivationPath}/0`);\n    const mnemonicChecked = new EnglishMnemonic(phrase);\n    const seed = await Bip39.mnemonicToSeed(mnemonicChecked);\n\n    const { privkey } = Slip10.derivePath(Slip10Curve.Secp256k1, seed, derivationPathString);\n\n    return privkey;\n  },\n  getAccount: cosmosClient.getAccount,\n  validateAddress: cosmosClient.checkAddress,\n  getAddressFromMnemonic: (phrase: string) =>\n    cosmosClient.getAddressFromMnemonic(phrase, `${derivationPath}/0`),\n  getPubKeyFromMnemonic: (phrase: string) =>\n    cosmosClient.getPubKeyFromMnemonic(phrase, `${derivationPath}/0`),\n  getFeeRateFromThorswap,\n  getBalance: async (address: string, _potentialScamFilter?: boolean) => {\n    const denomBalances = await cosmosClient.getBalance(address);\n    return await Promise.all(\n      denomBalances\n        .filter(({ denom }) => denom && !denom.includes(\"IBC/\"))\n        .map(({ denom, amount }) => getAssetFromDenom(denom, amount)),\n    );\n  },\n});\n\nexport const cosmosValidateAddress = ({\n  address,\n  chain,\n  stagenet = false,\n  server,\n}: ToolboxParams & {\n  address: string;\n  chain: Chain.THORChain | Chain.Maya | Chain.Kujira | Chain.Cosmos;\n}) => {\n  switch (chain) {\n    case Chain.Cosmos: {\n      const client = new CosmosClient({\n        server: server || \"https://node-router.thorswap.net/cosmos/rest\",\n        chainId: ChainId.Cosmos,\n      });\n      return client.checkAddress(address);\n    }\n\n    case Chain.Kujira: {\n      const client = new CosmosClient({\n        server: server || \"https://lcd-kujira.synergynodes.com/\",\n        chainId: ChainId.Kujira,\n        prefix: \"kujira\",\n      });\n      return client.checkAddress(address);\n    }\n    case Chain.THORChain: {\n      const client = new CosmosClient({\n        server: stagenet\n          ? \"https://stagenet-thornode.ninerealms.com\"\n          : \"https://thornode.thorswap.net\",\n        chainId: stagenet ? ChainId.THORChainStagenet : ChainId.THORChain,\n        prefix: `${stagenet ? \"s\" : \"\"}thor`,\n        stagenet,\n      });\n      return client.checkAddress(address);\n    }\n\n    case Chain.Maya: {\n      const client = new CosmosClient({\n        server: stagenet\n          ? \"https://stagenet.mayanode.mayachain.info\"\n          : \"https://mayanode.mayachain.info\",\n        chainId: stagenet ? ChainId.MayaStagenet : ChainId.Maya,\n        prefix: `${stagenet ? \"s\" : \"\"}maya`,\n        stagenet,\n      });\n      return client.checkAddress(address);\n    }\n  }\n  return false;\n};\n\nexport const estimateTransactionFee = ({ assetValue }: { assetValue: AssetValue }) => {\n  const chain = assetValue.chain;\n  switch (chain) {\n    case Chain.Cosmos: {\n      return AssetValue.from({ chain: Chain.Cosmos, value: 0.007 });\n    }\n    case Chain.Kujira: {\n      return AssetValue.from({ chain: Chain.Kujira, value: 0.02 });\n    }\n    case Chain.THORChain: {\n      return AssetValue.from({ chain: Chain.THORChain, value: 0.02 });\n    }\n    case Chain.Maya: {\n      return AssetValue.from({ chain: Chain.Maya, value: 0.02 });\n    }\n    default:\n      return assetValue.set(0);\n  }\n};\n\nexport type BaseCosmosWallet = ReturnType<typeof BaseCosmosToolbox>;\nexport type CosmosWallets = {\n  [chain in Chain.Cosmos | Chain.Kujira]: BaseCosmosWallet;\n};\n",
    "import { type AccountData, Secp256k1HdWallet } from \"@cosmjs/amino\";\nimport type { StdFee } from \"@cosmjs/stargate\";\nimport { base64, bech32 } from \"@scure/base\";\nimport { type ChainId, SwapKitError } from \"@swapkit/helpers\";\n\nimport { stringToPath } from \"@cosmjs/crypto\";\nimport type { CosmosSDKClientParams, TransferParams } from \"./types.ts\";\nimport {\n  DEFAULT_COSMOS_FEE_MAINNET,\n  createSigningStargateClient,\n  createStargateClient,\n  getDenom,\n  getRPC,\n} from \"./util.ts\";\n\nexport class CosmosClient {\n  server: string;\n  chainId: ChainId;\n  prefix = \"\";\n  rpcUrl;\n\n  // by default, cosmos chain\n  constructor({ server, chainId, prefix = \"cosmos\", stagenet = false }: CosmosSDKClientParams) {\n    this.rpcUrl = getRPC(chainId, stagenet);\n    this.server = server;\n    this.chainId = chainId;\n    this.prefix = prefix;\n  }\n\n  getAddressFromMnemonic = async (mnemonic: string, derivationPath: string) => {\n    const walletAccount = await this.#getWalletAccount(mnemonic, derivationPath);\n\n    return walletAccount.address;\n  };\n\n  getPubKeyFromMnemonic = async (mnemonic: string, derivationPath: string) => {\n    const walletAccount = await this.#getWalletAccount(mnemonic, derivationPath);\n\n    return base64.encode(walletAccount.pubkey);\n  };\n\n  checkAddress = (address: string) => {\n    if (!address.startsWith(this.prefix)) return false;\n\n    try {\n      const { prefix, words } = bech32.decode(address);\n      const normalized = bech32.encode(prefix, words);\n\n      return normalized === address.toLocaleLowerCase();\n    } catch (_error) {\n      return false;\n    }\n  };\n\n  getBalance = async (address: string) => {\n    const client = await createStargateClient(this.rpcUrl);\n\n    const allBalances = (await client.getAllBalances(address)) as unknown as {\n      denom: string;\n      amount: string;\n    }[];\n\n    return allBalances.map((balance) => ({\n      ...balance,\n      denom: balance.denom.includes(\"/\") ? balance.denom.toUpperCase() : balance.denom,\n    }));\n  };\n\n  getAccount = async (address: string) => {\n    const client = await createStargateClient(this.rpcUrl);\n    return client.getAccount(address);\n  };\n\n  transfer = async ({\n    from,\n    recipient,\n    assetValue,\n    memo = \"\",\n    fee = DEFAULT_COSMOS_FEE_MAINNET,\n    signer,\n  }: TransferParams) => {\n    if (!signer) {\n      throw new SwapKitError(\"toolbox_cosmos_signer_not_defined\");\n    }\n\n    const signingClient = await createSigningStargateClient(this.rpcUrl, signer);\n    const txResponse = await signingClient.sendTokens(\n      from,\n      recipient,\n      [\n        {\n          denom: getDenom(`u${assetValue.symbol}`).toLowerCase(),\n          amount: assetValue.getBaseValue(\"string\"),\n        },\n      ],\n      fee as StdFee,\n      memo,\n    );\n\n    return txResponse.transactionHash;\n  };\n\n  #getWallet = (mnemonic: string, derivationPath: string) => {\n    return Secp256k1HdWallet.fromMnemonic(mnemonic, {\n      prefix: this.prefix,\n      hdPaths: [stringToPath(derivationPath)],\n    });\n  };\n\n  #getWalletAccount = async (mnemonic: string, derivationPath: string) => {\n    const wallet = await this.#getWallet(mnemonic, derivationPath);\n    const accounts = await wallet.getAccounts();\n\n    if (accounts.length === 0) {\n      throw new SwapKitError(\"toolbox_cosmos_no_accounts_found\");\n    }\n\n    return accounts[0] as AccountData;\n  };\n}\n",
    "import type { OfflineDirectSigner } from \"@cosmjs/proto-signing\";\nimport type { Account } from \"@cosmjs/stargate\";\nimport {\n  type AssetValue,\n  BaseDecimal,\n  ChainId,\n  DerivationPath,\n  SwapKitNumber,\n} from \"@swapkit/helpers\";\n\nimport { CosmosClient } from \"../cosmosClient.ts\";\nimport type { GaiaToolboxType, ToolboxParams } from \"../index.ts\";\nimport type { TransferParams } from \"../types.ts\";\n\nimport { BaseCosmosToolbox, getFeeRateFromThorswap } from \"./BaseCosmosToolbox.ts\";\n\nexport const GaiaToolbox = ({ server }: ToolboxParams = {}): GaiaToolboxType => {\n  const client = new CosmosClient({\n    server: server || \"https://node-router.thorswap.net/cosmos/rest\",\n    chainId: ChainId.Cosmos,\n  });\n\n  const baseToolbox: {\n    validateAddress: (address: string) => boolean;\n    getAddressFromMnemonic: (phrase: string) => Promise<string>;\n    getAccount: (address: string) => Promise<Account | null>;\n    getBalance: (address: string, potentialScamFilter?: boolean) => Promise<AssetValue[]>;\n    transfer: (params: TransferParams) => Promise<string>;\n    getSigner: (phrase: string) => Promise<OfflineDirectSigner>;\n    getSignerFromPrivateKey: (privateKey: Uint8Array) => Promise<OfflineDirectSigner>;\n    getPubKeyFromMnemonic: (phrase: string) => Promise<string>;\n    createPrivateKeyFromPhrase: (phrase: string) => Promise<Uint8Array>;\n  } = BaseCosmosToolbox({\n    decimal: BaseDecimal.GAIA,\n    derivationPath: DerivationPath.GAIA,\n    client,\n  });\n\n  async function getFees() {\n    const baseFee = await getFeeRateFromThorswap(ChainId.Cosmos, 500);\n    return {\n      type: \"base\",\n      average: SwapKitNumber.fromBigInt(BigInt(baseFee), BaseDecimal.GAIA),\n      fast: SwapKitNumber.fromBigInt((BigInt(baseFee) * 15n) / 10n, BaseDecimal.GAIA),\n      fastest: SwapKitNumber.fromBigInt(BigInt(baseFee) * 2n, BaseDecimal.GAIA),\n    };\n  }\n\n  async function transfer(params: TransferParams) {\n    const gasFees = await getFees();\n\n    return baseToolbox.transfer({\n      ...params,\n      fee: params.fee || {\n        amount: [\n          {\n            denom: \"uatom\",\n            amount: gasFees[params.feeOptionKey || \"fast\"].getBaseValue(\"string\") || \"1000\",\n          },\n        ],\n        gas: \"200000\",\n      },\n    });\n  }\n\n  return {\n    ...baseToolbox,\n    getFees,\n    transfer,\n  };\n};\n",
    "import { Chain } from \"@swapkit/helpers\";\n\nimport { GaiaToolbox } from \"./gaia.ts\";\nimport { KujiraToolbox } from \"./kujira.ts\";\nimport { MayaToolbox, ThorchainToolbox } from \"./thorchain.ts\";\n\ntype ToolboxType = {\n  THOR: typeof ThorchainToolbox;\n  GAIA: typeof GaiaToolbox;\n  KUJI: typeof KujiraToolbox;\n  MAYA: typeof MayaToolbox;\n};\n\nexport const getToolboxByChain = <T extends keyof ToolboxType>(chain: T): ToolboxType[T] => {\n  switch (chain) {\n    case Chain.Kujira:\n      return KujiraToolbox as ToolboxType[T];\n    case Chain.Maya:\n      return MayaToolbox as ToolboxType[T];\n    case Chain.THORChain:\n      return ThorchainToolbox as ToolboxType[T];\n    case Chain.Cosmos:\n      return GaiaToolbox as ToolboxType[T];\n    default:\n      throw new Error(`Chain ${chain} is not supported`);\n  }\n};\n",
    "import type { OfflineDirectSigner } from \"@cosmjs/proto-signing\";\nimport type { Account } from \"@cosmjs/stargate\";\nimport {\n  type AssetValue,\n  BaseDecimal,\n  ChainId,\n  DerivationPath,\n  SwapKitNumber,\n} from \"@swapkit/helpers\";\n\nimport { CosmosClient } from \"../cosmosClient.ts\";\nimport {\n  type KujiraToolboxType,\n  type ToolboxParams,\n  USK_KUJIRA_FACTORY_DENOM,\n  YUM_KUJIRA_FACTORY_DENOM,\n} from \"../index.ts\";\nimport type { TransferParams } from \"../types.ts\";\n\nimport {\n  BaseCosmosToolbox,\n  getAssetFromDenom,\n  getFeeRateFromThorswap,\n} from \"./BaseCosmosToolbox.ts\";\n\nasync function getFees() {\n  const baseFee = await getFeeRateFromThorswap(ChainId.Kujira, 1000);\n  return {\n    type: \"base\",\n    average: SwapKitNumber.fromBigInt(BigInt(baseFee), BaseDecimal.KUJI),\n    fast: SwapKitNumber.fromBigInt(BigInt(Math.floor(baseFee * 1.5)), BaseDecimal.KUJI),\n    fastest: SwapKitNumber.fromBigInt(BigInt(Math.floor(baseFee * 2)), BaseDecimal.KUJI),\n  };\n}\n\nexport const KujiraToolbox = ({ server }: ToolboxParams = {}): KujiraToolboxType => {\n  const client = new CosmosClient({\n    server: server || \"https://lcd-kujira.synergynodes.com/\",\n    chainId: ChainId.Kujira,\n    prefix: \"kujira\",\n  });\n\n  const baseToolbox: {\n    validateAddress: (address: string) => boolean;\n    getAddressFromMnemonic: (phrase: string) => Promise<string>;\n    getAccount: (address: string) => Promise<Account | null>;\n    getBalance: (address: string, potentialScamFilter?: boolean) => Promise<AssetValue[]>;\n    transfer: (params: TransferParams) => Promise<string>;\n    getSigner: (phrase: string) => Promise<OfflineDirectSigner>;\n    getSignerFromPrivateKey: (privateKey: Uint8Array) => Promise<OfflineDirectSigner>;\n    getPubKeyFromMnemonic: (phrase: string) => Promise<string>;\n    createPrivateKeyFromPhrase: (phrase: string) => Promise<Uint8Array>;\n  } = BaseCosmosToolbox({\n    decimal: BaseDecimal.KUJI,\n    derivationPath: DerivationPath.KUJI,\n    client,\n  });\n\n  return {\n    ...baseToolbox,\n    getFees,\n    getBalance: async (address: string, _potentialScamFilter?: boolean) => {\n      const denomBalances = await client.getBalance(address);\n      return await Promise.all(\n        denomBalances\n          .filter(({ denom }) => {\n            if (!denom || denom.includes(\"IBC/\")) return false;\n\n            return (\n              [USK_KUJIRA_FACTORY_DENOM, YUM_KUJIRA_FACTORY_DENOM].includes(denom) ||\n              !denom.startsWith(\"FACTORY\")\n            );\n          })\n          .map(({ denom, amount }) => getAssetFromDenom(denom, amount)),\n      );\n    },\n    transfer: async (params: TransferParams) => {\n      const gasFees = await getFees();\n\n      return baseToolbox.transfer({\n        ...params,\n        fee: params.fee || {\n          amount: [\n            {\n              denom: \"ukuji\",\n              amount: gasFees[params.feeOptionKey || \"fast\"].getBaseValue(\"string\") || \"1000\",\n            },\n          ],\n          gas: \"200000\",\n        },\n      });\n    },\n  };\n};\n",
    "import {\n  type Pubkey,\n  Secp256k1HdWallet,\n  createMultisigThresholdPubkey,\n  encodeSecp256k1Pubkey,\n  pubkeyToAddress,\n} from \"@cosmjs/amino\";\nimport { Secp256k1, Secp256k1Signature, stringToPath } from \"@cosmjs/crypto\";\nimport type { OfflineDirectSigner } from \"@cosmjs/proto-signing\";\nimport { type Account, makeMultisignedTxBytes } from \"@cosmjs/stargate\";\nimport { base64 } from \"@scure/base\";\nimport {\n  type AssetValue,\n  BaseDecimal,\n  Chain,\n  ChainId,\n  DerivationPath,\n  FeeOption,\n  RequestClient,\n  SwapKitError,\n  SwapKitNumber,\n} from \"@swapkit/helpers\";\n\nimport { CosmosClient } from \"../cosmosClient.ts\";\nimport {\n  buildAminoMsg,\n  buildEncodedTxBody,\n  buildTransaction,\n  convertToSignable,\n  createDefaultAminoTypes,\n  createDefaultRegistry,\n  getDefaultChainFee,\n  prepareMessageForBroadcast,\n} from \"../thorchainUtils/index.ts\";\nimport type {\n  DepositParam,\n  MayaToolboxType,\n  ThorchainConstantsResponse,\n  ThorchainToolboxType,\n} from \"../thorchainUtils/types/client-types.ts\";\nimport type { Signer, ToolboxParams, TransferParams } from \"../types.ts\";\nimport {\n  createOfflineStargateClient,\n  createSigningStargateClient,\n  createStargateClient,\n  getRPC,\n} from \"../util.ts\";\n\nimport { BaseCosmosToolbox } from \"./BaseCosmosToolbox.ts\";\n\nconst secp256k1HdWalletFromMnemonic =\n  ({ prefix, derivationPath }: { prefix: string; derivationPath: string }) =>\n  (mnemonic: string, index = 0) => {\n    return Secp256k1HdWallet.fromMnemonic(mnemonic, {\n      hdPaths: [stringToPath(`${derivationPath}/${index}`)],\n      prefix,\n    });\n  };\n\nconst exportSignature = (signature: Uint8Array) => base64.encode(signature);\n\nconst signMultisigTx = async (\n  wallet: Secp256k1HdWallet,\n  tx: string,\n  chain: Chain.THORChain | Chain.Maya,\n) => {\n  const { msgs, accountNumber, sequence, chainId, fee, memo } = JSON.parse(tx);\n\n  const address = (await wallet.getAccounts())?.[0]?.address || \"\";\n  const aminoTypes = await createDefaultAminoTypes(chain);\n  const registry = await createDefaultRegistry();\n  const signingClient = await createOfflineStargateClient(wallet, {\n    registry,\n    aminoTypes,\n  });\n\n  const msgForSigning = [];\n\n  for (const msg of msgs) {\n    const signMsg = await convertToSignable(msg, chain);\n    msgForSigning.push(signMsg);\n  }\n\n  const {\n    signatures: [signature],\n  } = await signingClient.sign(address, msgForSigning, fee, memo, {\n    accountNumber,\n    sequence,\n    chainId,\n  });\n\n  const bodyBytes = await buildEncodedTxBody({\n    chain,\n    msgs: msgs.map((msg: NotWorth) => prepareMessageForBroadcast(msg)),\n    memo,\n  });\n\n  return { signature: exportSignature(signature as Uint8Array), bodyBytes };\n};\n\nconst broadcastMultisigTx =\n  ({ prefix, rpcUrl }: { prefix: string; rpcUrl: string }) =>\n  async (\n    tx: string,\n    signers: Signer[],\n    membersPubKeys: string[],\n    threshold: number,\n    bodyBytes: Uint8Array,\n  ) => {\n    const { sequence, fee } = JSON.parse(tx);\n    const multisigPubkey = await createMultisig(membersPubKeys, threshold);\n\n    const addressesAndSignatures: [string, Uint8Array][] = signers.map((signer) => [\n      pubkeyToAddress(encodeSecp256k1Pubkey(base64.decode(signer.pubKey)), prefix),\n      base64.decode(signer.signature),\n    ]);\n\n    const broadcaster = await createStargateClient(rpcUrl);\n\n    const { transactionHash } = await broadcaster.broadcastTx(\n      makeMultisignedTxBytes(\n        multisigPubkey,\n        sequence,\n        fee,\n        bodyBytes,\n        new Map<string, Uint8Array>(addressesAndSignatures),\n      ),\n    );\n\n    return transactionHash;\n  };\n\nconst createMultisig = async (pubKeys: string[], threshold: number, noSortPubKeys = true) => {\n  return createMultisigThresholdPubkey(\n    pubKeys.map((pubKey) => encodeSecp256k1Pubkey(base64.decode(pubKey))),\n    threshold,\n    noSortPubKeys,\n  );\n};\n\nconst importSignature = (signature: string) => base64.decode(signature);\n\nconst __REEXPORT__pubkeyToAddress = (prefix: string) => (pubkey: Pubkey) => {\n  return pubkeyToAddress(pubkey, prefix);\n};\n\nconst signWithPrivateKey = async ({\n  privateKey,\n  message,\n}: { privateKey: Uint8Array; message: string }) => {\n  const signature = await Secp256k1.createSignature(base64.decode(message), privateKey);\n  return base64.encode(Buffer.concat([signature.r(32), signature.s(32)]));\n};\n\nfunction verifySignature(getAccount: (address: string) => Promise<Account | null>) {\n  return async function verifySignature({\n    signature,\n    message,\n    address,\n  }: {\n    signature: string;\n    message: string;\n    address: string;\n  }) {\n    const account = await getAccount(address);\n    if (!account?.pubkey) throw new SwapKitError(\"toolbox_cosmos_verify_signature_no_pubkey\");\n\n    const secpSignature = Secp256k1Signature.fromFixedLength(base64.decode(signature));\n    return Secp256k1.verifySignature(secpSignature, base64.decode(message), account.pubkey.value);\n  };\n}\n\nexport const BaseThorchainToolbox = ({\n  chain,\n  stagenet,\n}: ToolboxParams & {\n  chain: Chain.THORChain | Chain.Maya;\n}): ThorchainToolboxType => {\n  const isThorchain = chain === Chain.THORChain;\n  const isMaya = chain === Chain.Maya;\n  const chainId = isThorchain ? ChainId.THORChain : ChainId.Maya;\n\n  const prefix = `${stagenet ? \"s\" : \"\"}${chain.toLowerCase()}`;\n  const derivationPath = DerivationPath[chain];\n  const rpcUrl = getRPC(chainId, stagenet);\n  const nodeUrl = stagenet\n    ? isMaya\n      ? \"https://stagenet.mayanode.mayachain.info\"\n      : \"https://stagenet-thornode.ninerealms.com\"\n    : isMaya\n      ? \"https://mayanode.mayachain.info\"\n      : \"https://thornode.thorswap.net\";\n\n  const client = new CosmosClient({\n    server: nodeUrl,\n    chainId,\n    prefix,\n    stagenet,\n  });\n  const defaultFee = getDefaultChainFee(chain);\n\n  const baseToolbox: {\n    createPrivateKeyFromPhrase: (phrase: string) => Promise<Uint8Array>;\n    getAccount: (address: string) => Promise<Account | null>;\n    validateAddress: (address: string) => boolean;\n    getAddressFromMnemonic: (phrase: string) => Promise<string>;\n    getPubKeyFromMnemonic: (phrase: string) => Promise<string>;\n    getBalance: (address: string, potentialScamFilter?: boolean) => Promise<AssetValue[]>;\n    getSigner: (phrase: string) => Promise<OfflineDirectSigner>;\n    getSignerFromPrivateKey: (privateKey: Uint8Array) => Promise<OfflineDirectSigner>;\n  } = BaseCosmosToolbox({\n    client,\n    derivationPath,\n    decimal: BaseDecimal[chain],\n  });\n\n  const loadAddressBalances = async (address: string) => {\n    try {\n      const balances: AssetValue[] = await baseToolbox.getBalance(address);\n\n      return balances;\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  };\n\n  const getFees = async () => {\n    let fee: SwapKitNumber;\n\n    const constantsUrl = `${nodeUrl}/${isThorchain ? \"thorchain\" : \"mayachain\"}/constants}`;\n\n    try {\n      const {\n        int_64_values: { NativeTransactionFee: nativeFee },\n      } = await RequestClient.get<ThorchainConstantsResponse>(constantsUrl);\n\n      // validate data\n      if (!nativeFee || Number.isNaN(nativeFee) || nativeFee < 0)\n        throw Error(`Invalid nativeFee: ${nativeFee.toString()}`);\n\n      fee = new SwapKitNumber(nativeFee);\n    } catch {\n      fee = new SwapKitNumber({\n        value: isThorchain ? 0.02 : 1,\n        decimal: BaseDecimal[chain],\n      });\n    }\n\n    return {\n      [FeeOption.Average]: fee,\n      [FeeOption.Fast]: fee,\n      [FeeOption.Fastest]: fee,\n    };\n  };\n\n  const transfer = async ({\n    from,\n    recipient,\n    assetValue,\n    memo = \"\",\n    signer,\n  }: Omit<TransferParams, \"recipient\"> & { recipient?: string }) => {\n    if (!signer) throw new Error(\"Signer not defined\");\n\n    const registry = createDefaultRegistry();\n    const signingClient = await createSigningStargateClient(rpcUrl, signer, {\n      registry,\n    });\n\n    const msgSign = convertToSignable(\n      prepareMessageForBroadcast(buildAminoMsg({ assetValue, from, recipient, memo, chain })),\n      chain,\n    );\n\n    const txResponse = await signingClient.signAndBroadcast(from, [msgSign], defaultFee, memo);\n\n    return txResponse.transactionHash;\n  };\n\n  return {\n    ...baseToolbox,\n    deposit: (params: DepositParam & { from: string }) => transfer(params),\n    transfer,\n    getFees,\n    buildAminoMsg,\n    convertToSignable,\n    buildTransaction,\n    buildEncodedTxBody,\n    prepareMessageForBroadcast,\n    createDefaultAminoTypes: () => createDefaultAminoTypes(chain),\n    createDefaultRegistry,\n    secp256k1HdWalletFromMnemonic: secp256k1HdWalletFromMnemonic({\n      derivationPath,\n      prefix,\n    }),\n    signMultisigTx: (wallet: Secp256k1HdWallet, tx: string) => signMultisigTx(wallet, tx, chain),\n    broadcastMultisigTx: broadcastMultisigTx({ prefix, rpcUrl }),\n    createMultisig,\n    importSignature,\n    loadAddressBalances,\n    pubkeyToAddress: __REEXPORT__pubkeyToAddress(prefix),\n    signWithPrivateKey,\n    verifySignature: verifySignature(baseToolbox.getAccount),\n  };\n};\n\nexport const ThorchainToolbox = ({ stagenet }: ToolboxParams = {}): ThorchainToolboxType => {\n  return BaseThorchainToolbox({ chain: Chain.THORChain, stagenet });\n};\n\nexport const MayaToolbox = ({ stagenet }: ToolboxParams = {}): MayaToolboxType => {\n  return BaseThorchainToolbox({ chain: Chain.Maya, stagenet });\n};\n\nexport type ThorchainWallet = Omit<ReturnType<typeof BaseThorchainToolbox>, \"signMessage\">;\nexport type ThorchainWallets = {\n  [chain in Chain.THORChain | Chain.Maya]: ThorchainWallet;\n};\n"
  ],
  "mappings": "AAAA,mBAAS,0BACT,iBAAS,aAAQ,qBACjB,wBAAS,kBAAe,mBAEjB,SAAS,CAAc,CAAC,EAAiB,CAC9C,OAAO,GAAO,OAAO,WAAW,KAAK,GAAO,UAAU,GAAO,OAAO,CAAO,EAAE,KAAK,CAAC,CAAC,EAG/E,SAAS,CAAc,CAAC,EAAiB,EAAS,OAAQ,CAC/D,OAAO,GAAS,EAAQ,GAAO,OAAO,CAAO,CAAC,EAGzC,SAAS,EAAQ,CAAC,EAAkB,CACzC,OAAO,GAAc,CAAI,EAGpB,SAAS,EAAU,CAAC,EAAsB,CAC/C,IAAK,EAAa,MAAM,wBAAwB,EAC9C,MAAM,IAAI,MAAM,8BAA8B,EAEhD,OAAO,GAAY,CAAY,ECnBjC,qBAAS,YAAY,oBAAO,aAAgB,0BCA5C,mBACE,4BACA,qBAEA,0BAEF,qBACE,WACA,cACA,eACA,aACA,2BACA,0BAKK,IAAM,EACX,iFAEW,EACX,6DAEW,GAA6B,CACxC,OAAQ,CAAC,CAAE,MAAO,QAAS,OAAQ,KAAM,CAAC,EAC1C,IAAK,QACP,EAEa,EAAW,CAAC,EAAgB,EAAc,KAAU,CAC/D,GAAI,EACF,OAAO,EAAO,YAAY,EAE5B,OAAQ,OACD,OACH,OAAO,MACJ,OACH,OAAO,UAEP,OAAO,IAIA,EAAuB,CAAC,IAAgB,CACnD,OAAO,GAAe,QAAQ,CAAE,MAAK,QAAS,EAAsB,CAAC,GAG1D,EAA8B,CACzC,EACA,EACA,EAA0D,CAAC,IACxD,CACH,MAAM,SAAkB,IAAqB,SAAW,EAAmB,cACrE,SAAiB,IAAqB,SAAW,CAAC,EAAI,EAE5D,OAAO,GAAsB,kBAAkB,CAAE,MAAK,QAAS,EAAsB,EAAG,EAAQ,CAC9F,SAAU,GAAS,WAAW,CAAQ,KACnC,CACL,CAAC,GAGU,GAA8B,CACzC,EACA,IACG,CACH,OAAO,GAAsB,QAAQ,EAAQ,CAAQ,GAG1C,EAAS,CAAC,EAAkB,IAAuB,CAC9D,OAAQ,QACD,EAAQ,OACX,OAAO,EAAO,YACX,EAAQ,OACX,OAAO,EAAO,YAEX,EAAQ,UACX,OAAO,EAAW,EAAO,kBAAoB,EAAO,eACjD,EAAQ,KACX,OAAO,EAAW,EAAO,aAAe,EAAO,aAG/C,OAAO,EAAO,SAIP,GAA4B,OACvC,OACA,UACA,QACA,eAAe,GAAU,QAC+B,CACxD,MAAM,SACG,IAAU,SAAW,MAAM,EAAW,KAAK,CAAE,iBAAkB,GAAM,OAAM,CAAC,EAAI,EACnF,EAAW,MAAM,EAAQ,WAAW,CAAI,EACxC,EAAU,EAAS,KAAK,EAAG,SAAQ,WACvC,EAAQ,IAAW,GAAa,OAAS,IAAW,EAAW,KAAK,CAAE,OAAM,CAAC,EAAE,MACjF,EAEM,EAAO,MAAM,EAAQ,QAAQ,EAEnC,IAAK,EACH,OAAO,EAAW,KAAK,CAAE,MAAO,GAAa,OAAS,EAAS,IAAI,OAAS,GAAM,MAAO,CAAC,EAG5F,OAAO,EAAQ,IAAI,EAAK,EAAa,GCxGvC,mBAAS,+BACT,qBAAS,2BAAY,0BACrB,gBAAS,0BCDT,qCAGA,IAAM,EAAU,EAAU,OACpB,EAAU,EAAU,OACpB,EAAQ,EAAU,KAIlB,EAAS,EAAU,MAAM,UAAe,EAAU,MAAM,QAAa,CAAC,GAE5E,EAAM,QAAU,IAAM,CAMpB,MAAM,EAAS,CAAC,EA85ChB,OA55CA,EAAO,OAAS,IAAM,CAmBpB,SAAS,CAAK,CAAC,EAAY,CACzB,GAAI,GACF,QAAS,EAAO,OAAO,KAAK,CAAU,EAAG,EAAI,EAAG,EAAI,EAAK,SAAU,EACjE,GAAI,EAAW,EAAK,KAAO,KAAM,KAAK,EAAK,IAAM,EAAW,EAAK,KAoNvE,OA3MA,EAAM,UAAU,MAAQ,GAQxB,EAAM,UAAU,OAAS,GAQzB,EAAM,UAAU,OAAS,GAQzB,EAAM,UAAU,MAAQ,GAUxB,EAAM,gBAAkB,CAAM,CAAC,EAAY,CACzC,OAAO,IAAI,EAAM,CAAU,GAY7B,EAAM,gBAAkB,CAAM,CAAC,EAAS,EAAQ,CAC9C,IAAK,EAAQ,EAAS,EAAQ,OAAO,EACrC,GAAI,EAAQ,OAAS,MAAQ,OAAO,eAAe,KAAK,EAAS,OAAO,EACtE,EAAO,OAA+B,EAAE,EAAE,OAAO,EAAQ,KAAK,EAChE,GAAI,EAAQ,QAAU,MAAQ,OAAO,eAAe,KAAK,EAAS,QAAQ,EACxE,EAAO,OAA+B,EAAE,EAAE,OAAO,EAAQ,MAAM,EACjE,GAAI,EAAQ,QAAU,MAAQ,OAAO,eAAe,KAAK,EAAS,QAAQ,EACxE,EAAO,OAA+B,EAAE,EAAE,OAAO,EAAQ,MAAM,EACjE,GAAI,EAAQ,OAAS,MAAQ,OAAO,eAAe,KAAK,EAAS,OAAO,EACtE,EAAO,OAA+B,EAAE,EAAE,KAAK,EAAQ,KAAK,EAC9D,OAAO,GAYT,EAAM,yBAA2B,CAAe,CAAC,EAAS,EAAQ,CAChE,OAAO,KAAK,OAAO,EAAS,CAAM,EAAE,OAAO,GAc7C,EAAM,gBAAkB,CAAM,CAAC,EAAQ,EAAQ,CAC7C,KAAM,aAAkB,GAAU,EAAS,EAAQ,OAAO,CAAM,EAChE,MAAM,EAAM,IAAW,OAAY,EAAO,IAAM,EAAO,IAAM,EAC3D,EAAU,IAAI,EAAM,OAAO,MAC7B,MAAO,EAAO,IAAM,EAAK,CACvB,MAAM,EAAM,EAAO,OAAO,EAC1B,OAAQ,IAAQ,OACT,GACH,EAAQ,MAAQ,EAAO,OAAO,EAC9B,UACG,GACH,EAAQ,OAAS,EAAO,OAAO,EAC/B,UACG,GACH,EAAQ,OAAS,EAAO,OAAO,EAC/B,UACG,GACH,EAAQ,MAAQ,EAAO,KAAK,EAC5B,cAEA,EAAO,SAAS,EAAM,CAAC,EACvB,OAGN,OAAO,GAaT,EAAM,yBAA2B,CAAe,CAAC,EAAQ,CACvD,KAAM,aAAkB,GAAU,EAAS,IAAI,EAAQ,CAAM,EAC7D,OAAO,KAAK,OAAO,EAAQ,EAAO,OAAO,CAAC,GAW5C,EAAM,gBAAkB,CAAM,CAAC,EAAS,CACtC,UAAW,IAAY,UAAY,IAAY,KAAM,MAAO,kBAC5D,GAAI,EAAQ,OAAS,MAAQ,EAAQ,eAAe,OAAO,GACzD,IAAK,EAAM,SAAS,EAAQ,KAAK,EAAG,MAAO,yBAC7C,GAAI,EAAQ,QAAU,MAAQ,EAAQ,eAAe,QAAQ,GAC3D,IAAK,EAAM,SAAS,EAAQ,MAAM,EAAG,MAAO,0BAC9C,GAAI,EAAQ,QAAU,MAAQ,EAAQ,eAAe,QAAQ,GAC3D,IAAK,EAAM,SAAS,EAAQ,MAAM,EAAG,MAAO,0BAC9C,GAAI,EAAQ,OAAS,MAAQ,EAAQ,eAAe,OAAO,GACzD,UAAW,EAAQ,QAAU,UAAW,MAAO,0BACjD,OAAO,MAWT,EAAM,oBAAsB,CAAU,CAAC,EAAQ,CAC7C,GAAI,aAAkB,EAAM,OAAO,MAAO,OAAO,EACjD,MAAM,EAAU,IAAI,EAAM,OAAO,MACjC,GAAI,EAAO,OAAS,KAAM,EAAQ,MAAQ,OAAO,EAAO,KAAK,EAC7D,GAAI,EAAO,QAAU,KAAM,EAAQ,OAAS,OAAO,EAAO,MAAM,EAChE,GAAI,EAAO,QAAU,KAAM,EAAQ,OAAS,OAAO,EAAO,MAAM,EAChE,GAAI,EAAO,OAAS,KAAM,EAAQ,MAAQ,QAAQ,EAAO,KAAK,EAC9D,OAAO,GAYT,EAAM,kBAAoB,CAAQ,CAAC,EAAS,EAAS,CACnD,IAAK,EAAS,EAAU,CAAC,EACzB,MAAM,EAAS,CAAC,EAChB,GAAI,EAAQ,SACV,EAAO,MAAQ,GACf,EAAO,OAAS,GAChB,EAAO,OAAS,GAChB,EAAO,MAAQ,GAEjB,GAAI,EAAQ,OAAS,MAAQ,EAAQ,eAAe,OAAO,EAAG,EAAO,MAAQ,EAAQ,MACrF,GAAI,EAAQ,QAAU,MAAQ,EAAQ,eAAe,QAAQ,EAC3D,EAAO,OAAS,EAAQ,OAC1B,GAAI,EAAQ,QAAU,MAAQ,EAAQ,eAAe,QAAQ,EAC3D,EAAO,OAAS,EAAQ,OAC1B,GAAI,EAAQ,OAAS,MAAQ,EAAQ,eAAe,OAAO,EAAG,EAAO,MAAQ,EAAQ,MACrF,OAAO,GAUT,EAAM,UAAU,gBAAkB,CAAM,EAAG,CACzC,OAAO,KAAK,YAAY,SAAS,KAAM,EAAU,KAAK,aAAa,GAG9D,IACN,EAEH,EAAO,MAAQ,IAAM,CAkBnB,SAAS,CAAI,CAAC,EAAY,CACxB,GAAI,GACF,QAAS,EAAO,OAAO,KAAK,CAAU,EAAG,EAAI,EAAG,EAAI,EAAK,SAAU,EACjE,GAAI,EAAW,EAAK,KAAO,KAAM,KAAK,EAAK,IAAM,EAAW,EAAK,KAgPvE,OAvOA,EAAK,UAAU,MAAQ,KAQvB,EAAK,UAAU,OAAS,GAQxB,EAAK,UAAU,SAAW,EAAM,KAAO,EAAM,KAAK,SAAS,EAAG,EAAG,EAAK,EAAI,EAU1E,EAAK,gBAAkB,CAAM,CAAC,EAAY,CACxC,OAAO,IAAI,EAAK,CAAU,GAY5B,EAAK,gBAAkB,CAAM,CAAC,EAAS,EAAQ,CAC7C,IAAK,EAAQ,EAAS,EAAQ,OAAO,EACrC,GAAI,EAAQ,OAAS,MAAQ,OAAO,eAAe,KAAK,EAAS,OAAO,EACtE,EAAM,OAAO,MAAM,OACjB,EAAQ,MACR,EAAO,OAA+B,EAAE,EAAE,KAAK,CACjD,EAAE,OAAO,EACX,GAAI,EAAQ,QAAU,MAAQ,OAAO,eAAe,KAAK,EAAS,QAAQ,EACxE,EAAO,OAA+B,EAAE,EAAE,OAAO,EAAQ,MAAM,EACjE,GAAI,EAAQ,UAAY,MAAQ,OAAO,eAAe,KAAK,EAAS,UAAU,EAC5E,EAAO,OAA+B,EAAE,EAAE,MAAM,EAAQ,QAAQ,EAClE,OAAO,GAYT,EAAK,yBAA2B,CAAe,CAAC,EAAS,EAAQ,CAC/D,OAAO,KAAK,OAAO,EAAS,CAAM,EAAE,OAAO,GAc7C,EAAK,gBAAkB,CAAM,CAAC,EAAQ,EAAQ,CAC5C,KAAM,aAAkB,GAAU,EAAS,EAAQ,OAAO,CAAM,EAChE,MAAM,EAAM,IAAW,OAAY,EAAO,IAAM,EAAO,IAAM,EAC3D,EAAU,IAAI,EAAM,OAAO,KAC7B,MAAO,EAAO,IAAM,EAAK,CACvB,MAAM,EAAM,EAAO,OAAO,EAC1B,OAAQ,IAAQ,OACT,GACH,EAAQ,MAAQ,EAAM,OAAO,MAAM,OAAO,EAAQ,EAAO,OAAO,CAAC,EACjE,UACG,GACH,EAAQ,OAAS,EAAO,OAAO,EAC/B,UACG,GACH,EAAQ,SAAW,EAAO,MAAM,EAChC,cAEA,EAAO,SAAS,EAAM,CAAC,EACvB,OAGN,OAAO,GAaT,EAAK,yBAA2B,CAAe,CAAC,EAAQ,CACtD,KAAM,aAAkB,GAAU,EAAS,IAAI,EAAQ,CAAM,EAC7D,OAAO,KAAK,OAAO,EAAQ,EAAO,OAAO,CAAC,GAW5C,EAAK,gBAAkB,CAAM,CAAC,EAAS,CACrC,UAAW,IAAY,UAAY,IAAY,KAAM,MAAO,kBAC5D,GAAI,EAAQ,OAAS,MAAQ,EAAQ,eAAe,OAAO,EAAG,CAC5D,MAAM,EAAQ,EAAM,OAAO,MAAM,OAAO,EAAQ,KAAK,EACrD,GAAI,EAAO,MAAO,SAAW,EAE/B,GAAI,EAAQ,QAAU,MAAQ,EAAQ,eAAe,QAAQ,GAC3D,IAAK,EAAM,SAAS,EAAQ,MAAM,EAAG,MAAO,0BAC9C,GAAI,EAAQ,UAAY,MAAQ,EAAQ,eAAe,UAAU,GAC/D,IACG,EAAM,UAAU,EAAQ,QAAQ,KAE/B,EAAQ,UACR,EAAM,UAAU,EAAQ,SAAS,GAAG,GACpC,EAAM,UAAU,EAAQ,SAAS,IAAI,GAGvC,MAAO,kCACX,OAAO,MAWT,EAAK,oBAAsB,CAAU,CAAC,EAAQ,CAC5C,GAAI,aAAkB,EAAM,OAAO,KAAM,OAAO,EAChD,MAAM,EAAU,IAAI,EAAM,OAAO,KACjC,GAAI,EAAO,OAAS,KAAM,CACxB,UAAW,EAAO,QAAU,SAC1B,MAAM,UAAU,qCAAqC,EACvD,EAAQ,MAAQ,EAAM,OAAO,MAAM,WAAW,EAAO,KAAK,EAE5D,GAAI,EAAO,QAAU,KAAM,EAAQ,OAAS,OAAO,EAAO,MAAM,EAChE,GAAI,EAAO,UAAY,MACrB,GAAI,EAAM,KAAM,CAAC,EAAQ,SAAW,EAAM,KAAK,UAAU,EAAO,QAAQ,GAAG,SAAW,kBACtE,EAAO,WAAa,SAClC,EAAQ,SAAW,SAAS,EAAO,SAAU,EAAE,iBACjC,EAAO,WAAa,SAAU,EAAQ,SAAW,EAAO,wBACxD,EAAO,WAAa,SAClC,EAAQ,SAAW,IAAI,EAAM,SAC3B,EAAO,SAAS,MAAQ,EACxB,EAAO,SAAS,OAAS,CAC3B,EAAE,SAAS,EACf,OAAO,GAYT,EAAK,kBAAoB,CAAQ,CAAC,EAAS,EAAS,CAClD,IAAK,EAAS,EAAU,CAAC,EACzB,MAAM,EAAS,CAAC,EAChB,GAAI,EAAQ,SAGV,GAFA,EAAO,MAAQ,KACf,EAAO,OAAS,GACZ,EAAM,KAAM,CACd,MAAM,EAAO,IAAI,EAAM,KAAK,EAAG,EAAG,EAAK,EACvC,EAAO,SACL,EAAQ,QAAU,OACd,EAAK,SAAS,EACd,EAAQ,QAAU,OAChB,EAAK,SAAS,EACd,MACH,GAAO,SAAW,EAAQ,QAAU,OAAS,IAAM,EAE5D,GAAI,EAAQ,OAAS,MAAQ,EAAQ,eAAe,OAAO,EACzD,EAAO,MAAQ,EAAM,OAAO,MAAM,SAAS,EAAQ,MAAO,CAAO,EACnE,GAAI,EAAQ,QAAU,MAAQ,EAAQ,eAAe,QAAQ,EAC3D,EAAO,OAAS,EAAQ,OAC1B,GAAI,EAAQ,UAAY,MAAQ,EAAQ,eAAe,UAAU,EAC/D,UAAW,EAAQ,WAAa,SAC9B,EAAO,SAAW,EAAQ,QAAU,OAAS,OAAO,EAAQ,QAAQ,EAAI,EAAQ,aAEhF,GAAO,SACL,EAAQ,QAAU,OACd,EAAM,KAAK,UAAU,SAAS,KAAK,EAAQ,QAAQ,EACnD,EAAQ,QAAU,OAChB,IAAI,EAAM,SACR,EAAQ,SAAS,MAAQ,EACzB,EAAQ,SAAS,OAAS,CAC5B,EAAE,SAAS,EACX,EAAQ,SACpB,OAAO,GAUT,EAAK,UAAU,gBAAkB,CAAM,EAAG,CACxC,OAAO,KAAK,YAAY,SAAS,KAAM,EAAU,KAAK,aAAa,GAG9D,IACN,EAEH,EAAO,WAAa,IAAM,CAiBxB,SAAS,CAAS,CAAC,EAAY,CAC7B,GAAI,GACF,QAAS,EAAO,OAAO,KAAK,CAAU,EAAG,EAAI,EAAG,EAAI,EAAK,SAAU,EACjE,GAAI,EAAW,EAAK,KAAO,KAAM,KAAK,EAAK,IAAM,EAAW,EAAK,KAgLvE,OAvKA,EAAU,UAAU,UAAY,GAQhC,EAAU,UAAU,QAAU,GAU9B,EAAU,gBAAkB,CAAM,CAAC,EAAY,CAC7C,OAAO,IAAI,EAAU,CAAU,GAYjC,EAAU,gBAAkB,CAAM,CAAC,EAAS,EAAQ,CAClD,IAAK,EAAQ,EAAS,EAAQ,OAAO,EACrC,GAAI,EAAQ,WAAa,MAAQ,OAAO,eAAe,KAAK,EAAS,WAAW,EAC9E,EAAO,OAA+B,EAAE,EAAE,OAAO,EAAQ,SAAS,EACpE,GAAI,EAAQ,SAAW,MAAQ,OAAO,eAAe,KAAK,EAAS,SAAS,EAC1E,EAAO,OAA+B,EAAE,EAAE,OAAO,EAAQ,OAAO,EAClE,OAAO,GAYT,EAAU,yBAA2B,CAAe,CAAC,EAAS,EAAQ,CACpE,OAAO,KAAK,OAAO,EAAS,CAAM,EAAE,OAAO,GAc7C,EAAU,gBAAkB,CAAM,CAAC,EAAQ,EAAQ,CACjD,KAAM,aAAkB,GAAU,EAAS,EAAQ,OAAO,CAAM,EAChE,MAAM,EAAM,IAAW,OAAY,EAAO,IAAM,EAAO,IAAM,EAC3D,EAAU,IAAI,EAAM,OAAO,UAC7B,MAAO,EAAO,IAAM,EAAK,CACvB,MAAM,EAAM,EAAO,OAAO,EAC1B,OAAQ,IAAQ,OACT,GACH,EAAQ,UAAY,EAAO,OAAO,EAClC,UACG,GACH,EAAQ,QAAU,EAAO,OAAO,EAChC,cAEA,EAAO,SAAS,EAAM,CAAC,EACvB,OAGN,OAAO,GAaT,EAAU,yBAA2B,CAAe,CAAC,EAAQ,CAC3D,KAAM,aAAkB,GAAU,EAAS,IAAI,EAAQ,CAAM,EAC7D,OAAO,KAAK,OAAO,EAAQ,EAAO,OAAO,CAAC,GAW5C,EAAU,gBAAkB,CAAM,CAAC,EAAS,CAC1C,UAAW,IAAY,UAAY,IAAY,KAAM,MAAO,kBAC5D,GAAI,EAAQ,WAAa,MAAQ,EAAQ,eAAe,WAAW,GACjE,IAAK,EAAM,SAAS,EAAQ,SAAS,EAAG,MAAO,6BACjD,GAAI,EAAQ,SAAW,MAAQ,EAAQ,eAAe,SAAS,GAC7D,IAAK,EAAM,SAAS,EAAQ,OAAO,EAAG,MAAO,2BAC/C,OAAO,MAWT,EAAU,oBAAsB,CAAU,CAAC,EAAQ,CACjD,GAAI,aAAkB,EAAM,OAAO,UAAW,OAAO,EACrD,MAAM,EAAU,IAAI,EAAM,OAAO,UACjC,GAAI,EAAO,WAAa,KAAM,EAAQ,UAAY,OAAO,EAAO,SAAS,EACzE,GAAI,EAAO,SAAW,KAAM,EAAQ,QAAU,OAAO,EAAO,OAAO,EACnE,OAAO,GAYT,EAAU,kBAAoB,CAAQ,CAAC,EAAS,EAAS,CACvD,IAAK,EAAS,EAAU,CAAC,EACzB,MAAM,EAAS,CAAC,EAChB,GAAI,EAAQ,SACV,EAAO,UAAY,GACnB,EAAO,QAAU,GAEnB,GAAI,EAAQ,WAAa,MAAQ,EAAQ,eAAe,WAAW,EACjE,EAAO,UAAY,EAAQ,UAC7B,GAAI,EAAQ,SAAW,MAAQ,EAAQ,eAAe,SAAS,EAC7D,EAAO,QAAU,EAAQ,QAC3B,OAAO,GAUT,EAAU,UAAU,gBAAkB,CAAM,EAAG,CAC7C,OAAO,KAAK,YAAY,SAAS,KAAM,EAAU,KAAK,aAAa,GAG9D,IACN,EAEH,EAAO,IAAM,IAAM,CAsBjB,SAAS,CAAE,CAAC,EAAY,CAGtB,GAFA,KAAK,MAAQ,CAAC,EACd,KAAK,IAAM,CAAC,EACR,GACF,QAAS,EAAO,OAAO,KAAK,CAAU,EAAG,EAAI,EAAG,EAAI,EAAK,SAAU,EACjE,GAAI,EAAW,EAAK,KAAO,KAAM,KAAK,EAAK,IAAM,EAAW,EAAK,KAuTvE,OA9SA,EAAG,UAAU,GAAK,GAQlB,EAAG,UAAU,MAAQ,GAQrB,EAAG,UAAU,YAAc,GAQ3B,EAAG,UAAU,UAAY,GAQzB,EAAG,UAAU,MAAQ,EAAM,WAQ3B,EAAG,UAAU,IAAM,EAAM,WAQzB,EAAG,UAAU,KAAO,GAUpB,EAAG,gBAAkB,CAAM,CAAC,EAAY,CACtC,OAAO,IAAI,EAAG,CAAU,GAY1B,EAAG,gBAAkB,CAAM,CAAC,EAAS,EAAQ,CAC3C,IAAK,EAAQ,EAAS,EAAQ,OAAO,EACrC,GAAI,EAAQ,IAAM,MAAQ,OAAO,eAAe,KAAK,EAAS,IAAI,EAChE,EAAO,OAA+B,EAAE,EAAE,OAAO,EAAQ,EAAE,EAC7D,GAAI,EAAQ,OAAS,MAAQ,OAAO,eAAe,KAAK,EAAS,OAAO,EACtE,EAAO,OAA+B,EAAE,EAAE,OAAO,EAAQ,KAAK,EAChE,GAAI,EAAQ,aAAe,MAAQ,OAAO,eAAe,KAAK,EAAS,aAAa,EAClF,EAAO,OAA+B,EAAE,EAAE,OAAO,EAAQ,WAAW,EACtE,GAAI,EAAQ,WAAa,MAAQ,OAAO,eAAe,KAAK,EAAS,WAAW,EAC9E,EAAO,OAA+B,EAAE,EAAE,OAAO,EAAQ,SAAS,EACpE,GAAI,EAAQ,OAAO,OACjB,QAAS,EAAI,EAAG,EAAI,EAAQ,MAAM,SAAU,EAC1C,EAAM,OAAO,KAAK,OAChB,EAAQ,MAAM,GACd,EAAO,OAA+B,EAAE,EAAE,KAAK,CACjD,EAAE,OAAO,EACb,GAAI,EAAQ,KAAK,OACf,QAAS,EAAI,EAAG,EAAI,EAAQ,IAAI,SAAU,EACxC,EAAM,OAAO,KAAK,OAChB,EAAQ,IAAI,GACZ,EAAO,OAA+B,EAAE,EAAE,KAAK,CACjD,EAAE,OAAO,EACb,GAAI,EAAQ,MAAQ,MAAQ,OAAO,eAAe,KAAK,EAAS,MAAM,EACpE,EAAO,OAA+B,EAAE,EAAE,OAAO,EAAQ,IAAI,EAC/D,OAAO,GAYT,EAAG,yBAA2B,CAAe,CAAC,EAAS,EAAQ,CAC7D,OAAO,KAAK,OAAO,EAAS,CAAM,EAAE,OAAO,GAc7C,EAAG,gBAAkB,CAAM,CAAC,EAAQ,EAAQ,CAC1C,KAAM,aAAkB,GAAU,EAAS,EAAQ,OAAO,CAAM,EAChE,MAAM,EAAM,IAAW,OAAY,EAAO,IAAM,EAAO,IAAM,EAC3D,EAAU,IAAI,EAAM,OAAO,GAC7B,MAAO,EAAO,IAAM,EAAK,CACvB,MAAM,EAAM,EAAO,OAAO,EAC1B,OAAQ,IAAQ,OACT,GACH,EAAQ,GAAK,EAAO,OAAO,EAC3B,UACG,GACH,EAAQ,MAAQ,EAAO,OAAO,EAC9B,UACG,GACH,EAAQ,YAAc,EAAO,OAAO,EACpC,UACG,GACH,EAAQ,UAAY,EAAO,OAAO,EAClC,UACG,GACH,IAAK,EAAQ,OAAO,OAAQ,EAAQ,MAAQ,CAAC,EAC7C,EAAQ,MAAM,KAAK,EAAM,OAAO,KAAK,OAAO,EAAQ,EAAO,OAAO,CAAC,CAAC,EACpE,UACG,GACH,IAAK,EAAQ,KAAK,OAAQ,EAAQ,IAAM,CAAC,EACzC,EAAQ,IAAI,KAAK,EAAM,OAAO,KAAK,OAAO,EAAQ,EAAO,OAAO,CAAC,CAAC,EAClE,UACG,GACH,EAAQ,KAAO,EAAO,OAAO,EAC7B,cAEA,EAAO,SAAS,EAAM,CAAC,EACvB,OAGN,OAAO,GAaT,EAAG,yBAA2B,CAAe,CAAC,EAAQ,CACpD,KAAM,aAAkB,GAAU,EAAS,IAAI,EAAQ,CAAM,EAC7D,OAAO,KAAK,OAAO,EAAQ,EAAO,OAAO,CAAC,GAW5C,EAAG,gBAAkB,CAAM,CAAC,EAAS,CACnC,UAAW,IAAY,UAAY,IAAY,KAAM,MAAO,kBAC5D,GAAI,EAAQ,IAAM,MAAQ,EAAQ,eAAe,IAAI,GACnD,IAAK,EAAM,SAAS,EAAQ,EAAE,EAAG,MAAO,sBAC1C,GAAI,EAAQ,OAAS,MAAQ,EAAQ,eAAe,OAAO,GACzD,IAAK,EAAM,SAAS,EAAQ,KAAK,EAAG,MAAO,yBAC7C,GAAI,EAAQ,aAAe,MAAQ,EAAQ,eAAe,aAAa,GACrE,IAAK,EAAM,SAAS,EAAQ,WAAW,EAAG,MAAO,+BACnD,GAAI,EAAQ,WAAa,MAAQ,EAAQ,eAAe,WAAW,GACjE,IAAK,EAAM,SAAS,EAAQ,SAAS,EAAG,MAAO,6BACjD,GAAI,EAAQ,OAAS,MAAQ,EAAQ,eAAe,OAAO,EAAG,CAC5D,IAAK,MAAM,QAAQ,EAAQ,KAAK,EAAG,MAAO,wBAC1C,QAAS,EAAI,EAAG,EAAI,EAAQ,MAAM,SAAU,EAAG,CAC7C,MAAM,EAAQ,EAAM,OAAO,KAAK,OAAO,EAAQ,MAAM,EAAE,EACvD,GAAI,EAAO,MAAO,SAAW,GAGjC,GAAI,EAAQ,KAAO,MAAQ,EAAQ,eAAe,KAAK,EAAG,CACxD,IAAK,MAAM,QAAQ,EAAQ,GAAG,EAAG,MAAO,sBACxC,QAAS,EAAI,EAAG,EAAI,EAAQ,IAAI,SAAU,EAAG,CAC3C,MAAM,EAAQ,EAAM,OAAO,KAAK,OAAO,EAAQ,IAAI,EAAE,EACrD,GAAI,EAAO,MAAO,OAAS,GAG/B,GAAI,EAAQ,MAAQ,MAAQ,EAAQ,eAAe,MAAM,GACvD,IAAK,EAAM,SAAS,EAAQ,IAAI,EAAG,MAAO,wBAC5C,OAAO,MAWT,EAAG,oBAAsB,CAAU,CAAC,EAAQ,CAC1C,GAAI,aAAkB,EAAM,OAAO,GAAI,OAAO,EAC9C,MAAM,EAAU,IAAI,EAAM,OAAO,GACjC,GAAI,EAAO,IAAM,KAAM,EAAQ,GAAK,OAAO,EAAO,EAAE,EACpD,GAAI,EAAO,OAAS,KAAM,EAAQ,MAAQ,OAAO,EAAO,KAAK,EAC7D,GAAI,EAAO,aAAe,KAAM,EAAQ,YAAc,OAAO,EAAO,WAAW,EAC/E,GAAI,EAAO,WAAa,KAAM,EAAQ,UAAY,OAAO,EAAO,SAAS,EACzE,GAAI,EAAO,MAAO,CAChB,IAAK,MAAM,QAAQ,EAAO,KAAK,EAAG,MAAM,UAAU,kCAAkC,EACpF,EAAQ,MAAQ,CAAC,EACjB,QAAS,EAAI,EAAG,EAAI,EAAO,MAAM,SAAU,EAAG,CAC5C,UAAW,EAAO,MAAM,KAAO,SAC7B,MAAM,UAAU,mCAAmC,EACrD,EAAQ,MAAM,GAAK,EAAM,OAAO,KAAK,WAAW,EAAO,MAAM,EAAE,GAGnE,GAAI,EAAO,IAAK,CACd,IAAK,MAAM,QAAQ,EAAO,GAAG,EAAG,MAAM,UAAU,gCAAgC,EAChF,EAAQ,IAAM,CAAC,EACf,QAAS,EAAI,EAAG,EAAI,EAAO,IAAI,SAAU,EAAG,CAC1C,UAAW,EAAO,IAAI,KAAO,SAAU,MAAM,UAAU,iCAAiC,EACxF,EAAQ,IAAI,GAAK,EAAM,OAAO,KAAK,WAAW,EAAO,IAAI,EAAE,GAG/D,GAAI,EAAO,MAAQ,KAAM,EAAQ,KAAO,OAAO,EAAO,IAAI,EAC1D,OAAO,GAYT,EAAG,kBAAoB,CAAQ,CAAC,EAAS,EAAS,CAChD,IAAK,EAAS,EAAU,CAAC,EACzB,MAAM,EAAS,CAAC,EAChB,GAAI,EAAQ,QAAU,EAAQ,SAC5B,EAAO,MAAQ,CAAC,EAChB,EAAO,IAAM,CAAC,EAEhB,GAAI,EAAQ,SACV,EAAO,GAAK,GACZ,EAAO,MAAQ,GACf,EAAO,YAAc,GACrB,EAAO,UAAY,GACnB,EAAO,KAAO,GAEhB,GAAI,EAAQ,IAAM,MAAQ,EAAQ,eAAe,IAAI,EAAG,EAAO,GAAK,EAAQ,GAC5E,GAAI,EAAQ,OAAS,MAAQ,EAAQ,eAAe,OAAO,EAAG,EAAO,MAAQ,EAAQ,MACrF,GAAI,EAAQ,aAAe,MAAQ,EAAQ,eAAe,aAAa,EACrE,EAAO,YAAc,EAAQ,YAC/B,GAAI,EAAQ,WAAa,MAAQ,EAAQ,eAAe,WAAW,EACjE,EAAO,UAAY,EAAQ,UAC7B,GAAI,EAAQ,OAAO,OAAQ,CACzB,EAAO,MAAQ,CAAC,EAChB,QAAS,EAAI,EAAG,EAAI,EAAQ,MAAM,SAAU,EAC1C,EAAO,MAAM,GAAK,EAAM,OAAO,KAAK,SAAS,EAAQ,MAAM,GAAI,CAAO,EAE1E,GAAI,EAAQ,KAAK,OAAQ,CACvB,EAAO,IAAM,CAAC,EACd,QAAS,EAAI,EAAG,EAAI,EAAQ,IAAI,SAAU,EACxC,EAAO,IAAI,GAAK,EAAM,OAAO,KAAK,SAAS,EAAQ,IAAI,GAAI,CAAO,EAEtE,GAAI,EAAQ,MAAQ,MAAQ,EAAQ,eAAe,MAAM,EAAG,EAAO,KAAO,EAAQ,KAClF,OAAO,GAUT,EAAG,UAAU,gBAAkB,CAAM,EAAG,CACtC,OAAO,KAAK,YAAY,SAAS,KAAM,EAAU,KAAK,aAAa,GAG9D,IACN,EAEH,EAAO,KAAO,IAAM,CAiBlB,SAAS,CAAG,CAAC,EAAY,CAEvB,GADA,KAAK,MAAQ,CAAC,EACV,GACF,QAAS,EAAO,OAAO,KAAK,CAAU,EAAG,EAAI,EAAG,EAAI,EAAK,SAAU,EACjE,GAAI,EAAW,EAAK,KAAO,KAAM,KAAK,EAAK,IAAM,EAAW,EAAK,KAmMvE,OA1LA,EAAI,UAAU,MAAQ,EAAM,WAQ5B,EAAI,UAAU,WAAa,GAU3B,EAAI,gBAAkB,CAAM,CAAC,EAAY,CACvC,OAAO,IAAI,EAAI,CAAU,GAY3B,EAAI,gBAAkB,CAAM,CAAC,EAAS,EAAQ,CAC5C,IAAK,EAAQ,EAAS,EAAQ,OAAO,EACrC,GAAI,EAAQ,OAAO,OACjB,QAAS,EAAI,EAAG,EAAI,EAAQ,MAAM,SAAU,EAC1C,EAAM,OAAO,KAAK,OAChB,EAAQ,MAAM,GACd,EAAO,OAA+B,EAAE,EAAE,KAAK,CACjD,EAAE,OAAO,EACb,GAAI,EAAQ,YAAc,MAAQ,OAAO,eAAe,KAAK,EAAS,YAAY,EAChF,EAAO,OAA+B,EAAE,EAAE,OAAO,EAAQ,UAAU,EACrE,OAAO,GAYT,EAAI,yBAA2B,CAAe,CAAC,EAAS,EAAQ,CAC9D,OAAO,KAAK,OAAO,EAAS,CAAM,EAAE,OAAO,GAc7C,EAAI,gBAAkB,CAAM,CAAC,EAAQ,EAAQ,CAC3C,KAAM,aAAkB,GAAU,EAAS,EAAQ,OAAO,CAAM,EAChE,MAAM,EAAM,IAAW,OAAY,EAAO,IAAM,EAAO,IAAM,EAC3D,EAAU,IAAI,EAAM,OAAO,IAC7B,MAAO,EAAO,IAAM,EAAK,CACvB,MAAM,EAAM,EAAO,OAAO,EAC1B,OAAQ,IAAQ,OACT,GACH,IAAK,EAAQ,OAAO,OAAQ,EAAQ,MAAQ,CAAC,EAC7C,EAAQ,MAAM,KAAK,EAAM,OAAO,KAAK,OAAO,EAAQ,EAAO,OAAO,CAAC,CAAC,EACpE,UACG,GACH,EAAQ,WAAa,EAAO,OAAO,EACnC,cAEA,EAAO,SAAS,EAAM,CAAC,EACvB,OAGN,OAAO,GAaT,EAAI,yBAA2B,CAAe,CAAC,EAAQ,CACrD,KAAM,aAAkB,GAAU,EAAS,IAAI,EAAQ,CAAM,EAC7D,OAAO,KAAK,OAAO,EAAQ,EAAO,OAAO,CAAC,GAW5C,EAAI,gBAAkB,CAAM,CAAC,EAAS,CACpC,UAAW,IAAY,UAAY,IAAY,KAAM,MAAO,kBAC5D,GAAI,EAAQ,OAAS,MAAQ,EAAQ,eAAe,OAAO,EAAG,CAC5D,IAAK,MAAM,QAAQ,EAAQ,KAAK,EAAG,MAAO,wBAC1C,QAAS,EAAI,EAAG,EAAI,EAAQ,MAAM,SAAU,EAAG,CAC7C,MAAM,EAAQ,EAAM,OAAO,KAAK,OAAO,EAAQ,MAAM,EAAE,EACvD,GAAI,EAAO,MAAO,SAAW,GAGjC,GAAI,EAAQ,YAAc,MAAQ,EAAQ,eAAe,YAAY,GACnE,IAAK,EAAM,SAAS,EAAQ,UAAU,EAAG,MAAO,8BAClD,OAAO,MAWT,EAAI,oBAAsB,CAAU,CAAC,EAAQ,CAC3C,GAAI,aAAkB,EAAM,OAAO,IAAK,OAAO,EAC/C,MAAM,EAAU,IAAI,EAAM,OAAO,IACjC,GAAI,EAAO,MAAO,CAChB,IAAK,MAAM,QAAQ,EAAO,KAAK,EAAG,MAAM,UAAU,mCAAmC,EACrF,EAAQ,MAAQ,CAAC,EACjB,QAAS,EAAI,EAAG,EAAI,EAAO,MAAM,SAAU,EAAG,CAC5C,UAAW,EAAO,MAAM,KAAO,SAC7B,MAAM,UAAU,oCAAoC,EACtD,EAAQ,MAAM,GAAK,EAAM,OAAO,KAAK,WAAW,EAAO,MAAM,EAAE,GAGnE,GAAI,EAAO,YAAc,KAAM,EAAQ,WAAa,OAAO,EAAO,UAAU,EAC5E,OAAO,GAYT,EAAI,kBAAoB,CAAQ,CAAC,EAAS,EAAS,CACjD,IAAK,EAAS,EAAU,CAAC,EACzB,MAAM,EAAS,CAAC,EAChB,GAAI,EAAQ,QAAU,EAAQ,SAAU,EAAO,MAAQ,CAAC,EACxD,GAAI,EAAQ,SAAU,EAAO,WAAa,GAC1C,GAAI,EAAQ,OAAO,OAAQ,CACzB,EAAO,MAAQ,CAAC,EAChB,QAAS,EAAI,EAAG,EAAI,EAAQ,MAAM,SAAU,EAC1C,EAAO,MAAM,GAAK,EAAM,OAAO,KAAK,SAAS,EAAQ,MAAM,GAAI,CAAO,EAE1E,GAAI,EAAQ,YAAc,MAAQ,EAAQ,eAAe,YAAY,EACnE,EAAO,WAAa,EAAQ,WAC9B,OAAO,GAUT,EAAI,UAAU,gBAAkB,CAAM,EAAG,CACvC,OAAO,KAAK,YAAY,SAAS,KAAM,EAAU,KAAK,aAAa,GAG9D,IACN,EAEH,EAAO,WAAa,IAAM,CAgBxB,SAAS,CAAS,CAAC,EAAY,CAC7B,GAAI,GACF,QAAS,EAAO,OAAO,KAAK,CAAU,EAAG,EAAI,EAAG,EAAI,EAAK,SAAU,EACjE,GAAI,EAAW,EAAK,KAAO,KAAM,KAAK,EAAK,IAAM,EAAW,EAAK,KA0JvE,OAjJA,EAAU,UAAU,MAAQ,GAU5B,EAAU,gBAAkB,CAAM,CAAC,EAAY,CAC7C,OAAO,IAAI,EAAU,CAAU,GAYjC,EAAU,gBAAkB,CAAM,CAAC,EAAS,EAAQ,CAClD,IAAK,EAAQ,EAAS,EAAQ,OAAO,EACrC,GAAI,EAAQ,OAAS,MAAQ,OAAO,eAAe,KAAK,EAAS,OAAO,EACtE,EAAO,OAA+B,EAAE,EAAE,OAAO,EAAQ,KAAK,EAChE,OAAO,GAYT,EAAU,yBAA2B,CAAe,CAAC,EAAS,EAAQ,CACpE,OAAO,KAAK,OAAO,EAAS,CAAM,EAAE,OAAO,GAc7C,EAAU,gBAAkB,CAAM,CAAC,EAAQ,EAAQ,CACjD,KAAM,aAAkB,GAAU,EAAS,EAAQ,OAAO,CAAM,EAChE,MAAM,EAAM,IAAW,OAAY,EAAO,IAAM,EAAO,IAAM,EAC3D,EAAU,IAAI,EAAM,OAAO,UAC7B,MAAO,EAAO,IAAM,EAAK,CACvB,MAAM,EAAM,EAAO,OAAO,EAC1B,OAAQ,IAAQ,OACT,GACH,EAAQ,MAAQ,EAAO,OAAO,EAC9B,cAEA,EAAO,SAAS,EAAM,CAAC,EACvB,OAGN,OAAO,GAaT,EAAU,yBAA2B,CAAe,CAAC,EAAQ,CAC3D,KAAM,aAAkB,GAAU,EAAS,IAAI,EAAQ,CAAM,EAC7D,OAAO,KAAK,OAAO,EAAQ,EAAO,OAAO,CAAC,GAW5C,EAAU,gBAAkB,CAAM,CAAC,EAAS,CAC1C,UAAW,IAAY,UAAY,IAAY,KAAM,MAAO,kBAC5D,GAAI,EAAQ,OAAS,MAAQ,EAAQ,eAAe,OAAO,GACzD,IAAK,EAAM,SAAS,EAAQ,KAAK,EAAG,MAAO,yBAC7C,OAAO,MAWT,EAAU,oBAAsB,CAAU,CAAC,EAAQ,CACjD,GAAI,aAAkB,EAAM,OAAO,UAAW,OAAO,EACrD,MAAM,EAAU,IAAI,EAAM,OAAO,UACjC,GAAI,EAAO,OAAS,KAAM,EAAQ,MAAQ,OAAO,EAAO,KAAK,EAC7D,OAAO,GAYT,EAAU,kBAAoB,CAAQ,CAAC,EAAS,EAAS,CACvD,IAAK,EAAS,EAAU,CAAC,EACzB,MAAM,EAAS,CAAC,EAChB,GAAI,EAAQ,SAAU,EAAO,MAAQ,GACrC,GAAI,EAAQ,OAAS,MAAQ,EAAQ,eAAe,OAAO,EAAG,EAAO,MAAQ,EAAQ,MACrF,OAAO,GAUT,EAAU,UAAU,gBAAkB,CAAM,EAAG,CAC7C,OAAO,KAAK,YAAY,SAAS,KAAM,EAAU,KAAK,aAAa,GAG9D,IACN,EAEI,IACN,EAEH,EAAM,OAAS,IAAM,CAMnB,MAAM,EAAQ,CAAC,EAsiBf,OApiBA,EAAM,YAAc,IAAM,CAkBxB,SAAS,CAAU,CAAC,EAAY,CAE9B,GADA,KAAK,MAAQ,CAAC,EACV,GACF,QAAS,EAAO,OAAO,KAAK,CAAU,EAAG,EAAI,EAAG,EAAI,EAAK,SAAU,EACjE,GAAI,EAAW,EAAK,KAAO,KAAM,KAAK,EAAK,IAAM,EAAW,EAAK,KA8OvE,OArOA,EAAW,UAAU,MAAQ,EAAM,WAQnC,EAAW,UAAU,KAAO,GAQ5B,EAAW,UAAU,OAAS,EAAM,UAAU,CAAC,CAAC,EAUhD,EAAW,gBAAkB,CAAM,CAAC,EAAY,CAC9C,OAAO,IAAI,EAAW,CAAU,GAYlC,EAAW,gBAAkB,CAAM,CAAC,EAAS,EAAQ,CACnD,IAAK,EAAQ,EAAS,EAAQ,OAAO,EACrC,GAAI,EAAQ,OAAO,OACjB,QAAS,EAAI,EAAG,EAAI,EAAQ,MAAM,SAAU,EAC1C,EAAM,OAAO,KAAK,OAChB,EAAQ,MAAM,GACd,EAAO,OAA+B,EAAE,EAAE,KAAK,CACjD,EAAE,OAAO,EACb,GAAI,EAAQ,MAAQ,MAAQ,OAAO,eAAe,KAAK,EAAS,MAAM,EACpE,EAAO,OAA+B,EAAE,EAAE,OAAO,EAAQ,IAAI,EAC/D,GAAI,EAAQ,QAAU,MAAQ,OAAO,eAAe,KAAK,EAAS,QAAQ,EACxE,EAAO,OAA+B,EAAE,EAAE,MAAM,EAAQ,MAAM,EAChE,OAAO,GAYT,EAAW,yBAA2B,CAAe,CAAC,EAAS,EAAQ,CACrE,OAAO,KAAK,OAAO,EAAS,CAAM,EAAE,OAAO,GAc7C,EAAW,gBAAkB,CAAM,CAAC,EAAQ,EAAQ,CAClD,KAAM,aAAkB,GAAU,EAAS,EAAQ,OAAO,CAAM,EAChE,MAAM,EAAM,IAAW,OAAY,EAAO,IAAM,EAAO,IAAM,EAC3D,EAAU,IAAI,EAAM,MAAM,WAC5B,MAAO,EAAO,IAAM,EAAK,CACvB,MAAM,EAAM,EAAO,OAAO,EAC1B,OAAQ,IAAQ,OACT,GACH,IAAK,EAAQ,OAAO,OAAQ,EAAQ,MAAQ,CAAC,EAC7C,EAAQ,MAAM,KAAK,EAAM,OAAO,KAAK,OAAO,EAAQ,EAAO,OAAO,CAAC,CAAC,EACpE,UACG,GACH,EAAQ,KAAO,EAAO,OAAO,EAC7B,UACG,GACH,EAAQ,OAAS,EAAO,MAAM,EAC9B,cAEA,EAAO,SAAS,EAAM,CAAC,EACvB,OAGN,OAAO,GAaT,EAAW,yBAA2B,CAAe,CAAC,EAAQ,CAC5D,KAAM,aAAkB,GAAU,EAAS,IAAI,EAAQ,CAAM,EAC7D,OAAO,KAAK,OAAO,EAAQ,EAAO,OAAO,CAAC,GAW5C,EAAW,gBAAkB,CAAM,CAAC,EAAS,CAC3C,UAAW,IAAY,UAAY,IAAY,KAAM,MAAO,kBAC5D,GAAI,EAAQ,OAAS,MAAQ,EAAQ,eAAe,OAAO,EAAG,CAC5D,IAAK,MAAM,QAAQ,EAAQ,KAAK,EAAG,MAAO,wBAC1C,QAAS,EAAI,EAAG,EAAI,EAAQ,MAAM,SAAU,EAAG,CAC7C,MAAM,EAAQ,EAAM,OAAO,KAAK,OAAO,EAAQ,MAAM,EAAE,EACvD,GAAI,EAAO,MAAO,SAAW,GAGjC,GAAI,EAAQ,MAAQ,MAAQ,EAAQ,eAAe,MAAM,GACvD,IAAK,EAAM,SAAS,EAAQ,IAAI,EAAG,MAAO,wBAC5C,GAAI,EAAQ,QAAU,MAAQ,EAAQ,eAAe,QAAQ,GAC3D,KAEK,EAAQ,eAAiB,EAAQ,OAAO,SAAW,UACpD,EAAM,SAAS,EAAQ,MAAM,GAG/B,MAAO,0BACX,OAAO,MAWT,EAAW,oBAAsB,CAAU,CAAC,EAAQ,CAClD,GAAI,aAAkB,EAAM,MAAM,WAAY,OAAO,EACrD,MAAM,EAAU,IAAI,EAAM,MAAM,WAChC,GAAI,EAAO,MAAO,CAChB,IAAK,MAAM,QAAQ,EAAO,KAAK,EAC7B,MAAM,UAAU,yCAAyC,EAC3D,EAAQ,MAAQ,CAAC,EACjB,QAAS,EAAI,EAAG,EAAI,EAAO,MAAM,SAAU,EAAG,CAC5C,UAAW,EAAO,MAAM,KAAO,SAC7B,MAAM,UAAU,0CAA0C,EAC5D,EAAQ,MAAM,GAAK,EAAM,OAAO,KAAK,WAAW,EAAO,MAAM,EAAE,GAGnE,GAAI,EAAO,MAAQ,KAAM,EAAQ,KAAO,OAAO,EAAO,IAAI,EAC1D,GAAI,EAAO,QAAU,MACnB,UAAW,EAAO,SAAW,SAC3B,EAAM,OAAO,OACX,EAAO,OACN,EAAQ,OAAS,EAAM,UAAU,EAAM,OAAO,OAAO,EAAO,MAAM,CAAC,EACpE,CACF,UACO,EAAO,OAAO,OAAQ,EAAQ,OAAS,EAAO,OACzD,OAAO,GAYT,EAAW,kBAAoB,CAAQ,CAAC,EAAS,EAAS,CACxD,IAAK,EAAS,EAAU,CAAC,EACzB,MAAM,EAAS,CAAC,EAChB,GAAI,EAAQ,QAAU,EAAQ,SAAU,EAAO,MAAQ,CAAC,EACxD,GAAI,EAAQ,UAEV,GADA,EAAO,KAAO,GACV,EAAQ,QAAU,OAAQ,EAAO,OAAS,WAE5C,EAAO,OAAS,CAAC,EACb,EAAQ,QAAU,MAAO,EAAO,OAAS,EAAM,UAAU,EAAO,MAAM,EAG9E,GAAI,EAAQ,OAAO,OAAQ,CACzB,EAAO,MAAQ,CAAC,EAChB,QAAS,EAAI,EAAG,EAAI,EAAQ,MAAM,SAAU,EAC1C,EAAO,MAAM,GAAK,EAAM,OAAO,KAAK,SAAS,EAAQ,MAAM,GAAI,CAAO,EAE1E,GAAI,EAAQ,MAAQ,MAAQ,EAAQ,eAAe,MAAM,EAAG,EAAO,KAAO,EAAQ,KAClF,GAAI,EAAQ,QAAU,MAAQ,EAAQ,eAAe,QAAQ,EAC3D,EAAO,OACL,EAAQ,QAAU,OACd,EAAM,OAAO,OAAO,EAAQ,OAAQ,EAAG,EAAQ,OAAO,MAAM,EAC5D,EAAQ,QAAU,MAChB,MAAM,UAAU,MAAM,KAAK,EAAQ,MAAM,EACzC,EAAQ,OAClB,OAAO,GAUT,EAAW,UAAU,gBAAkB,CAAM,EAAG,CAC9C,OAAO,KAAK,YAAY,SAAS,KAAM,EAAU,KAAK,aAAa,GAG9D,IACN,EAEH,EAAM,SAAW,IAAM,CAkBrB,SAAS,CAAO,CAAC,EAAY,CAE3B,GADA,KAAK,OAAS,CAAC,EACX,GACF,QAAS,EAAO,OAAO,KAAK,CAAU,EAAG,EAAI,EAAG,EAAI,EAAK,SAAU,EACjE,GAAI,EAAW,EAAK,KAAO,KAAM,KAAK,EAAK,IAAM,EAAW,EAAK,KAoQvE,OA3PA,EAAQ,UAAU,YAAc,EAAM,UAAU,CAAC,CAAC,EAQlD,EAAQ,UAAU,UAAY,EAAM,UAAU,CAAC,CAAC,EAQhD,EAAQ,UAAU,OAAS,EAAM,WAUjC,EAAQ,gBAAkB,CAAM,CAAC,EAAY,CAC3C,OAAO,IAAI,EAAQ,CAAU,GAY/B,EAAQ,gBAAkB,CAAM,CAAC,EAAS,EAAQ,CAChD,IAAK,EAAQ,EAAS,EAAQ,OAAO,EACrC,GAAI,EAAQ,aAAe,MAAQ,OAAO,eAAe,KAAK,EAAS,aAAa,EAClF,EAAO,OAA+B,EAAE,EAAE,MAAM,EAAQ,WAAW,EACrE,GAAI,EAAQ,WAAa,MAAQ,OAAO,eAAe,KAAK,EAAS,WAAW,EAC9E,EAAO,OAA+B,EAAE,EAAE,MAAM,EAAQ,SAAS,EACnE,GAAI,EAAQ,QAAQ,OAClB,QAAS,EAAI,EAAG,EAAI,EAAQ,OAAO,SAAU,EAC3C,EAAM,OAAO,KAAK,QAAQ,KAAK,OAC7B,EAAQ,OAAO,GACf,EAAO,OAA+B,EAAE,EAAE,KAAK,CACjD,EAAE,OAAO,EACb,OAAO,GAYT,EAAQ,yBAA2B,CAAe,CAAC,EAAS,EAAQ,CAClE,OAAO,KAAK,OAAO,EAAS,CAAM,EAAE,OAAO,GAc7C,EAAQ,gBAAkB,CAAM,CAAC,EAAQ,EAAQ,CAC/C,KAAM,aAAkB,GAAU,EAAS,EAAQ,OAAO,CAAM,EAChE,MAAM,EAAM,IAAW,OAAY,EAAO,IAAM,EAAO,IAAM,EAC3D,EAAU,IAAI,EAAM,MAAM,QAC5B,MAAO,EAAO,IAAM,EAAK,CACvB,MAAM,EAAM,EAAO,OAAO,EAC1B,OAAQ,IAAQ,OACT,GACH,EAAQ,YAAc,EAAO,MAAM,EACnC,UACG,GACH,EAAQ,UAAY,EAAO,MAAM,EACjC,UACG,GACH,IAAK,EAAQ,QAAQ,OAAQ,EAAQ,OAAS,CAAC,EAC/C,EAAQ,OAAO,KAAK,EAAM,OAAO,KAAK,QAAQ,KAAK,OAAO,EAAQ,EAAO,OAAO,CAAC,CAAC,EAClF,cAEA,EAAO,SAAS,EAAM,CAAC,EACvB,OAGN,OAAO,GAaT,EAAQ,yBAA2B,CAAe,CAAC,EAAQ,CACzD,KAAM,aAAkB,GAAU,EAAS,IAAI,EAAQ,CAAM,EAC7D,OAAO,KAAK,OAAO,EAAQ,EAAO,OAAO,CAAC,GAW5C,EAAQ,gBAAkB,CAAM,CAAC,EAAS,CACxC,UAAW,IAAY,UAAY,IAAY,KAAM,MAAO,kBAC5D,GAAI,EAAQ,aAAe,MAAQ,EAAQ,eAAe,aAAa,GACrE,KAEK,EAAQ,oBAAsB,EAAQ,YAAY,SAAW,UAC9D,EAAM,SAAS,EAAQ,WAAW,GAGpC,MAAO,+BACX,GAAI,EAAQ,WAAa,MAAQ,EAAQ,eAAe,WAAW,GACjE,KAEK,EAAQ,kBAAoB,EAAQ,UAAU,SAAW,UAC1D,EAAM,SAAS,EAAQ,SAAS,GAGlC,MAAO,6BACX,GAAI,EAAQ,QAAU,MAAQ,EAAQ,eAAe,QAAQ,EAAG,CAC9D,IAAK,MAAM,QAAQ,EAAQ,MAAM,EAAG,MAAO,yBAC3C,QAAS,EAAI,EAAG,EAAI,EAAQ,OAAO,SAAU,EAAG,CAC9C,MAAM,EAAQ,EAAM,OAAO,KAAK,QAAQ,KAAK,OAAO,EAAQ,OAAO,EAAE,EACrE,GAAI,EAAO,MAAO,UAAY,GAGlC,OAAO,MAWT,EAAQ,oBAAsB,CAAU,CAAC,EAAQ,CAC/C,GAAI,aAAkB,EAAM,MAAM,QAAS,OAAO,EAClD,MAAM,EAAU,IAAI,EAAM,MAAM,QAChC,GAAI,EAAO,aAAe,MACxB,UAAW,EAAO,cAAgB,SAChC,EAAM,OAAO,OACX,EAAO,YACN,EAAQ,YAAc,EAAM,UAAU,EAAM,OAAO,OAAO,EAAO,WAAW,CAAC,EAC9E,CACF,UACO,EAAO,YAAY,OAAQ,EAAQ,YAAc,EAAO,YACnE,GAAI,EAAO,WAAa,MACtB,UAAW,EAAO,YAAc,SAC9B,EAAM,OAAO,OACX,EAAO,UACN,EAAQ,UAAY,EAAM,UAAU,EAAM,OAAO,OAAO,EAAO,SAAS,CAAC,EAC1E,CACF,UACO,EAAO,UAAU,OAAQ,EAAQ,UAAY,EAAO,UAC/D,GAAI,EAAO,OAAQ,CACjB,IAAK,MAAM,QAAQ,EAAO,MAAM,EAAG,MAAM,UAAU,uCAAuC,EAC1F,EAAQ,OAAS,CAAC,EAClB,QAAS,EAAI,EAAG,EAAI,EAAO,OAAO,SAAU,EAAG,CAC7C,UAAW,EAAO,OAAO,KAAO,SAC9B,MAAM,UAAU,wCAAwC,EAC1D,EAAQ,OAAO,GAAK,EAAM,OAAO,KAAK,QAAQ,KAAK,WAAW,EAAO,OAAO,EAAE,GAGlF,OAAO,GAYT,EAAQ,kBAAoB,CAAQ,CAAC,EAAS,EAAS,CACrD,IAAK,EAAS,EAAU,CAAC,EACzB,MAAM,EAAS,CAAC,EAChB,GAAI,EAAQ,QAAU,EAAQ,SAAU,EAAO,OAAS,CAAC,EACzD,GAAI,EAAQ,SAAU,CACpB,GAAI,EAAQ,QAAU,OAAQ,EAAO,YAAc,WAEjD,EAAO,YAAc,CAAC,EAClB,EAAQ,QAAU,MAAO,EAAO,YAAc,EAAM,UAAU,EAAO,WAAW,EAEtF,GAAI,EAAQ,QAAU,OAAQ,EAAO,UAAY,WAE/C,EAAO,UAAY,CAAC,EAChB,EAAQ,QAAU,MAAO,EAAO,UAAY,EAAM,UAAU,EAAO,SAAS,EAGpF,GAAI,EAAQ,aAAe,MAAQ,EAAQ,eAAe,aAAa,EACrE,EAAO,YACL,EAAQ,QAAU,OACd,EAAM,OAAO,OAAO,EAAQ,YAAa,EAAG,EAAQ,YAAY,MAAM,EACtE,EAAQ,QAAU,MAChB,MAAM,UAAU,MAAM,KAAK,EAAQ,WAAW,EAC9C,EAAQ,YAClB,GAAI,EAAQ,WAAa,MAAQ,EAAQ,eAAe,WAAW,EACjE,EAAO,UACL,EAAQ,QAAU,OACd,EAAM,OAAO,OAAO,EAAQ,UAAW,EAAG,EAAQ,UAAU,MAAM,EAClE,EAAQ,QAAU,MAChB,MAAM,UAAU,MAAM,KAAK,EAAQ,SAAS,EAC5C,EAAQ,UAClB,GAAI,EAAQ,QAAQ,OAAQ,CAC1B,EAAO,OAAS,CAAC,EACjB,QAAS,EAAI,EAAG,EAAI,EAAQ,OAAO,SAAU,EAC3C,EAAO,OAAO,GAAK,EAAM,OAAO,KAAK,QAAQ,KAAK,SAAS,EAAQ,OAAO,GAAI,CAAO,EAEzF,OAAO,GAUT,EAAQ,UAAU,gBAAkB,CAAM,EAAG,CAC3C,OAAO,KAAK,YAAY,SAAS,KAAM,EAAU,KAAK,aAAa,GAG9D,IACN,EAEI,IACN,EAEH,EAAM,QAAU,IAAM,CAMpB,MAAM,EAAS,CAAC,EAswBhB,OApwBA,EAAO,MAAQ,IAAM,CAMnB,MAAM,EAAO,CAAC,EA2vBd,OAzvBA,EAAK,SAAW,IAAM,CAMpB,MAAM,EAAU,CAAC,EAgvBjB,OA9uBA,EAAQ,MAAQ,IAAM,CAiBpB,SAAS,CAAI,CAAC,EAAY,CACxB,GAAI,GACF,QAAS,EAAO,OAAO,KAAK,CAAU,EAAG,EAAI,EAAG,EAAI,EAAK,SAAU,EACjE,GAAI,EAAW,EAAK,KAAO,KAAM,KAAK,EAAK,IAAM,EAAW,EAAK,KAgLvE,OAvKA,EAAK,UAAU,MAAQ,GAQvB,EAAK,UAAU,OAAS,GAUxB,EAAK,gBAAkB,CAAM,CAAC,EAAY,CACxC,OAAO,IAAI,EAAK,CAAU,GAY5B,EAAK,gBAAkB,CAAM,CAAC,EAAS,EAAQ,CAC7C,IAAK,EAAQ,EAAS,EAAQ,OAAO,EACrC,GAAI,EAAQ,OAAS,MAAQ,OAAO,eAAe,KAAK,EAAS,OAAO,EACtE,EAAO,OAA+B,EAAE,EAAE,OAAO,EAAQ,KAAK,EAChE,GAAI,EAAQ,QAAU,MAAQ,OAAO,eAAe,KAAK,EAAS,QAAQ,EACxE,EAAO,OAA+B,EAAE,EAAE,OAAO,EAAQ,MAAM,EACjE,OAAO,GAYT,EAAK,yBAA2B,CAAe,CAAC,EAAS,EAAQ,CAC/D,OAAO,KAAK,OAAO,EAAS,CAAM,EAAE,OAAO,GAc7C,EAAK,gBAAkB,CAAM,CAAC,EAAQ,EAAQ,CAC5C,KAAM,aAAkB,GAAU,EAAS,EAAQ,OAAO,CAAM,EAChE,MAAM,EAAM,IAAW,OAAY,EAAO,IAAM,EAAO,IAAM,EAC3D,EAAU,IAAI,EAAM,OAAO,KAAK,QAAQ,KAC1C,MAAO,EAAO,IAAM,EAAK,CACvB,MAAM,EAAM,EAAO,OAAO,EAC1B,OAAQ,IAAQ,OACT,GACH,EAAQ,MAAQ,EAAO,OAAO,EAC9B,UACG,GACH,EAAQ,OAAS,EAAO,OAAO,EAC/B,cAEA,EAAO,SAAS,EAAM,CAAC,EACvB,OAGN,OAAO,GAaT,EAAK,yBAA2B,CAAe,CAAC,EAAQ,CACtD,KAAM,aAAkB,GAAU,EAAS,IAAI,EAAQ,CAAM,EAC7D,OAAO,KAAK,OAAO,EAAQ,EAAO,OAAO,CAAC,GAW5C,EAAK,gBAAkB,CAAM,CAAC,EAAS,CACrC,UAAW,IAAY,UAAY,IAAY,KAAM,MAAO,kBAC5D,GAAI,EAAQ,OAAS,MAAQ,EAAQ,eAAe,OAAO,GACzD,IAAK,EAAM,SAAS,EAAQ,KAAK,EAAG,MAAO,yBAC7C,GAAI,EAAQ,QAAU,MAAQ,EAAQ,eAAe,QAAQ,GAC3D,IAAK,EAAM,SAAS,EAAQ,MAAM,EAAG,MAAO,0BAC9C,OAAO,MAWT,EAAK,oBAAsB,CAAU,CAAC,EAAQ,CAC5C,GAAI,aAAkB,EAAM,OAAO,KAAK,QAAQ,KAAM,OAAO,EAC7D,MAAM,EAAU,IAAI,EAAM,OAAO,KAAK,QAAQ,KAC9C,GAAI,EAAO,OAAS,KAAM,EAAQ,MAAQ,OAAO,EAAO,KAAK,EAC7D,GAAI,EAAO,QAAU,KAAM,EAAQ,OAAS,OAAO,EAAO,MAAM,EAChE,OAAO,GAYT,EAAK,kBAAoB,CAAQ,CAAC,EAAS,EAAS,CAClD,IAAK,EAAS,EAAU,CAAC,EACzB,MAAM,EAAS,CAAC,EAChB,GAAI,EAAQ,SACV,EAAO,MAAQ,GACf,EAAO,OAAS,GAElB,GAAI,EAAQ,OAAS,MAAQ,EAAQ,eAAe,OAAO,EACzD,EAAO,MAAQ,EAAQ,MACzB,GAAI,EAAQ,QAAU,MAAQ,EAAQ,eAAe,QAAQ,EAC3D,EAAO,OAAS,EAAQ,OAC1B,OAAO,GAUT,EAAK,UAAU,gBAAkB,CAAM,EAAG,CACxC,OAAO,KAAK,YAAY,SAAS,KAAM,EAAU,KAAK,aAAa,GAG9D,IACN,EAEH,EAAQ,SAAW,IAAM,CAiBvB,SAAS,CAAO,CAAC,EAAY,CAC3B,GAAI,GACF,QAAS,EAAO,OAAO,KAAK,CAAU,EAAG,EAAI,EAAG,EAAI,EAAK,SAAU,EACjE,GAAI,EAAW,EAAK,KAAO,KAAM,KAAK,EAAK,IAAM,EAAW,EAAK,KAgLvE,OAvKA,EAAQ,UAAU,MAAQ,GAQ1B,EAAQ,UAAU,OAAS,GAU3B,EAAQ,gBAAkB,CAAM,CAAC,EAAY,CAC3C,OAAO,IAAI,EAAQ,CAAU,GAY/B,EAAQ,gBAAkB,CAAM,CAAC,EAAS,EAAQ,CAChD,IAAK,EAAQ,EAAS,EAAQ,OAAO,EACrC,GAAI,EAAQ,OAAS,MAAQ,OAAO,eAAe,KAAK,EAAS,OAAO,EACtE,EAAO,OAA+B,EAAE,EAAE,OAAO,EAAQ,KAAK,EAChE,GAAI,EAAQ,QAAU,MAAQ,OAAO,eAAe,KAAK,EAAS,QAAQ,EACxE,EAAO,OAA+B,EAAE,EAAE,OAAO,EAAQ,MAAM,EACjE,OAAO,GAYT,EAAQ,yBAA2B,CAAe,CAAC,EAAS,EAAQ,CAClE,OAAO,KAAK,OAAO,EAAS,CAAM,EAAE,OAAO,GAc7C,EAAQ,gBAAkB,CAAM,CAAC,EAAQ,EAAQ,CAC/C,KAAM,aAAkB,GAAU,EAAS,EAAQ,OAAO,CAAM,EAChE,MAAM,EAAM,IAAW,OAAY,EAAO,IAAM,EAAO,IAAM,EAC3D,EAAU,IAAI,EAAM,OAAO,KAAK,QAAQ,QAC1C,MAAO,EAAO,IAAM,EAAK,CACvB,MAAM,EAAM,EAAO,OAAO,EAC1B,OAAQ,IAAQ,OACT,GACH,EAAQ,MAAQ,EAAO,OAAO,EAC9B,UACG,GACH,EAAQ,OAAS,EAAO,OAAO,EAC/B,cAEA,EAAO,SAAS,EAAM,CAAC,EACvB,OAGN,OAAO,GAaT,EAAQ,yBAA2B,CAAe,CAAC,EAAQ,CACzD,KAAM,aAAkB,GAAU,EAAS,IAAI,EAAQ,CAAM,EAC7D,OAAO,KAAK,OAAO,EAAQ,EAAO,OAAO,CAAC,GAW5C,EAAQ,gBAAkB,CAAM,CAAC,EAAS,CACxC,UAAW,IAAY,UAAY,IAAY,KAAM,MAAO,kBAC5D,GAAI,EAAQ,OAAS,MAAQ,EAAQ,eAAe,OAAO,GACzD,IAAK,EAAM,SAAS,EAAQ,KAAK,EAAG,MAAO,yBAC7C,GAAI,EAAQ,QAAU,MAAQ,EAAQ,eAAe,QAAQ,GAC3D,IAAK,EAAM,SAAS,EAAQ,MAAM,EAAG,MAAO,0BAC9C,OAAO,MAWT,EAAQ,oBAAsB,CAAU,CAAC,EAAQ,CAC/C,GAAI,aAAkB,EAAM,OAAO,KAAK,QAAQ,QAAS,OAAO,EAChE,MAAM,EAAU,IAAI,EAAM,OAAO,KAAK,QAAQ,QAC9C,GAAI,EAAO,OAAS,KAAM,EAAQ,MAAQ,OAAO,EAAO,KAAK,EAC7D,GAAI,EAAO,QAAU,KAAM,EAAQ,OAAS,OAAO,EAAO,MAAM,EAChE,OAAO,GAYT,EAAQ,kBAAoB,CAAQ,CAAC,EAAS,EAAS,CACrD,IAAK,EAAS,EAAU,CAAC,EACzB,MAAM,EAAS,CAAC,EAChB,GAAI,EAAQ,SACV,EAAO,MAAQ,GACf,EAAO,OAAS,GAElB,GAAI,EAAQ,OAAS,MAAQ,EAAQ,eAAe,OAAO,EACzD,EAAO,MAAQ,EAAQ,MACzB,GAAI,EAAQ,QAAU,MAAQ,EAAQ,eAAe,QAAQ,EAC3D,EAAO,OAAS,EAAQ,OAC1B,OAAO,GAUT,EAAQ,UAAU,gBAAkB,CAAM,EAAG,CAC3C,OAAO,KAAK,YAAY,SAAS,KAAM,EAAU,KAAK,aAAa,GAG9D,IACN,EAEH,EAAQ,UAAY,IAAM,CAgBxB,SAAS,CAAQ,CAAC,EAAY,CAC5B,GAAI,GACF,QAAS,EAAO,OAAO,KAAK,CAAU,EAAG,EAAI,EAAG,EAAI,EAAK,SAAU,EACjE,GAAI,EAAW,EAAK,KAAO,KAAM,KAAK,EAAK,IAAM,EAAW,EAAK,KA0JvE,OAjJA,EAAS,UAAU,IAAM,GAUzB,EAAS,gBAAkB,CAAM,CAAC,EAAY,CAC5C,OAAO,IAAI,EAAS,CAAU,GAYhC,EAAS,gBAAkB,CAAM,CAAC,EAAS,EAAQ,CACjD,IAAK,EAAQ,EAAS,EAAQ,OAAO,EACrC,GAAI,EAAQ,KAAO,MAAQ,OAAO,eAAe,KAAK,EAAS,KAAK,EAClE,EAAO,OAA+B,EAAE,EAAE,OAAO,EAAQ,GAAG,EAC9D,OAAO,GAYT,EAAS,yBAA2B,CAAe,CAAC,EAAS,EAAQ,CACnE,OAAO,KAAK,OAAO,EAAS,CAAM,EAAE,OAAO,GAc7C,EAAS,gBAAkB,CAAM,CAAC,EAAQ,EAAQ,CAChD,KAAM,aAAkB,GAAU,EAAS,EAAQ,OAAO,CAAM,EAChE,MAAM,EAAM,IAAW,OAAY,EAAO,IAAM,EAAO,IAAM,EAC3D,EAAU,IAAI,EAAM,OAAO,KAAK,QAAQ,SAC1C,MAAO,EAAO,IAAM,EAAK,CACvB,MAAM,EAAM,EAAO,OAAO,EAC1B,OAAQ,IAAQ,OACT,GACH,EAAQ,IAAM,EAAO,OAAO,EAC5B,cAEA,EAAO,SAAS,EAAM,CAAC,EACvB,OAGN,OAAO,GAaT,EAAS,yBAA2B,CAAe,CAAC,EAAQ,CAC1D,KAAM,aAAkB,GAAU,EAAS,IAAI,EAAQ,CAAM,EAC7D,OAAO,KAAK,OAAO,EAAQ,EAAO,OAAO,CAAC,GAW5C,EAAS,gBAAkB,CAAM,CAAC,EAAS,CACzC,UAAW,IAAY,UAAY,IAAY,KAAM,MAAO,kBAC5D,GAAI,EAAQ,KAAO,MAAQ,EAAQ,eAAe,KAAK,GACrD,IAAK,EAAM,SAAS,EAAQ,GAAG,EAAG,MAAO,uBAC3C,OAAO,MAWT,EAAS,oBAAsB,CAAU,CAAC,EAAQ,CAChD,GAAI,aAAkB,EAAM,OAAO,KAAK,QAAQ,SAAU,OAAO,EACjE,MAAM,EAAU,IAAI,EAAM,OAAO,KAAK,QAAQ,SAC9C,GAAI,EAAO,KAAO,KAAM,EAAQ,IAAM,OAAO,EAAO,GAAG,EACvD,OAAO,GAYT,EAAS,kBAAoB,CAAQ,CAAC,EAAS,EAAS,CACtD,IAAK,EAAS,EAAU,CAAC,EACzB,MAAM,EAAS,CAAC,EAChB,GAAI,EAAQ,SAAU,EAAO,IAAM,GACnC,GAAI,EAAQ,KAAO,MAAQ,EAAQ,eAAe,KAAK,EAAG,EAAO,IAAM,EAAQ,IAC/E,OAAO,GAUT,EAAS,UAAU,gBAAkB,CAAM,EAAG,CAC5C,OAAO,KAAK,YAAY,SAAS,KAAM,EAAU,KAAK,aAAa,GAG9D,IACN,EAEH,EAAQ,UAAY,IAAM,CAgBxB,SAAS,CAAQ,CAAC,EAAY,CAC5B,GAAI,GACF,QAAS,EAAO,OAAO,KAAK,CAAU,EAAG,EAAI,EAAG,EAAI,EAAK,SAAU,EACjE,GAAI,EAAW,EAAK,KAAO,KAAM,KAAK,EAAK,IAAM,EAAW,EAAK,KA0JvE,OAjJA,EAAS,UAAU,IAAM,GAUzB,EAAS,gBAAkB,CAAM,CAAC,EAAY,CAC5C,OAAO,IAAI,EAAS,CAAU,GAYhC,EAAS,gBAAkB,CAAM,CAAC,EAAS,EAAQ,CACjD,IAAK,EAAQ,EAAS,EAAQ,OAAO,EACrC,GAAI,EAAQ,KAAO,MAAQ,OAAO,eAAe,KAAK,EAAS,KAAK,EAClE,EAAO,OAA+B,EAAE,EAAE,OAAO,EAAQ,GAAG,EAC9D,OAAO,GAYT,EAAS,yBAA2B,CAAe,CAAC,EAAS,EAAQ,CACnE,OAAO,KAAK,OAAO,EAAS,CAAM,EAAE,OAAO,GAc7C,EAAS,gBAAkB,CAAM,CAAC,EAAQ,EAAQ,CAChD,KAAM,aAAkB,GAAU,EAAS,EAAQ,OAAO,CAAM,EAChE,MAAM,EAAM,IAAW,OAAY,EAAO,IAAM,EAAO,IAAM,EAC3D,EAAU,IAAI,EAAM,OAAO,KAAK,QAAQ,SAC1C,MAAO,EAAO,IAAM,EAAK,CACvB,MAAM,EAAM,EAAO,OAAO,EAC1B,OAAQ,IAAQ,OACT,GACH,EAAQ,IAAM,EAAO,OAAO,EAC5B,cAEA,EAAO,SAAS,EAAM,CAAC,EACvB,OAGN,OAAO,GAaT,EAAS,yBAA2B,CAAe,CAAC,EAAQ,CAC1D,KAAM,aAAkB,GAAU,EAAS,IAAI,EAAQ,CAAM,EAC7D,OAAO,KAAK,OAAO,EAAQ,EAAO,OAAO,CAAC,GAW5C,EAAS,gBAAkB,CAAM,CAAC,EAAS,CACzC,UAAW,IAAY,UAAY,IAAY,KAAM,MAAO,kBAC5D,GAAI,EAAQ,KAAO,MAAQ,EAAQ,eAAe,KAAK,GACrD,IAAK,EAAM,SAAS,EAAQ,GAAG,EAAG,MAAO,uBAC3C,OAAO,MAWT,EAAS,oBAAsB,CAAU,CAAC,EAAQ,CAChD,GAAI,aAAkB,EAAM,OAAO,KAAK,QAAQ,SAAU,OAAO,EACjE,MAAM,EAAU,IAAI,EAAM,OAAO,KAAK,QAAQ,SAC9C,GAAI,EAAO,KAAO,KAAM,EAAQ,IAAM,OAAO,EAAO,GAAG,EACvD,OAAO,GAYT,EAAS,kBAAoB,CAAQ,CAAC,EAAS,EAAS,CACtD,IAAK,EAAS,EAAU,CAAC,EACzB,MAAM,EAAS,CAAC,EAChB,GAAI,EAAQ,SAAU,EAAO,IAAM,GACnC,GAAI,EAAQ,KAAO,MAAQ,EAAQ,eAAe,KAAK,EAAG,EAAO,IAAM,EAAQ,IAC/E,OAAO,GAUT,EAAS,UAAU,gBAAkB,CAAM,EAAG,CAC5C,OAAO,KAAK,YAAY,SAAS,KAAM,EAAU,KAAK,aAAa,GAG9D,IACN,EAEI,IACN,EAEI,IACN,EAEI,IACN,EAEH,IAAe,ID3uFR,IAAM,EAAwB,IAAM,CACzC,OAAO,IAAI,GAAS,CAClB,GAAG,GACH,CAAC,iBAAkB,IAAW,EAAQ,MAAM,OAAQ,CAAC,EACrD,CAAC,oBAAqB,IAAW,EAAQ,MAAM,UAAW,CAAC,CAC7D,CAAC,GAGU,EAA0B,CAAC,IAAwC,CAC9E,OAAO,IAAI,GAAW,CACpB,iBAAkB,CAChB,UAAW,GAAG,IAAU,GAAM,KAAO,YAAc,sBACnD,QAAS,CAAC,KAAsB,CAC9B,aAAc,EAAe,EAAO,WAAW,EAC/C,WAAY,EAAe,EAAO,SAAS,EAC3C,OAAQ,CAAC,GAAG,EAAO,MAAM,CAC3B,GACA,UAAW,CAAC,KAAsB,CAChC,YAAa,EAAe,EAAO,YAAY,EAC/C,UAAW,EAAe,EAAO,UAAU,EAC3C,OAAQ,CAAC,GAAG,EAAO,MAAM,CAC3B,EACF,EACA,oBAAqB,CACnB,UAAW,GAAG,IAAU,GAAM,KAAO,YAAc,yBACnD,QAAS,CAAC,KAAsB,CAC9B,OAAQ,EAAe,EAAO,MAAM,EACpC,KAAM,EAAO,KACb,MAAO,CAAC,GAAG,EAAO,KAAK,CACzB,GACA,UAAW,CAAC,KAAsB,CAChC,OAAQ,EAAe,EAAO,MAAM,EACpC,KAAM,EAAO,KACb,MAAO,CAAC,GAAG,EAAO,KAAK,CACzB,EACF,CACF,CAAC,GF9BI,IAAM,EAAqB,CAAC,IAAwC,CACzE,OAAQ,QACD,EAAM,KACT,MAAO,CAAE,OAAQ,CAAC,EAAG,IAAK,aAAc,UAExC,MAAO,CAAE,OAAQ,CAAC,EAAG,IAAK,WAAY,IAI/B,GAAsB,EAAmB,EAAM,SAAS,EAAE,IAC1D,GAAiB,EAAmB,EAAM,IAAI,EAAE,IAEhD,GAAmB,EAC9B,OACA,YACA,aACA,YAMK,CACL,KAAM,GAAG,IAAU,EAAM,KAAO,YAAc,sBAC9C,MAAO,CACL,aAAc,EACd,WAAY,EACZ,OAAQ,CACN,CACE,OAAQ,EAAW,aAAa,QAAQ,EACxC,MAAO,EAAS,EAAW,OAAQ,EAAI,CACzC,CACF,CACF,CACF,GAEa,GAAkB,EAC7B,OACA,aACA,OAAO,GACP,WAMI,CACJ,MAAO,CACL,KAAM,GAAG,IAAU,EAAM,KAAO,YAAc,yBAC9C,MAAO,CACL,MAAO,CACL,CACE,OAAQ,EAAW,aAAa,QAAQ,EACxC,MAAO,GAAkB,CAAU,CACrC,CACF,EACA,OAAQ,EACR,MACF,CACF,GAGW,EAAgB,EAC3B,OACA,YACA,aACA,OACA,WAOI,CAMJ,OALmB,EAEf,GAAgB,CAAE,OAAM,aAAY,OAAM,OAAM,CAAC,EACjD,GAAiB,CAAE,OAAM,YAAW,aAAY,OAAM,CAAC,GAKhD,EAAoB,CAC/B,EACA,IACG,CAGH,OAFmB,EAAwB,CAAK,EAE9B,UAAU,CAAG,GAGpB,GAAmB,OAC9B,OACA,YACA,aACA,OAAO,GACP,aAAa,GACb,WAQI,CAKJ,MAAM,EAAU,MAJD,MAAM,EACnB,EAAa,GAAO,kBAAoB,GAAO,SACjD,GAE6B,WAAW,CAAI,EAE5C,IAAK,EACH,MAAM,IAAI,MAAM,wBAAwB,EAG1C,MAAM,EAAM,EAAc,CAAE,OAAM,YAAW,aAAY,OAAM,OAAM,CAAC,EAWtE,MAToB,CAClB,QAAS,GAAe,GACxB,cAAe,EAAQ,cACvB,SAAU,EAAQ,SAClB,KAAM,CAAC,CAAG,EACV,IAAK,EAAmB,EAAW,KAAqC,EACxE,MACF,GAKW,EAA6B,CAAC,IAA8B,CACvE,GAAI,EAAI,OAAS,qBAAuB,EAAI,OAAS,oBAAqB,OAAO,EAEjF,MAAO,IACF,EACH,MAAO,IACF,EAAI,MACP,MAAQ,EAAmB,MAAM,MAAM,IAAI,CAAC,IAA4C,CACtF,MAAM,EAAa,GAAW,KAAK,CAAE,MAAO,EAAK,KAAM,CAAC,EAElD,GACJ,EAAW,YAAc,EAAW,OAAO,MAAM,GAAG,IAAI,GAAK,EAAW,SACvE,YAAY,EACT,GACJ,EAAW,YAAc,EAAW,OAAO,MAAM,GAAG,IAAI,GAAK,EAAW,QACvE,YAAY,EAEf,MAAO,IACF,EACH,MAAO,CACL,QACA,SACA,OAAQ,EACR,MAAO,EAAW,WACpB,CACF,EACD,CACH,CACF,GAGW,EAAqB,EAChC,QACA,OACA,UAKI,CACJ,MAAM,EAAW,EAAsB,EACjC,EAAa,EAAwB,CAAK,EAE1C,EAAmC,CACvC,QAAS,4BACT,MAAO,CAAE,OAAM,SAAU,EAAK,IAAI,CAAC,IAAQ,EAAW,UAAU,CAAG,CAAC,CAAE,CACxE,EAEA,OAAO,EAAS,OAAO,CAAY,GAGxB,GAAoB,EAAG,SAAQ,WAAwB,CAClE,GAAI,IAAU,EAAM,KAClB,OAAQ,EAAO,YAAY,IAAM,QAAU,EAAS,GAAG,EAAM,QAAQ,KAAU,YAAY,EAE7F,OAAQ,EAAO,YAAY,IAAM,OAAS,EAAS,GAAG,EAAM,aAAa,KAAU,YAAY,GItMjG,gBAAS,sBAAO,aAAiB,kBAAQ,mBAAa,wBACtD,kCAAS,4BAAyB,+BAClC,qBAAS,sBACT,qBAAS,WAAY,aAAO,yBCH5B,4BAA2B,uBAE3B,iBAAS,aAAQ,qBACjB,uBAAuB,0BAEvB,uBAAS,wBAUF,MAAM,CAAa,CACxB,OACA,QACA,OAAS,GACT,OAGA,WAAW,EAAG,SAAQ,UAAS,SAAS,SAAU,WAAW,IAAgC,CAC3F,KAAK,OAAS,EAAO,EAAS,CAAQ,EACtC,KAAK,OAAS,EACd,KAAK,QAAU,EACf,KAAK,OAAS,EAGhB,uBAAyB,MAAO,EAAkB,IAA2B,CAG3E,OAFsB,MAAM,KAAK,GAAkB,EAAU,CAAc,GAEtD,SAGvB,sBAAwB,MAAO,EAAkB,IAA2B,CAC1E,MAAM,EAAgB,MAAM,KAAK,GAAkB,EAAU,CAAc,EAE3E,OAAO,GAAO,OAAO,EAAc,MAAM,GAG3C,aAAe,CAAC,IAAoB,CAClC,IAAK,EAAQ,WAAW,KAAK,MAAM,EAAG,MAAO,GAE7C,GAAI,CACF,MAAQ,SAAQ,SAAU,GAAO,OAAO,CAAO,EAG/C,OAFmB,GAAO,OAAO,EAAQ,CAAK,IAExB,EAAQ,kBAAkB,QACzC,EAAP,CACA,MAAO,KAIX,WAAa,MAAO,IAAoB,CAQtC,OALqB,MAFN,MAAM,EAAqB,KAAK,MAAM,GAEnB,eAAe,CAAO,GAKrC,IAAI,CAAC,KAAa,IAChC,EACH,MAAO,EAAQ,MAAM,SAAS,GAAG,EAAI,EAAQ,MAAM,YAAY,EAAI,EAAQ,KAC7E,EAAE,GAGJ,WAAa,MAAO,IAAoB,CAEtC,OADe,MAAM,EAAqB,KAAK,MAAM,GACvC,WAAW,CAAO,GAGlC,SAAW,OACT,OACA,YACA,aACA,OAAO,GACP,MAAM,GACN,YACoB,CACpB,IAAK,EACH,MAAM,IAAI,GAAa,mCAAmC,EAiB5D,OAbmB,MADG,MAAM,EAA4B,KAAK,OAAQ,CAAM,GACpC,WACrC,EACA,EACA,CACE,CACE,MAAO,EAAS,IAAI,EAAW,QAAQ,EAAE,YAAY,EACrD,OAAQ,EAAW,aAAa,QAAQ,CAC1C,CACF,EACA,EACA,CACF,GAEkB,iBAGpB,GAAa,CAAC,EAAkB,IAA2B,CACzD,OAAO,GAAkB,aAAa,EAAU,CAC9C,OAAQ,KAAK,OACb,QAAS,CAAC,GAAa,CAAc,CAAC,CACxC,CAAC,GAGH,GAAoB,MAAO,EAAkB,IAA2B,CAEtE,MAAM,EAAW,MADF,MAAM,KAAK,GAAW,EAAU,CAAc,GAC/B,YAAY,EAE1C,GAAI,EAAS,SAAW,EACtB,MAAM,IAAI,GAAa,kCAAkC,EAG3D,OAAO,EAAS,GAEpB,CDvGO,IAAM,EAAyB,MAAO,EAAkB,IAAwB,CACrF,GAAI,CAGF,OAFiB,MAAM,GAAW,YAAY,GAE9B,KAAK,CAAC,IAAQ,EAAI,UAAY,CAAO,GAAG,KAAO,QACxD,EAAP,CAEA,OADA,QAAQ,MAAM,CAAC,EACR,IAKE,GAAoB,CAAC,EAAe,IAAmB,CAClE,OAAQ,OACD,OACH,OAAO,EAAW,KAAK,CAAE,MAAO,EAAM,UAAW,MAAO,OAAO,SAAS,CAAM,EAAI,GAAI,CAAC,MACpF,YACA,OACH,OAAO,EAAW,KAAK,CAAE,MAAO,EAAM,OAAQ,MAAO,OAAO,SAAS,CAAM,EAAI,GAAI,CAAC,MACjF,QACH,OAAO,EAAW,KAAK,CAAE,MAAO,EAAM,KAAM,MAAO,OAAO,SAAS,CAAM,EAAI,WAAK,CAAC,MAChF,OACH,OAAO,EAAW,KAAK,CACrB,MAAO,GAAG,EAAM,QAAQ,EAAM,OAC9B,MAAO,OAAO,SAAS,CAAM,EAAI,GACnC,CAAC,MACE,YACA,OACH,OAAO,EAAW,KAAK,CAAE,MAAO,EAAM,OAAQ,MAAO,OAAO,SAAS,CAAM,EAAI,GAAI,CAAC,OACjF,EAEH,OAAO,EAAW,KAAK,CACrB,MAAO,GAAG,EAAM,aAChB,MAAO,OAAO,SAAS,CAAM,EAAI,GACnC,CAAC,UAGD,OAAO,EAAW,KAAK,CAAE,MAAO,EAAO,MAAO,OAAO,SAAS,CAAM,EAAI,GAAI,CAAC,IAItE,EAAoB,EAC/B,iBACA,OAAQ,MAC4B,CACpC,SAAU,EAAa,SACvB,UAAW,CAAC,IAAmB,CAC7B,OAAO,GAAwB,aAAa,EAAQ,CAClD,OAAQ,EAAa,OACrB,QAAS,CAAC,GAAa,GAAG,KAAkB,CAAC,CAC/C,CAAC,GAEH,wBAAyB,CAAC,IAA2B,CACnD,OAAO,GAAsB,QAAQ,EAAY,EAAa,MAAM,GAEtE,2BAA4B,MAAO,IAAmB,CACpD,MAAM,EAAuB,GAAa,GAAG,KAAkB,EACzD,EAAkB,IAAI,GAAgB,CAAM,EAC5C,EAAO,MAAM,GAAM,eAAe,CAAe,GAE/C,WAAY,GAAO,WAAW,GAAY,UAAW,EAAM,CAAoB,EAEvF,OAAO,GAET,WAAY,EAAa,WACzB,gBAAiB,EAAa,aAC9B,uBAAwB,CAAC,IACvB,EAAa,uBAAuB,EAAQ,GAAG,KAAkB,EACnE,sBAAuB,CAAC,IACtB,EAAa,sBAAsB,EAAQ,GAAG,KAAkB,EAClE,yBACA,WAAY,MAAO,EAAiB,IAAmC,CACrE,MAAM,EAAgB,MAAM,EAAa,WAAW,CAAO,EAC3D,OAAO,MAAM,QAAQ,IACnB,EACG,OAAO,EAAG,WAAY,IAAU,EAAM,SAAS,MAAM,CAAC,EACtD,IAAI,EAAG,QAAO,YAAa,GAAkB,EAAO,CAAM,CAAC,CAChE,EAEJ,GAEa,GAAwB,EACnC,UACA,QACA,WAAW,GACX,YAII,CACJ,OAAQ,QACD,EAAM,OAKT,OAJe,IAAI,EAAa,CAC9B,OAAQ,GAAU,+CAClB,QAAS,EAAQ,MACnB,CAAC,EACa,aAAa,CAAO,OAG/B,EAAM,OAMT,OALe,IAAI,EAAa,CAC9B,OAAQ,GAAU,uCAClB,QAAS,EAAQ,OACjB,OAAQ,QACV,CAAC,EACa,aAAa,CAAO,OAE/B,EAAM,UAST,OARe,IAAI,EAAa,CAC9B,OAAQ,EACJ,2CACA,gCACJ,QAAS,EAAW,EAAQ,kBAAoB,EAAQ,UACxD,OAAQ,GAAG,EAAW,IAAM,SAC5B,UACF,CAAC,EACa,aAAa,CAAO,OAG/B,EAAM,KAST,OARe,IAAI,EAAa,CAC9B,OAAQ,EACJ,2CACA,kCACJ,QAAS,EAAW,EAAQ,aAAe,EAAQ,KACnD,OAAQ,GAAG,EAAW,IAAM,SAC5B,UACF,CAAC,EACa,aAAa,CAAO,EAGtC,MAAO,IAGI,GAAyB,EAAG,gBAA6C,CAEpF,OADc,EAAW,YAElB,EAAM,OACT,OAAO,EAAW,KAAK,CAAE,MAAO,EAAM,OAAQ,MAAO,KAAM,CAAC,OAEzD,EAAM,OACT,OAAO,EAAW,KAAK,CAAE,MAAO,EAAM,OAAQ,MAAO,IAAK,CAAC,OAExD,EAAM,UACT,OAAO,EAAW,KAAK,CAAE,MAAO,EAAM,UAAW,MAAO,IAAK,CAAC,OAE3D,EAAM,KACT,OAAO,EAAW,KAAK,CAAE,MAAO,EAAM,KAAM,MAAO,IAAK,CAAC,UAGzD,OAAO,EAAW,IAAI,CAAC,IEpK7B,sBAEE,aACA,qBACA,oBACA,0BASK,IAAM,GAAc,EAAG,UAA0B,CAAC,IAAuB,CAC9E,MAAM,EAAS,IAAI,EAAa,CAC9B,OAAQ,GAAU,+CAClB,QAAS,GAAQ,MACnB,CAAC,EAEK,EAUF,EAAkB,CACpB,QAAS,EAAY,KACrB,eAAgB,GAAe,KAC/B,QACF,CAAC,EAED,eAAe,CAAO,EAAG,CACvB,MAAM,EAAU,MAAM,EAAuB,GAAQ,OAAQ,GAAG,EAChE,MAAO,CACL,KAAM,OACN,QAAS,GAAc,WAAW,OAAO,CAAO,EAAG,EAAY,IAAI,EACnE,KAAM,GAAc,WAAY,OAAO,CAAO,EAAI,IAAO,IAAK,EAAY,IAAI,EAC9E,QAAS,GAAc,WAAW,OAAO,CAAO,EAAI,GAAI,EAAY,IAAI,CAC1E,EAGF,eAAe,CAAQ,CAAC,EAAwB,CAC9C,MAAM,EAAU,MAAM,EAAQ,EAE9B,OAAO,EAAY,SAAS,IACvB,EACH,IAAK,EAAO,KAAO,CACjB,OAAQ,CACN,CACE,MAAO,QACP,OAAQ,EAAQ,EAAO,cAAgB,QAAQ,aAAa,QAAQ,GAAK,MAC3E,CACF,EACA,IAAK,QACP,CACF,CAAC,EAGH,MAAO,IACF,EACH,UACA,UACF,GCrEF,gBAAS,yBCET,sBAEE,aACA,qBACA,oBACA,0BAkBF,eAAe,EAAO,EAAG,CACvB,MAAM,EAAU,MAAM,EAAuB,GAAQ,OAAQ,IAAI,EACjE,MAAO,CACL,KAAM,OACN,QAAS,GAAc,WAAW,OAAO,CAAO,EAAG,EAAY,IAAI,EACnE,KAAM,GAAc,WAAW,OAAO,KAAK,MAAM,EAAU,GAAG,CAAC,EAAG,EAAY,IAAI,EAClF,QAAS,GAAc,WAAW,OAAO,KAAK,MAAM,EAAU,CAAC,CAAC,EAAG,EAAY,IAAI,CACrF,EAGK,IAAM,GAAgB,EAAG,UAA0B,CAAC,IAAyB,CAClF,MAAM,EAAS,IAAI,EAAa,CAC9B,OAAQ,GAAU,uCAClB,QAAS,GAAQ,OACjB,OAAQ,QACV,CAAC,EAEK,EAUF,EAAkB,CACpB,QAAS,EAAY,KACrB,eAAgB,GAAe,KAC/B,QACF,CAAC,EAED,MAAO,IACF,EACH,WACA,WAAY,MAAO,EAAiB,IAAmC,CACrE,MAAM,EAAgB,MAAM,EAAO,WAAW,CAAO,EACrD,OAAO,MAAM,QAAQ,IACnB,EACG,OAAO,EAAG,WAAY,CACrB,IAAK,GAAS,EAAM,SAAS,MAAM,EAAG,MAAO,GAE7C,MACE,CAAC,EAA0B,CAAwB,EAAE,SAAS,CAAK,IAClE,EAAM,WAAW,SAAS,EAE9B,EACA,IAAI,EAAG,QAAO,YAAa,GAAkB,EAAO,CAAM,CAAC,CAChE,GAEF,SAAU,MAAO,IAA2B,CAC1C,MAAM,EAAU,MAAM,GAAQ,EAE9B,OAAO,EAAY,SAAS,IACvB,EACH,IAAK,EAAO,KAAO,CACjB,OAAQ,CACN,CACE,MAAO,QACP,OAAQ,EAAQ,EAAO,cAAgB,QAAQ,aAAa,QAAQ,GAAK,MAC3E,CACF,EACA,IAAK,QACP,CACF,CAAC,EAEL,GC5FF,4BAEE,oCACA,4BACA,sBACA,uBAEF,oBAAS,yBAAW,mBAAoB,wBAExC,iCAAuB,0BACvB,iBAAS,oBACT,sBAEE,YACA,aACA,qBACA,gBACA,oBACA,mBACA,oBACA,0BAsIF,SAAS,EAAe,CAAC,EAA0D,CACjF,OAAO,eAAe,CAAe,EACnC,YACA,UACA,WAKC,CACD,MAAM,EAAU,MAAM,EAAW,CAAO,EACxC,IAAK,GAAS,OAAQ,MAAM,IAAI,GAAa,2CAA2C,EAExF,MAAM,EAAgB,GAAmB,gBAAgB,EAAO,OAAO,CAAS,CAAC,EACjF,OAAO,GAAU,gBAAgB,EAAe,EAAO,OAAO,CAAO,EAAG,EAAQ,OAAO,KAAK,GAtHhG,IAAM,GACJ,EAAG,SAAQ,oBACX,CAAC,EAAkB,EAAQ,IAAM,CAC/B,OAAO,GAAkB,aAAa,EAAU,CAC9C,QAAS,CAAC,GAAa,GAAG,KAAkB,GAAO,CAAC,EACpD,QACF,CAAC,GAGC,GAAkB,CAAC,IAA0B,EAAO,OAAO,CAAS,EAEpE,GAAiB,MACrB,EACA,EACA,IACG,CACH,MAAQ,OAAM,gBAAe,WAAU,UAAS,MAAK,QAAS,KAAK,MAAM,CAAE,EAErE,GAAW,MAAM,EAAO,YAAY,KAAK,IAAI,SAAW,GACxD,EAAa,MAAM,EAAwB,CAAK,EAChD,EAAW,MAAM,EAAsB,EACvC,EAAgB,MAAM,GAA4B,EAAQ,CAC9D,WACA,YACF,CAAC,EAEK,EAAgB,CAAC,EAEvB,QAAW,KAAO,EAAM,CACtB,MAAM,EAAU,MAAM,EAAkB,EAAK,CAAK,EAClD,EAAc,KAAK,CAAO,EAG5B,MACE,YAAa,IACX,MAAM,EAAc,KAAK,EAAS,EAAe,EAAK,EAAM,CAC9D,gBACA,WACA,SACF,CAAC,EAEK,EAAY,MAAM,EAAmB,CACzC,QACA,KAAM,EAAK,IAAI,CAAC,IAAkB,EAA2B,CAAG,CAAC,EACjE,MACF,CAAC,EAED,MAAO,CAAE,UAAW,GAAgB,CAAuB,EAAG,WAAU,GAGpE,GACJ,EAAG,SAAQ,YACX,MACE,EACA,EACA,EACA,EACA,IACG,CACH,MAAQ,WAAU,OAAQ,KAAK,MAAM,CAAE,EACjC,EAAiB,MAAM,GAAe,EAAgB,CAAS,EAE/D,EAAiD,EAAQ,IAAI,CAAC,IAAW,CAC7E,GAAgB,GAAsB,EAAO,OAAO,EAAO,MAAM,CAAC,EAAG,CAAM,EAC3E,EAAO,OAAO,EAAO,SAAS,CAChC,CAAC,EAEK,EAAc,MAAM,EAAqB,CAAM,GAE7C,mBAAoB,MAAM,EAAY,YAC5C,GACE,EACA,EACA,EACA,EACA,IAAI,IAAwB,CAAsB,CACpD,CACF,EAEA,OAAO,GAGL,GAAiB,MAAO,EAAmB,EAAmB,EAAgB,KAAS,CAC3F,OAAO,GACL,EAAQ,IAAI,CAAC,IAAW,GAAsB,EAAO,OAAO,CAAM,CAAC,CAAC,EACpE,EACA,CACF,GAGI,GAAkB,CAAC,IAAsB,EAAO,OAAO,CAAS,EAEhE,GAA8B,CAAC,IAAmB,CAAC,IAAmB,CAC1E,OAAO,GAAgB,EAAQ,CAAM,GAGjC,GAAqB,OACzB,aACA,aACiD,CACjD,MAAM,EAAY,MAAM,GAAU,gBAAgB,EAAO,OAAO,CAAO,EAAG,CAAU,EACpF,OAAO,EAAO,OAAO,OAAO,OAAO,CAAC,EAAU,EAAE,EAAE,EAAG,EAAU,EAAE,EAAE,CAAC,CAAC,CAAC,GAqB3D,GAAuB,EAClC,QACA,cAG0B,CAC1B,MAAM,EAAc,IAAU,EAAM,UAC9B,EAAS,IAAU,EAAM,KACzB,EAAU,EAAc,GAAQ,UAAY,GAAQ,KAEpD,EAAS,GAAG,EAAW,IAAM,KAAK,EAAM,YAAY,IACpD,EAAiB,GAAe,GAChC,EAAS,EAAO,EAAS,CAAQ,EACjC,EAAU,EACZ,EACE,2CACA,2CACF,EACE,kCACA,gCAEA,EAAS,IAAI,EAAa,CAC9B,OAAQ,EACR,UACA,SACA,UACF,CAAC,EACK,EAAa,EAAmB,CAAK,EAErC,EASF,EAAkB,CACpB,SACA,iBACA,QAAS,GAAY,EACvB,CAAC,EAEK,EAAsB,MAAO,IAAoB,CACrD,GAAI,CAGF,OAF+B,MAAM,EAAY,WAAW,CAAO,QAG5D,EAAP,CACA,OAAO,QAAQ,OAAO,CAAK,IAIzB,EAAU,SAAY,CAC1B,IAAI,EAEJ,MAAM,EAAe,GAAG,KAAW,EAAc,YAAc,yBAE/D,GAAI,CACF,MACE,eAAiB,qBAAsB,IACrC,MAAM,GAAc,IAAgC,CAAY,EAGpE,IAAK,GAAa,OAAO,MAAM,CAAS,GAAK,EAAY,EACvD,MAAM,MAAM,sBAAsB,EAAU,SAAS,GAAG,EAE1D,EAAM,IAAI,GAAc,CAAS,OACjC,CACA,EAAM,IAAI,GAAc,CACtB,MAAO,EAAc,KAAO,EAC5B,QAAS,GAAY,EACvB,CAAC,EAGH,MAAO,EACJ,GAAU,SAAU,GACpB,GAAU,MAAO,GACjB,GAAU,SAAU,CACvB,GAGI,EAAW,OACf,OACA,YACA,aACA,QAAO,GACP,aACgE,CAChE,IAAK,GAAQ,MAAM,IAAI,MAAM,oBAAoB,EAEjD,MAAM,GAAW,EAAsB,EACjC,GAAgB,MAAM,EAA4B,EAAQ,GAAQ,CACtE,WACF,CAAC,EAEK,GAAU,EACd,EAA2B,EAAc,CAAE,aAAY,OAAM,YAAW,QAAM,OAAM,CAAC,CAAC,EACtF,CACF,EAIA,OAFmB,MAAM,GAAc,iBAAiB,EAAM,CAAC,EAAO,EAAG,EAAY,EAAI,GAEvE,iBAGpB,MAAO,IACF,EACH,QAAS,CAAC,IAA4C,EAAS,CAAM,EACrE,WACA,UACA,gBACA,oBACA,oBACA,qBACA,6BACA,wBAAyB,IAAM,EAAwB,CAAK,EAC5D,wBACA,8BAA+B,GAA8B,CAC3D,iBACA,QACF,CAAC,EACD,eAAgB,CAAC,EAA2B,IAAe,GAAe,EAAQ,EAAI,CAAK,EAC3F,oBAAqB,GAAoB,CAAE,SAAQ,QAAO,CAAC,EAC3D,kBACA,mBACA,sBACA,gBAAiB,GAA4B,CAAM,EACnD,sBACA,gBAAiB,GAAgB,EAAY,UAAU,CACzD,GAGW,GAAmB,EAAG,YAA4B,CAAC,IAA4B,CAC1F,OAAO,GAAqB,CAAE,MAAO,EAAM,UAAW,UAAS,CAAC,GAGrD,GAAc,EAAG,YAA4B,CAAC,IAAuB,CAChF,OAAO,GAAqB,CAAE,MAAO,EAAM,KAAM,UAAS,CAAC,GF1StD,IAAM,GAAoB,CAA8B,IAA6B,CAC1F,OAAQ,QACD,EAAM,OACT,OAAO,QACJ,EAAM,KACT,OAAO,QACJ,EAAM,UACT,OAAO,QACJ,EAAM,OACT,OAAO,WAEP,MAAM,IAAI,MAAM,SAAS,oBAAwB",
  "debugId": "E8736A2CC407A98A64756E2164756E21",
  "names": []
}