import{networks as wB,Psbt as lB,Transaction as YB}from"bitcoinjs-lib";import{Chain as W,RequestClient as i}from"@swapkit/helpers";var o=(_)=>`https://api.blockchair.com/${Y_(_)}`,k_=(_)=>{switch(_){case W.Bitcoin:return 5;case W.Dogecoin:return 1e4;case W.Litecoin:return 1;default:return 2}},Y_=(_)=>{switch(_){case W.BitcoinCash:return"bitcoin-cash";case W.Litecoin:return"litecoin";case W.Dash:return"dash";case W.Dogecoin:return"dogecoin";case W.Polkadot:return"polkadot";default:return"bitcoin"}},m_=async(_)=>{try{const{feePerKb:g}=await i.get(`https://app.bitgo.com/api/v2/${_.toLowerCase()}/tx/fee`),B=g/1000;return Math.max(B,k_(_))}catch(g){return k_(_)}},x=async(_,g)=>{try{const B=await i.get(_);if(!B||B.context.code!==200)throw new Error(`failed to query ${_}`);return B.data}catch(B){if(!g)throw B;const b=await i.get(`${_}${g?`&key=${g}`:""}`);if(!b||b.context.code!==200)throw new Error(`failed to query ${_}`);return b.data}},I_={utxo:[],address:{balance:0,transaction_count:0}},D_=async({address:_,chain:g,apiKey:B})=>{if(!_)throw new Error("address is required");try{return(await x(`${o(g)}/dashboards/address/${_}?transaction_details=true`,B))[_]}catch(b){return I_}},F_=async({address:_,chain:g,apiKey:B})=>{return(await D_({address:_,chain:g,apiKey:B}))?.address.balance},f_=async({chain:_,address:g,apiKey:B})=>{if(!g)throw new Error("address is required");try{return(await x(`${o(_)}/addresses/balances?addresses=${g}`,B))[g]||0}catch(b){return 0}},G_=async({chain:_,apiKey:g,txHash:B})=>{if(!B)throw new Error("txHash is required");try{return(await x(`${o(_)}/raw/transaction/${B}`,g))?.[B]?.raw_transaction}catch(b){return console.error(b),""}},v_=async({chain:_,address:g,apiKey:B,offset:b=0})=>{if(!g)throw new Error("address is required");try{const n=await x(`${o(_)}/outputs?q=is_spent(false),recipient(${g})&limit=100&offset=${b}`,B),k=n.filter(({is_spent:D})=>!D).map(({script_hex:D,block_id:r,transaction_hash:v,index:U,value:Q,spending_signature_hex:G})=>({hash:v,index:U,value:Q,txHex:G,script_hex:D,is_confirmed:r!==-1}));if(n.length!==100)return k;const X=await v_({address:g,chain:_,apiKey:B,offset:n?.[99]?.transaction_id});return k.concat(X)}catch(n){return console.error(n),[]}},O_=async({address:_,chain:g,apiKey:B,fetchTxHex:b=!0})=>{const n=await v_({chain:g,address:_,apiKey:B}),k=[];for(let{hash:X,index:D,script_hex:r,value:v}of n){let U;if(b)U=await G_({txHash:X,chain:g,apiKey:B});k.push({address:_,hash:X,index:D,txHex:U,value:v,witnessUtxo:{value:v,script:Buffer.from(r,"hex")}})}return k},A=({apiKey:_,chain:g})=>({getConfirmedBalance:(B)=>f_({chain:g,address:B,apiKey:_}),getRawTx:(B)=>G_({txHash:B,chain:g,apiKey:_}),getSuggestedTxFee:()=>m_(g),getBalance:(B)=>F_({address:B,chain:g,apiKey:_}),getAddressData:(B)=>D_({address:B,chain:g,apiKey:_}),scanUTXOs:(B)=>O_({...B,chain:g,apiKey:_})});import{Chain as j,ChainToRPC as Wg}from"@swapkit/helpers";import{RequestClient as V_}from"@swapkit/helpers";import{Chain as Y,FeeOption as t}from"@swapkit/helpers";import{networks as o_}from"bitcoinjs-lib";import m from"coininfo";var x_=typeof process!=="undefined"&&process.pid?process.pid.toString(36):"",L=(_)=>{switch(_){case Y.Bitcoin:return o_.bitcoin;case Y.BitcoinCash:return m.bitcoincash.main.toBitcoinJS();case Y.Dash:return m.dash.main.toBitcoinJS();case Y.Litecoin:return m.litecoin.main.toBitcoinJS();case Y.Dogecoin:{const g={private:70615956,public:70617039},B=m.dogecoin.test;return B.versions.bip32=g,m.dogecoin.main.toBitcoinJS()}default:throw new Error("Invalid chain")}},U_=(_)=>({[t.Average]:_,[t.Fast]:_*1.5,[t.Fastest]:_*2}),d=0,A_=()=>{const _=Date.now(),g=d||_;return d=g,_>d?_:g+1},$_=()=>x_+A_().toString(36);var V=async({txHash:_,rpcUrl:g})=>{const B=JSON.stringify({jsonrpc:"2.0",method:"sendrawtransaction",params:[_],id:$_()}),b=await V_.post(g,{headers:{"Content-Type":"application/json"},body:B});if(b.error)throw new Error(`failed to broadcast a transaction: ${b.error?.message}`);if(b.result.includes('"code":-26'))throw new Error("Invalid transaction: the transaction amount was too low");return b.result};import*as bg from"@bitcoinerlab/secp256k1";import{HDNode as ng,Transaction as Xg,TransactionBuilder as kg,address as Dg}from"@psf/bitcoincashjs-lib";import{mnemonicToSeedSync as Gg}from"@scure/bip39";import{Chain as vg,DerivationPath as Ug,FeeOption as $g,RPCUrl as Jg}from"@swapkit/helpers";import{Psbt as rg}from"bitcoinjs-lib";import{ECPairFactory as Qg}from"ecpair";import r_ from"bs58check";import Q_ from"cashaddrjs";function q_(_){try{return C(_),!0}catch(g){return!1}}function L_(_){return C(_)?.network}function I(_){const g=C(_);if(g?.format==="legacy")return _;return P_(g)}function N(_){const g=C(_);return K_(g)}function C(_){try{return N_(_)}catch(g){}try{return C_(_)}catch(g){}throw Error("Received an invalid Bitcoin Cash address as input.")}function N_(_){try{const g=r_.decode(_);if(g.length!==21)throw Error("Received an invalid Bitcoin Cash address as input.");const B=g[0],b=Array.prototype.slice.call(g,1);switch(B){case J.legacy.mainnet.p2pkh:return{hash:b,format:"legacy",network:"mainnet",type:"p2pkh"};case J.legacy.mainnet.p2sh:return{hash:b,format:"legacy",network:"mainnet",type:"p2sh"};case J.legacy.testnet.p2pkh:return{hash:b,format:"legacy",network:"testnet",type:"p2pkh"};case J.legacy.testnet.p2sh:return{hash:b,format:"legacy",network:"testnet",type:"p2sh"};case J.bitpay.mainnet.p2pkh:return{hash:b,format:"bitpay",network:"mainnet",type:"p2pkh"};case J.bitpay.mainnet.p2sh:return{hash:b,format:"bitpay",network:"mainnet",type:"p2sh"};default:throw Error("Received an invalid Bitcoin Cash address as input.")}}catch(g){throw Error("Received an invalid Bitcoin Cash address as input.")}}function C_(_){if(_.indexOf(":")!==-1)try{return J_(_)}catch(g){}else{const g=["bitcoincash","bchtest","bchreg"];for(let B of g)try{return J_(`${B}:${_}`)}catch(b){}}throw Error("Received an invalid Bitcoin Cash address as input.")}function J_(_){try{const{hash:g,prefix:B,type:b}=Q_.decode(_);return{format:"cashaddr",hash:Array.prototype.slice.call(g,0),network:B==="bitcoincash"?"mainnet":"testnet",type:b==="P2PKH"?"p2pkh":"p2sh"}}catch(g){throw Error("Received an invalid Bitcoin Cash address as input.")}}function P_(_){const g=J.legacy[_.network][_.type],B=Buffer.alloc(1+_.hash.length);return B[0]=g,B.set(_.hash,1),r_.encode(B)}function K_(_){const g=_.network==="mainnet"?"bitcoincash":"bchtest",B=_.type==="p2pkh"?"P2PKH":"P2SH",b=new Uint8Array(_.hash);return Q_.encode(g,B,b)}var Z_;((B)=>{B.Mainnet="mainnet";B.Testnet="testnet"})(Z_||={});var J={["legacy"]:{["mainnet"]:{["p2pkh"]:0,["p2sh"]:5},["testnet"]:{["p2pkh"]:111,["p2sh"]:196}},["bitpay"]:{["mainnet"]:{["p2pkh"]:28,["p2sh"]:40},["testnet"]:{["p2pkh"]:111,["p2sh"]:196}}};import{Chain as w}from"@swapkit/helpers";var s=(_)=>{switch(_){case w.Bitcoin:case w.BitcoinCash:return 550;case w.Dash:case w.Litecoin:return 5500;case w.Dogecoin:return 1e5;default:throw new Error("Invalid Chain")}},z=({inputs:_,outputs:g,feeRate:B=1,chain:b=w.Bitcoin})=>{const n=Math.ceil(B),k=_[0]&&"address"in _[0]&&_[0].address?K(_[0].address):"P2PKH",X=_.filter((G)=>T(G)*n<=G.value),D=a+g.reduce((G,$)=>G+P($,k),0),r=g.reduce((G,$)=>G+$.value,0);let v=D*n,U=0;const Q=[];for(let G of X){const $=T(G),Z=n*$;v+=Z,U+=G.value,Q.push(G);const q=v+r;if(U<q)continue;const H=U-q,b_=n*P({address:"",value:0},k);if(H>b_){const n_=b_+v,X_=U-(r+n_);if(X_>Math.max(T({})*n,s(b)))return{inputs:Q,outputs:g.concat({value:X_,address:""}),fee:n_}}return{inputs:Q,outputs:g,fee:v}}return{fee:n*F({inputs:_,outputs:g,feeRate:n})}};import{opcodes as S_,script as E_}from"bitcoinjs-lib";var Sg=1000,a=10,R_=10,c_=41,u_=107,y=(_)=>{const g=Buffer.from(_,"utf8");return E_.compile([S_.OP_RETURN,g])},e;((B)=>{B.P2PKH="P2PKH";B.P2WPKH="P2WPKH"})(e||={});var __={["P2PKH"]:148,["P2WPKH"]:68},S={["P2PKH"]:34,["P2WPKH"]:31},K=(_)=>{if(_.startsWith("bc1")||_.startsWith("ltc1"))return"P2WPKH";if(_.startsWith("1")||_.startsWith("3")||_.startsWith("L")||_.startsWith("M")||_.startsWith("X")||_.startsWith("D")||_.startsWith("bitcoincash:q")||_.startsWith("q"))return"P2PKH";throw new Error("Invalid address")},F=({inputs:_,outputs:g,feeRate:B})=>{const b=_[0]&&"address"in _[0]&&_[0].address?K(_[0].address):"P2PKH",n=_.filter((X)=>X.value>=__["type"in X?X.type:"P2PKH"]*Math.ceil(B)).reduce((X,D)=>X+T(D),0),k=g?.reduce((X,D)=>X+P(D),0)||S[b];return a+n+k},T=(_)=>{if("type"in _)return __[_.type];if("address"in _&&_.address)return __[K(_.address)];return c_+u_},P=(_,g)=>{if(_?.script)return R_+_.script.length+(_.script.length>=74?2:1);if(g)return S[g];return S.P2PKH};import*as g_ from"@bitcoinerlab/secp256k1";import{HDKey as h_}from"@scure/bip32";import{mnemonicToSeedSync as p_}from"@scure/bip39";import{AssetValue as E,BaseDecimal as i_,Chain as R,FeeOption as B_,SwapKitNumber as t_}from"@swapkit/helpers";import{Psbt as d_,address as s_,initEccLib as T_,payments as j_}from"bitcoinjs-lib";import{ECPairFactory as a_}from"ecpair";var c=[R.Dash,R.Dogecoin],W_=({phrase:_,wif:g,derivationPath:B,chain:b})=>{if(!(g||_))throw new Error("Either phrase or wif must be provided");const n=a_(g_),k=L(b);if(g)return n.fromWIF(g,k);const X=p_(_),D=h_.fromMasterSeed(X,k).derive(B);if(!D.privateKey)throw new Error("Could not get private key from phrase");return n.fromPrivateKey(Buffer.from(D.privateKey),{network:k})},z_=({address:_,chain:g})=>{try{return T_(g_),s_.toOutputScript(_,L(g)),!0}catch(B){return!1}},e_=({keys:_,chain:g})=>{if(!_)throw new Error("Keys must be provided");const B=c.includes(g)?j_.p2pkh:j_.p2wpkh,{address:b}=B({pubkey:_.publicKey,network:L(g)});if(!b)throw new Error("Address not defined");return b},_g=async({signTransaction:_,from:g,memo:B,recipient:b,chain:n,apiClient:k,feeOptionKey:X,broadcastTx:D,feeRate:r,assetValue:v})=>{if(!g)throw new Error("From address must be provided");if(!b)throw new Error("Recipient address must be provided");const U=r||(await u(k))[X||B_.Fast],{psbt:Q}=await H_({recipient:b,feeRate:U,sender:g,fetchTxHex:c.includes(n),chain:n,apiClient:k,assetValue:v,memo:B}),G=await _(Q);return G.finalizeAllInputs(),D(G.extractTransaction().toHex())},gg=async({address:_,chain:g,apiClient:B})=>{const n=(await B.getBalance(_)||0)/10**i_[g];return[await E.from({asset:`${g}.${g}`,value:n})]},u=async(_)=>U_(await _.getSuggestedTxFee()),y_=async({assetValue:_,recipient:g,memo:B,sender:b,fetchTxHex:n=!1,apiClient:k})=>{return{inputs:await k.scanUTXOs({address:b,fetchTxHex:n}),outputs:[{address:g,value:Number(_.bigIntValue)},...B?[{address:"",script:y(B),value:0}]:[]]}},H_=async({assetValue:_,recipient:g,memo:B,feeRate:b,sender:n,fetchTxHex:k=!1,apiClient:X,chain:D})=>{const r=B?y(B):null,v=await y_({assetValue:_,recipient:g,memo:B,sender:n,fetchTxHex:k,apiClient:X}),{inputs:U,outputs:Q}=z({...v,feeRate:b,chain:D});if(!(U&&Q))throw new Error("Insufficient Balance for transaction");const G=new d_({network:L(D)});if(D===R.Dogecoin)G.setMaximumFeeRate(650000000);for(let $ of U)G.addInput({hash:$.hash,index:$.index,...!!$.witnessUtxo&&!c.includes(D)&&{witnessUtxo:$.witnessUtxo},...c.includes(D)&&{nonWitnessUtxo:$.txHex?Buffer.from($.txHex,"hex"):void 0}});for(let $ of Q){const Z="address"in $&&$.address?$.address:n,q=$.script?r?{script:r,value:0}:void 0:{address:Z,value:$.value};if(q)T_(g_),G.addOutput(q)}return{psbt:G,utxos:v.inputs,inputs:U}},M_=async({assetValue:_,apiClient:g,chain:B,feeOptionKey:b=B_.Fast,feeRate:n,fetchTxHex:k=!1,memo:X,recipient:D,from:r})=>{const v=await y_({assetValue:_,recipient:D,memo:X,sender:r,fetchTxHex:k,apiClient:g}),U=n?Math.floor(n):(await u(g))[b];return z({...v,feeRate:U,chain:B})},Bg=async({from:_,memo:g,feeRate:B,feeOptionKey:b=B_.Fast,recipients:n=1,chain:k,apiClient:X})=>{const D=await X.getAddressData(_),r=B?Math.ceil(B):(await u(X))[b],v=D?.utxo.map((Z)=>({...Z,type:"P2PKH",hash:""})).filter((Z)=>Z.value>Math.max(s(k),T(Z)*r));if(!v?.length)return E.from({chain:k});const U=E.from({chain:k,value:v.reduce((Z,q)=>Z+q.value,0)}),Q=typeof n==="number"?Array.from({length:n},()=>({address:_,value:0})):n;if(g){const Z=y(g);Q.push({address:_,script:Z,value:0})}const $=F({inputs:v,outputs:Q,feeRate:r})*r;return U.sub($)},h=(_)=>({accumulative:z,apiClient:_.apiClient,broadcastTx:_.broadcastTx,calculateTxSize:F,buildTx:(g)=>H_({...g,..._}),getAddressFromKeys:(g)=>e_({keys:g,..._}),validateAddress:(g)=>z_({address:g,..._}),createKeysForPath:(g)=>W_({...g,..._}),getPrivateKeyFromMnemonic:async(g)=>W_({..._,...g}).toWIF(),getBalance:async(g,B)=>gg({address:g,..._}),getFeeRates:()=>u(_.apiClient),transfer:(g)=>_g({...g,..._}),getInputsOutputsFee:(g)=>M_({...g,..._}),estimateTransactionFee:async(g)=>{return E.from({chain:_.chain,value:t_.fromBigInt(BigInt((await M_({...g,..._})).fee),8).getValue("string")})},estimateMaxSendableAmount:async(g)=>Bg({...g,..._})}),_B=({chain:_,address:g})=>_===R.BitcoinCash?l(g):z_({address:g,chain:_});var M=vg.BitcoinCash,O=(_)=>f(N(_)),w_=async({assetValue:_,recipient:g,memo:B,feeRate:b,sender:n,apiClient:k})=>{if(!l(g))throw new Error("Invalid address");const X=await k.scanUTXOs({address:O(n),fetchTxHex:!0}),D=B?y(B):null,r=[];r.push({address:g,value:_.getBaseValue("number")});const{inputs:v,outputs:U}=z({inputs:X,outputs:r,feeRate:b,chain:M});if(!(v&&U))throw new Error("Balance insufficient for transaction");const Q=new kg(L(M));await Promise.all(v.map(async(G)=>{const $=await k.getRawTx(G.hash);Q.addInput(Xg.fromBuffer(Buffer.from($,"hex")),G.index)}));for(let G of U){const $="address"in G&&G.address?G.address:I(n),Z=Dg.toOutputScript(I($),L(M));Q.addOutput(Z,G.value)}if(D)Q.addOutput(D,0);return{builder:Q,utxos:v}},Zg=async({signTransaction:_,from:g,recipient:B,assetValue:b,apiClient:n,broadcastTx:k,getFeeRates:X,...D})=>{if(!g)throw new Error("From address must be provided");if(!B)throw new Error("Recipient address must be provided");if(!_)throw new Error("signTransaction must be provided");const r=D.feeRate||(await X())[$g.Fast],{builder:v,utxos:U}=await w_({...D,assetValue:b,feeRate:r,recipient:B,sender:g,apiClient:n}),G=_({builder:v,utxos:U}).toHex();return k(G)},qg=async({assetValue:_,recipient:g,memo:B,feeRate:b,sender:n,apiClient:k})=>{const X=N(g);if(!l(X))throw new Error("Invalid address");const D=await k.scanUTXOs({address:O(n),fetchTxHex:!0}),r=Number(b.toFixed(0)),v=B?y(B):null,U=[];if(U.push({address:I(g),value:_.getBaseValue("number")}),v)U.push({script:v,value:0});const{inputs:Q,outputs:G}=z({inputs:D,outputs:U,feeRate:r,chain:M});if(!(Q&&G))throw new Error("Balance insufficient for transaction");const $=new rg({network:L(M)});for(let{hash:Z,index:q,witnessUtxo:H}of Q)$.addInput({hash:Z,index:q,witnessUtxo:H});for(let Z of G){const q="address"in Z&&Z.address?Z.address:I(n),H=Z.script?v?{script:v,value:0}:void 0:{address:q,value:Z.value};if(H)$.addOutput(H)}return{psbt:$,utxos:D,inputs:Q}},f=(_)=>_.replace(/(bchtest:|bitcoincash:)/,""),l=(_)=>{const g=f(_);return q_(g)&&L_(g)==="mainnet"},Lg=({phrase:_,derivationPath:g=`${Ug.BCH}/0`,wif:B})=>{const b=L(M);if(B)return Qg(bg).fromWIF(B,b);if(!_)throw new Error("No phrase provided");return ng.fromSeedBuffer(Buffer.from(Gg(_)),b).derivePath(g).keyPair},jg=(_)=>{const g=_.getAddress(0);return O(g)},l_=({apiKey:_,rpcUrl:g=Jg.BitcoinCash,apiClient:B})=>{const b=B||A({apiKey:_,chain:M}),{getBalance:n,...k}=h({chain:M,apiClient:b,broadcastTx:(X)=>V({txHash:X,rpcUrl:g})});return{...k,stripPrefix:f,stripToCashAddress:O,validateAddress:l,createKeysForPath:Lg,getAddressFromKeys:jg,buildBCHTx:(X)=>w_({...X,apiClient:b}),getBalance:(X,D)=>n(f(N(X))),buildTx:(X)=>qg({...X,apiClient:b}),transfer:(X)=>Zg({...X,getFeeRates:k.getFeeRates,broadcastTx:k.broadcastTx,apiClient:b})}};var p=(_)=>({apiKey:g,rpcUrl:B=Wg[_],apiClient:b})=>{return h({chain:_,broadcastTx:(n)=>V({txHash:n,rpcUrl:B}),apiClient:b||A({apiKey:g,chain:_})})},Mg=l_,Tg=p(j.Bitcoin),zg=p(j.Dash),yg=p(j.Dogecoin),Hg=p(j.Litecoin),jB=(_)=>{switch(_){case j.BitcoinCash:return Mg;case j.Bitcoin:return Tg;case j.Dogecoin:return yg;case j.Litecoin:return Hg;case j.Dash:return zg;default:throw new Error(`Chain ${_} is not supported`)}};export{l as validateAddress,_B as utxoValidateAddress,$_ as uniqid,I as toLegacyAddress,N as toCashAddress,O as stripToCashAddress,f as stripPrefix,U_ as standardFeeRates,c as nonSegwitChains,wB as networks,q_ as isValidAddress,jB as getToolboxByChain,K as getScriptTypeForAddress,P as getOutputSize,L as getNetwork,T as getInputSize,s as getDustThreshold,Bg as estimateMaxSendableAmount,L_ as detectAddressNetwork,y as compileMemo,F as calculateTxSize,A as blockchairApi,z as accumulative,e as UTXOScriptType,YB as Transaction,a as TX_OVERHEAD,lB as Psbt,S as OutputSizes,R_ as OP_RETURN_OVERHEAD,Z_ as Network,Sg as MIN_TX_FEE,Hg as LTCToolbox,__ as InputSizes,yg as DOGEToolbox,zg as DASHToolbox,h as BaseUTXOToolbox,Tg as BTCToolbox,Mg as BCHToolbox};

//# debugId=42B714AD1866C21364756E2164756E21
