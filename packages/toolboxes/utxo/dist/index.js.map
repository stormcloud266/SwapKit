{
  "version": 3,
  "sources": ["../src/index.ts", "../src/api/blockchairApi.ts", "../src/toolbox/index.ts", "../src/api/rpcApi.ts", "../src/utils/utils.ts", "../src/toolbox/bitcoinCash.ts", "../src/utils/bchaddrjs.ts", "../src/utils/coinselect.ts", "../src/utils/txSize.ts", "../src/toolbox/utxo.ts"],
  "sourcesContent": [
    "export { type Network, networks, Psbt, Transaction } from \"bitcoinjs-lib\";\n\n/**\n * Package\n */\nexport * from \"./api/blockchairApi.ts\";\nexport * from \"./toolbox/index.ts\";\nexport * from \"./toolbox/utxo.ts\";\nexport * from \"./types/index.ts\";\nexport * from \"./utils/bchaddrjs.ts\";\nexport * from \"./utils/index.ts\";\n",
    "import { Chain, RequestClient, type UTXOChain } from \"@swapkit/helpers\";\n\nimport type {\n  BlockchairAddressResponse,\n  BlockchairMultipleBalancesResponse,\n  BlockchairOutputsResponse,\n  BlockchairRawTransactionResponse,\n  BlockchairResponse,\n  UTXOType,\n} from \"../types/index.ts\";\ntype BlockchairParams<T> = T & { chain: Chain; apiKey?: string };\n\nconst baseUrl = (chain: Chain) => `https://api.blockchair.com/${mapChainToBlockchairChain(chain)}`;\n\nconst getDefaultTxFeeByChain = (chain: Chain) => {\n  switch (chain) {\n    case Chain.Bitcoin:\n      return 5;\n    case Chain.Dogecoin:\n      return 10000;\n    case Chain.Litecoin:\n      return 1;\n    default:\n      return 2;\n  }\n};\n\nconst mapChainToBlockchairChain = (chain: Chain) => {\n  switch (chain) {\n    case Chain.BitcoinCash:\n      return \"bitcoin-cash\";\n    case Chain.Litecoin:\n      return \"litecoin\";\n    case Chain.Dash:\n      return \"dash\";\n    case Chain.Dogecoin:\n      return \"dogecoin\";\n    case Chain.Polkadot:\n      return \"polkadot\";\n    default:\n      return \"bitcoin\";\n  }\n};\n\nconst getSuggestedTxFee = async (chain: Chain) => {\n  try {\n    //Use Bitgo API for fee estimation\n    //Refer: https://app.bitgo.com/docs/#operation/v2.tx.getfeeestimate\n    const { feePerKb } = await RequestClient.get<{\n      feePerKb: number;\n      cpfpFeePerKb: number;\n      numBlocks: number;\n      feeByBlockTarget: { 1: number; 3: number };\n    }>(`https://app.bitgo.com/api/v2/${chain.toLowerCase()}/tx/fee`);\n    const suggestedFee = feePerKb / 1000;\n\n    return Math.max(suggestedFee, getDefaultTxFeeByChain(chain));\n  } catch (_error) {\n    return getDefaultTxFeeByChain(chain);\n  }\n};\n\nconst blockchairRequest = async <T>(url: string, apiKey?: string): Promise<T> => {\n  try {\n    const response = await RequestClient.get<BlockchairResponse<T>>(url);\n    if (!response || response.context.code !== 200) throw new Error(`failed to query ${url}`);\n\n    return response.data as T;\n  } catch (error) {\n    if (!apiKey) throw error;\n    const response = await RequestClient.get<BlockchairResponse<T>>(\n      `${url}${apiKey ? `&key=${apiKey}` : \"\"}`,\n    );\n\n    if (!response || response.context.code !== 200) throw new Error(`failed to query ${url}`);\n\n    return response.data as T;\n  }\n};\n\nconst baseAddressData = { utxo: [], address: { balance: 0, transaction_count: 0 } };\nconst getAddressData = async ({\n  address,\n  chain,\n  apiKey,\n}: BlockchairParams<{ address?: string }>) => {\n  if (!address) throw new Error(\"address is required\");\n\n  try {\n    const response = await blockchairRequest<BlockchairAddressResponse>(\n      `${baseUrl(chain)}/dashboards/address/${address}?transaction_details=true`,\n      apiKey,\n    );\n\n    return response[address];\n  } catch (_error) {\n    return baseAddressData;\n  }\n};\n\nconst getUnconfirmedBalance = async ({\n  address,\n  chain,\n  apiKey,\n}: BlockchairParams<{ address?: string }>) => {\n  const response = await getAddressData({ address, chain, apiKey });\n\n  return response?.address.balance;\n};\n\nconst getConfirmedBalance = async ({\n  chain,\n  address,\n  apiKey,\n}: BlockchairParams<{ address?: string }>) => {\n  if (!address) throw new Error(\"address is required\");\n  try {\n    const response = await blockchairRequest<BlockchairMultipleBalancesResponse>(\n      `${baseUrl(chain)}/addresses/balances?addresses=${address}`,\n      apiKey,\n    );\n\n    return response[address] || 0;\n  } catch (_error) {\n    return 0;\n  }\n};\n\nconst getRawTx = async ({ chain, apiKey, txHash }: BlockchairParams<{ txHash?: string }>) => {\n  if (!txHash) throw new Error(\"txHash is required\");\n\n  try {\n    const rawTxResponse = await blockchairRequest<BlockchairRawTransactionResponse>(\n      `${baseUrl(chain)}/raw/transaction/${txHash}`,\n      apiKey,\n    );\n    return rawTxResponse?.[txHash]?.raw_transaction;\n  } catch (error) {\n    console.error(error);\n    return \"\";\n  }\n};\n\nconst getUnspentTxs = async ({\n  chain,\n  address,\n  apiKey,\n  offset = 0,\n}: BlockchairParams<{ offset?: number; address: string }>): Promise<\n  (UTXOType & { script_hex: string; is_confirmed: boolean })[]\n> => {\n  if (!address) throw new Error(\"address is required\");\n  try {\n    const response = await blockchairRequest<BlockchairOutputsResponse[]>(\n      `${baseUrl(\n        chain,\n      )}/outputs?q=is_spent(false),recipient(${address})&limit=100&offset=${offset}`,\n      apiKey,\n    );\n\n    const txs = response\n      .filter(({ is_spent }) => !is_spent)\n      .map(({ script_hex, block_id, transaction_hash, index, value, spending_signature_hex }) => ({\n        hash: transaction_hash,\n        index,\n        value,\n        txHex: spending_signature_hex,\n        script_hex,\n        is_confirmed: block_id !== -1,\n      })) as (UTXOType & { script_hex: string; is_confirmed: boolean })[];\n\n    if (response.length !== 100) return txs;\n\n    const nextBatch = await getUnspentTxs({\n      address,\n      chain,\n      apiKey,\n      offset: response?.[99]?.transaction_id,\n    });\n\n    return txs.concat(nextBatch);\n  } catch (error) {\n    console.error(error);\n    return [];\n  }\n};\n\nconst scanUTXOs = async ({\n  address,\n  chain,\n  apiKey,\n  fetchTxHex = true,\n}: BlockchairParams<{ address: string; fetchTxHex?: boolean }>) => {\n  const utxos = await getUnspentTxs({ chain, address, apiKey });\n  const results = [];\n\n  for (const { hash, index, script_hex, value } of utxos) {\n    let txHex: string | undefined;\n    if (fetchTxHex) {\n      txHex = await getRawTx({ txHash: hash, chain, apiKey });\n    }\n    results.push({\n      address,\n      hash,\n      index,\n      txHex,\n      value,\n      witnessUtxo: { value, script: Buffer.from(script_hex, \"hex\") },\n    });\n  }\n  return results;\n};\n\nexport const blockchairApi = ({ apiKey, chain }: { apiKey?: string; chain: UTXOChain }) => ({\n  getConfirmedBalance: (address: string) => getConfirmedBalance({ chain, address, apiKey }),\n  getRawTx: (txHash: string) => getRawTx({ txHash, chain, apiKey }),\n  getSuggestedTxFee: () => getSuggestedTxFee(chain),\n  getBalance: (address: string) => getUnconfirmedBalance({ address, chain, apiKey }),\n  getAddressData: (address: string) => getAddressData({ address, chain, apiKey }),\n  scanUTXOs: (params: { address: string; fetchTxHex?: boolean }) =>\n    scanUTXOs({ ...params, chain, apiKey }),\n});\n\nexport type BlockchairApiType = ReturnType<typeof blockchairApi>;\n",
    "import { Chain, ChainToRPC, type UTXOChain } from \"@swapkit/helpers\";\n\nimport type { BlockchairApiType } from \"../api/blockchairApi.ts\";\nimport { blockchairApi } from \"../api/blockchairApi.ts\";\nimport { broadcastUTXOTx } from \"../api/rpcApi.ts\";\n\nimport { createBCHToolbox } from \"./bitcoinCash.ts\";\nimport { BaseUTXOToolbox } from \"./utxo.ts\";\n\ntype ToolboxFactory = (params: {\n  apiKey?: string;\n  rpcUrl?: string;\n  apiClient?: BlockchairApiType;\n}) => ReturnType<typeof BaseUTXOToolbox>;\n\ntype ToolboxType = {\n  BCH: typeof BCHToolbox;\n  BTC: typeof BTCToolbox;\n  DOGE: typeof DOGEToolbox;\n  LTC: typeof LTCToolbox;\n  DASH: typeof DASHToolbox;\n};\n\nconst createToolbox =\n  (chain: UTXOChain): ToolboxFactory =>\n  ({ apiKey, rpcUrl = ChainToRPC[chain], apiClient }) => {\n    return BaseUTXOToolbox({\n      chain,\n      broadcastTx: (txHash: string) => broadcastUTXOTx({ txHash, rpcUrl }),\n      apiClient: apiClient || blockchairApi({ apiKey, chain }),\n    });\n  };\n\nexport const BCHToolbox = createBCHToolbox;\nexport const BTCToolbox = createToolbox(Chain.Bitcoin);\nexport const DASHToolbox = createToolbox(Chain.Dash);\nexport const DOGEToolbox = createToolbox(Chain.Dogecoin);\nexport const LTCToolbox = createToolbox(Chain.Litecoin);\n\nexport const getToolboxByChain = <T extends keyof ToolboxType>(chain: T): ToolboxType[T] => {\n  switch (chain) {\n    case Chain.BitcoinCash:\n      return BCHToolbox as ToolboxType[T];\n    case Chain.Bitcoin:\n      return BTCToolbox as ToolboxType[T];\n    case Chain.Dogecoin:\n      return DOGEToolbox as ToolboxType[T];\n    case Chain.Litecoin:\n      return LTCToolbox as ToolboxType[T];\n    case Chain.Dash:\n      return DASHToolbox as ToolboxType[T];\n    default:\n      throw new Error(`Chain ${chain} is not supported`);\n  }\n};\n\nexport { stripToCashAddress, stripPrefix, validateAddress } from \"./bitcoinCash.ts\";\n",
    "import { RequestClient } from \"@swapkit/helpers\";\n\nimport { uniqid } from \"../utils/utils.ts\";\n\nexport const broadcastUTXOTx = async ({ txHash, rpcUrl }: { txHash: string; rpcUrl: string }) => {\n  const body = JSON.stringify({\n    jsonrpc: \"2.0\",\n    method: \"sendrawtransaction\",\n    params: [txHash],\n    id: uniqid(),\n  });\n\n  const response = await RequestClient.post<{\n    id: string;\n    result: string;\n    error: { message: string; code?: number } | null;\n  }>(rpcUrl, { headers: { \"Content-Type\": \"application/json\" }, body });\n\n  if (response.error) {\n    throw new Error(`failed to broadcast a transaction: ${response.error?.message}`);\n  }\n\n  if (response.result.includes('\"code\":-26')) {\n    throw new Error(\"Invalid transaction: the transaction amount was too low\");\n  }\n\n  return response.result;\n};\n",
    "import { Chain, FeeOption } from \"@swapkit/helpers\";\nimport { networks } from \"bitcoinjs-lib\";\n// @ts-ignore TODO: check why wallets doesn't see modules included in toolbox\nimport coininfo from \"coininfo\";\n\nconst pid = typeof process !== \"undefined\" && process.pid ? process.pid.toString(36) : \"\";\n\nexport const getNetwork = (chain: Chain) => {\n  switch (chain) {\n    case Chain.Bitcoin:\n      return networks.bitcoin;\n    case Chain.BitcoinCash:\n      return coininfo.bitcoincash.main.toBitcoinJS();\n    case Chain.Dash:\n      return coininfo.dash.main.toBitcoinJS();\n    case Chain.Litecoin:\n      return coininfo.litecoin.main.toBitcoinJS();\n\n    case Chain.Dogecoin: {\n      const bip32 = { private: 0x04358394, public: 0x043587cf };\n      const test = coininfo.dogecoin.test;\n      test.versions.bip32 = bip32;\n      return coininfo.dogecoin.main.toBitcoinJS();\n    }\n    default:\n      throw new Error(\"Invalid chain\");\n  }\n};\n\nexport const standardFeeRates = (rate: number) => ({\n  [FeeOption.Average]: rate,\n  [FeeOption.Fast]: rate * 1.5,\n  [FeeOption.Fastest]: rate * 2.0,\n});\n\nlet last = 0;\nconst now = () => {\n  const time = Date.now();\n  const lastTime = last || time;\n  last = lastTime;\n\n  return time > last ? time : lastTime + 1;\n};\n\nexport const uniqid = () => pid + now().toString(36);\n",
    "import * as secp256k1 from \"@bitcoinerlab/secp256k1\";\nimport {\n  HDNode,\n  Transaction,\n  TransactionBuilder,\n  address as bchAddress,\n  // @ts-ignore TODO: check why wallets doesn't see modules included in toolbox\n} from \"@psf/bitcoincashjs-lib\";\n\nimport { mnemonicToSeedSync } from \"@scure/bip39\";\nimport { Chain, DerivationPath, FeeOption, RPCUrl, type UTXOChain } from \"@swapkit/helpers\";\nimport { Psbt } from \"bitcoinjs-lib\";\nimport { ECPairFactory } from \"ecpair\";\n\nimport type { BlockchairApiType } from \"../api/blockchairApi.ts\";\nimport { blockchairApi } from \"../api/blockchairApi.ts\";\nimport { broadcastUTXOTx } from \"../api/rpcApi.ts\";\nimport type {\n  TargetOutput,\n  TransactionBuilderType,\n  TransactionType,\n  UTXOBuildTxParams,\n  UTXOWalletTransferParams,\n} from \"../types/common.ts\";\nimport type { UTXOType } from \"../types/index.ts\";\nimport {\n  Network as bchNetwork,\n  detectAddressNetwork,\n  isValidAddress,\n  toCashAddress,\n  toLegacyAddress,\n} from \"../utils/bchaddrjs.ts\";\nimport { accumulative, compileMemo, getNetwork } from \"../utils/index.ts\";\n\nimport { BaseUTXOToolbox } from \"./utxo.ts\";\n\n// needed because TS can not infer types\ntype BCHMethods = {\n  stripPrefix: (address: string) => string;\n  stripToCashAddress: (address: string) => string;\n  validateAddress: (address: string, chain?: UTXOChain) => boolean;\n  createKeysForPath: (params: {\n    wif?: string;\n    phrase?: string;\n    derivationPath?: string;\n  }) => Promise<{ getAddress: (index?: number) => string }>;\n  getAddressFromKeys: (keys: { getAddress: (index?: number) => string }) => string;\n  buildBCHTx: (\n    params: UTXOBuildTxParams & { apiClient: BlockchairApiType },\n  ) => Promise<{ builder: TransactionBuilderType; utxos: UTXOType[] }>;\n  buildTx: (params: UTXOBuildTxParams) => Promise<{ psbt: Psbt }>;\n  transfer: (\n    params: UTXOWalletTransferParams<\n      { builder: TransactionBuilderType; utxos: UTXOType[] },\n      TransactionType\n    >,\n  ) => Promise<string>;\n};\n\nconst chain = Chain.BitcoinCash as UTXOChain;\n\nexport const stripToCashAddress = (address: string) => stripPrefix(toCashAddress(address));\n\nconst buildBCHTx: BCHMethods[\"buildBCHTx\"] = async ({\n  assetValue,\n  recipient,\n  memo,\n  feeRate,\n  sender,\n  apiClient,\n}) => {\n  if (!validateAddress(recipient)) throw new Error(\"Invalid address\");\n  const utxos = await apiClient.scanUTXOs({\n    address: stripToCashAddress(sender),\n    fetchTxHex: true,\n  });\n\n  const compiledMemo = memo ? compileMemo(memo) : null;\n\n  const targetOutputs: TargetOutput[] = [];\n  // output to recipient\n  targetOutputs.push({ address: recipient, value: assetValue.getBaseValue(\"number\") });\n  const { inputs, outputs } = accumulative({\n    inputs: utxos,\n    outputs: targetOutputs,\n    feeRate,\n    chain,\n  });\n\n  // .inputs and .outputs will be undefined if no solution was found\n  if (!(inputs && outputs)) throw new Error(\"Balance insufficient for transaction\");\n\n  const builder = new TransactionBuilder(getNetwork(chain));\n\n  await Promise.all(\n    inputs.map(async (utxo: UTXOType) => {\n      const txHex = (await apiClient.getRawTx(utxo.hash)) as string;\n\n      builder.addInput(Transaction.fromBuffer(Buffer.from(txHex, \"hex\")), utxo.index);\n    }),\n  );\n\n  for (const output of outputs) {\n    const address =\n      \"address\" in output && output.address ? output.address : toLegacyAddress(sender);\n    const outputScript = bchAddress.toOutputScript(toLegacyAddress(address), getNetwork(chain));\n\n    builder.addOutput(outputScript, output.value);\n  }\n\n  // add output for memo\n  if (compiledMemo) {\n    builder.addOutput(compiledMemo, 0); // Add OP_RETURN {script, value}\n  }\n\n  return { builder, utxos: inputs };\n};\n\nconst transfer = async ({\n  signTransaction,\n  from,\n  recipient,\n  assetValue,\n  apiClient,\n  broadcastTx,\n  getFeeRates,\n  ...rest\n}: UTXOWalletTransferParams<\n  { builder: TransactionBuilderType; utxos: UTXOType[] },\n  TransactionType\n> & {\n  apiClient: BlockchairApiType;\n  broadcastTx: (txHash: string) => Promise<string>;\n  getFeeRates: () => Promise<Record<FeeOption, number>>;\n}) => {\n  if (!from) throw new Error(\"From address must be provided\");\n  if (!recipient) throw new Error(\"Recipient address must be provided\");\n  if (!signTransaction) throw new Error(\"signTransaction must be provided\");\n\n  const feeRate = rest.feeRate || (await getFeeRates())[FeeOption.Fast];\n\n  // try out if psbt tx is faster/better/nicer\n  const { builder, utxos } = await buildBCHTx({\n    ...rest,\n    assetValue,\n    feeRate,\n    recipient,\n    sender: from,\n    apiClient,\n  });\n\n  const tx = signTransaction({ builder, utxos });\n  const txHex = tx.toHex();\n\n  return broadcastTx(txHex);\n};\n\nconst buildTx = async ({\n  assetValue,\n  recipient,\n  memo,\n  feeRate,\n  sender,\n  apiClient,\n  // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: TODO: refactor\n}: UTXOBuildTxParams & { apiClient: BlockchairApiType }) => {\n  const recipientCashAddress = toCashAddress(recipient);\n  if (!validateAddress(recipientCashAddress)) throw new Error(\"Invalid address\");\n\n  const utxos = await apiClient.scanUTXOs({\n    address: stripToCashAddress(sender),\n    fetchTxHex: true,\n  });\n\n  const feeRateWhole = Number(feeRate.toFixed(0));\n  const compiledMemo = memo ? compileMemo(memo) : null;\n\n  const targetOutputs = [] as TargetOutput[];\n\n  // output to recipient\n  targetOutputs.push({\n    address: toLegacyAddress(recipient),\n    value: assetValue.getBaseValue(\"number\"),\n  });\n\n  //2. add output memo to targets (optional)\n  if (compiledMemo) {\n    targetOutputs.push({ script: compiledMemo, value: 0 });\n  }\n\n  const { inputs, outputs } = accumulative({\n    inputs: utxos,\n    outputs: targetOutputs,\n    feeRate: feeRateWhole,\n    chain,\n  });\n\n  // .inputs and .outputs will be undefined if no solution was found\n  if (!(inputs && outputs)) throw new Error(\"Balance insufficient for transaction\");\n  const psbt = new Psbt({ network: getNetwork(chain) }); // Network-specific\n\n  for (const { hash, index, witnessUtxo } of inputs) {\n    psbt.addInput({ hash, index, witnessUtxo });\n  }\n\n  // Outputs\n  for (const output of outputs) {\n    const address =\n      \"address\" in output && output.address ? output.address : toLegacyAddress(sender);\n    const params = output.script\n      ? compiledMemo\n        ? { script: compiledMemo, value: 0 }\n        : undefined\n      : { address, value: output.value };\n\n    if (params) {\n      psbt.addOutput(params);\n    }\n  }\n\n  return { psbt, utxos, inputs: inputs as UTXOType[] };\n};\n\nexport const stripPrefix = (address: string) => address.replace(/(bchtest:|bitcoincash:)/, \"\");\n\nexport const validateAddress = (address: string) => {\n  const strippedAddress = stripPrefix(address);\n  return (\n    isValidAddress(strippedAddress) && detectAddressNetwork(strippedAddress) === bchNetwork.Mainnet\n  );\n};\n\nconst createKeysForPath: BCHMethods[\"createKeysForPath\"] = ({\n  phrase,\n  derivationPath = `${DerivationPath.BCH}/0`,\n  wif,\n}) => {\n  const network = getNetwork(chain);\n\n  if (wif) {\n    return ECPairFactory(secp256k1).fromWIF(wif, network);\n  }\n  if (!phrase) throw new Error(\"No phrase provided\");\n\n  const masterHDNode = HDNode.fromSeedBuffer(Buffer.from(mnemonicToSeedSync(phrase)), network);\n  const keyPair = masterHDNode.derivePath(derivationPath).keyPair;\n  // TODO: Figure out same pattern as in BTC\n  // const testWif = keyPair.toWIF();\n  // const k = ECPairFactory(secp256k1).fromWIF(testWif, network);\n  // const a = payments.p2pkh({ pubkey: k.publicKey, network });\n\n  return keyPair;\n};\n\nconst getAddressFromKeys = (keys: { getAddress: (index?: number) => string }) => {\n  const address = keys.getAddress(0);\n  return stripToCashAddress(address);\n};\n\nexport const createBCHToolbox = ({\n  apiKey,\n  rpcUrl = RPCUrl.BitcoinCash,\n  apiClient: client,\n}: {\n  apiKey?: string;\n  rpcUrl?: string;\n  apiClient?: BlockchairApiType;\n}): Omit<\n  ReturnType<typeof BaseUTXOToolbox>,\n  \"getAddressFromKeys\" | \"transfer\" | \"createKeysForPath\"\n> &\n  BCHMethods => {\n  const apiClient = client || blockchairApi({ apiKey, chain });\n  const { getBalance, ...toolbox } = BaseUTXOToolbox({\n    chain,\n    apiClient,\n    broadcastTx: (txHash: string) => broadcastUTXOTx({ txHash, rpcUrl }),\n  });\n\n  return {\n    ...toolbox,\n    stripPrefix,\n    stripToCashAddress,\n    validateAddress,\n    createKeysForPath,\n    getAddressFromKeys,\n    buildBCHTx: (params: UTXOBuildTxParams) => buildBCHTx({ ...params, apiClient }),\n    getBalance: (address: string, _potentialScamFilter?: boolean) =>\n      getBalance(stripPrefix(toCashAddress(address))),\n    buildTx: (params: UTXOBuildTxParams) => buildTx({ ...params, apiClient }),\n    transfer: (\n      params: UTXOWalletTransferParams<\n        { builder: TransactionBuilderType; utxos: UTXOType[] },\n        TransactionType\n      >,\n    ) =>\n      transfer({\n        ...params,\n        getFeeRates: toolbox.getFeeRates,\n        broadcastTx: toolbox.broadcastTx,\n        apiClient,\n      }),\n  };\n};\n",
    "import base58check from \"bs58check\";\n// @ts-expect-error\nimport cashaddr from \"cashaddrjs\";\n\nenum Format {\n  Legacy = \"legacy\",\n  Bitpay = \"bitpay\",\n  Cashaddr = \"cashaddr\",\n}\nenum Network {\n  Mainnet = \"mainnet\",\n  Testnet = \"testnet\",\n}\nenum Type {\n  P2PKH = \"p2pkh\",\n  P2SH = \"p2sh\",\n}\n\nconst VERSION_BYTE = {\n  [Format.Legacy]: {\n    [Network.Mainnet]: {\n      [Type.P2PKH]: 0,\n      [Type.P2SH]: 5,\n    },\n    [Network.Testnet]: {\n      [Type.P2PKH]: 111,\n      [Type.P2SH]: 196,\n    },\n  },\n  [Format.Bitpay]: {\n    [Network.Mainnet]: {\n      [Type.P2PKH]: 28,\n      [Type.P2SH]: 40,\n    },\n    [Network.Testnet]: {\n      [Type.P2PKH]: 111,\n      [Type.P2SH]: 196,\n    },\n  },\n};\n\ntype DecodedType = {\n  format: Format;\n  network: Network;\n  type: Type;\n  hash: Todo;\n};\n\nfunction isValidAddress(input: Todo) {\n  try {\n    decodeAddress(input);\n    return true;\n  } catch (_error) {\n    return false;\n  }\n}\n\nfunction detectAddressNetwork(address: string) {\n  return decodeAddress(address)?.network;\n}\n\nfunction toLegacyAddress(address: string): string {\n  const decoded = decodeAddress(address);\n  if (decoded?.format === Format.Legacy) {\n    return address;\n  }\n  return encodeAsLegacy(decoded);\n}\n\nfunction toCashAddress(address: string): string {\n  const decoded = decodeAddress(address);\n  return encodeAsCashaddr(decoded);\n}\n\nfunction decodeAddress(address: string) {\n  try {\n    return decodeBase58Address(address);\n  } catch (_error) {\n    // Try to decode as cashaddr if base58 decoding fails.\n  }\n  try {\n    return decodeCashAddress(address);\n  } catch (_error) {\n    // Try to decode as bitpay if cashaddr decoding fails.\n  }\n  throw Error(\"Received an invalid Bitcoin Cash address as input.\");\n}\n\nfunction decodeBase58Address(address: string) {\n  try {\n    const payload = base58check.decode(address);\n\n    // BASE_58_CHECK_PAYLOAD_LENGTH\n    if (payload.length !== 21) throw Error(\"Received an invalid Bitcoin Cash address as input.\");\n    const versionByte = payload[0];\n    const hash = Array.prototype.slice.call(payload, 1);\n\n    switch (versionByte) {\n      case VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2PKH]:\n        return { hash, format: Format.Legacy, network: Network.Mainnet, type: Type.P2PKH };\n\n      case VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2SH]:\n        return { hash, format: Format.Legacy, network: Network.Mainnet, type: Type.P2SH };\n\n      case VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2PKH]:\n        return { hash, format: Format.Legacy, network: Network.Testnet, type: Type.P2PKH };\n\n      case VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2SH]:\n        return { hash, format: Format.Legacy, network: Network.Testnet, type: Type.P2SH };\n\n      case VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2PKH]:\n        return { hash, format: Format.Bitpay, network: Network.Mainnet, type: Type.P2PKH };\n\n      case VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2SH]:\n        return { hash, format: Format.Bitpay, network: Network.Mainnet, type: Type.P2SH };\n\n      default:\n        throw Error(\"Received an invalid Bitcoin Cash address as input.\");\n    }\n  } catch (_error) {\n    throw Error(\"Received an invalid Bitcoin Cash address as input.\");\n  }\n}\n\nfunction decodeCashAddress(address: string) {\n  if (address.indexOf(\":\") !== -1) {\n    try {\n      return decodeCashAddressWithPrefix(address);\n    } catch (_error) {\n      // Try to decode as legacy if cashaddr decoding fails.\n    }\n  } else {\n    const prefixes = [\"bitcoincash\", \"bchtest\", \"bchreg\"];\n    for (const prefix of prefixes) {\n      try {\n        return decodeCashAddressWithPrefix(`${prefix}:${address}`);\n      } catch (_error) {\n        // Try next prefix if decoding fails.\n      }\n    }\n  }\n\n  throw Error(\"Received an invalid Bitcoin Cash address as input.\");\n}\n\nfunction decodeCashAddressWithPrefix(address: string): DecodedType {\n  try {\n    const { hash, prefix, type } = cashaddr.decode(address);\n\n    return {\n      format: Format.Cashaddr,\n      hash: Array.prototype.slice.call(hash, 0),\n      network: prefix === \"bitcoincash\" ? Network.Mainnet : Network.Testnet,\n      type: type === \"P2PKH\" ? Type.P2PKH : Type.P2SH,\n    };\n  } catch (_error) {\n    throw Error(\"Received an invalid Bitcoin Cash address as input.\");\n  }\n}\n\nfunction encodeAsLegacy(decoded: DecodedType) {\n  const versionByte = VERSION_BYTE[Format.Legacy][decoded.network][decoded.type];\n  const buffer = Buffer.alloc(1 + decoded.hash.length);\n  buffer[0] = versionByte;\n  buffer.set(decoded.hash, 1);\n  return base58check.encode(buffer);\n}\n\nfunction encodeAsCashaddr(decoded: DecodedType) {\n  const prefix = decoded.network === Network.Mainnet ? \"bitcoincash\" : \"bchtest\";\n  const type = decoded.type === Type.P2PKH ? \"P2PKH\" : \"P2SH\";\n  const hash = new Uint8Array(decoded.hash);\n  return cashaddr.encode(prefix, type, hash);\n}\n\nexport { detectAddressNetwork, isValidAddress, Network, toCashAddress, toLegacyAddress };\n",
    "import { Chain, type UTXOChain } from \"@swapkit/helpers\";\n\nimport type { TargetOutput, UTXOCalculateTxSizeParams, UTXOType } from \"../types/index.ts\";\nimport {\n  TX_OVERHEAD,\n  UTXOScriptType,\n  calculateTxSize,\n  getInputSize,\n  getOutputSize,\n  getScriptTypeForAddress,\n} from \"../utils/index.ts\";\n\nexport const getDustThreshold = (chain: UTXOChain) => {\n  switch (chain) {\n    case Chain.Bitcoin:\n    case Chain.BitcoinCash:\n      return 550;\n    case Chain.Dash:\n    case Chain.Litecoin:\n      return 5500;\n    case Chain.Dogecoin:\n      return 100000;\n    default:\n      throw new Error(\"Invalid Chain\");\n  }\n};\n\nexport const accumulative = ({\n  inputs,\n  outputs,\n  feeRate: initialFeeRate = 1,\n  chain = Chain.Bitcoin,\n}: UTXOCalculateTxSizeParams & { outputs: TargetOutput[]; chain: UTXOChain }) => {\n  const feeRate = Math.ceil(initialFeeRate);\n\n  const newTxType =\n    inputs[0] && \"address\" in inputs[0] && inputs[0].address\n      ? getScriptTypeForAddress(inputs[0].address)\n      : UTXOScriptType.P2PKH;\n  // skip input if adding it would cost more than input is worth\n  const filteredInputs = inputs.filter((input) => getInputSize(input) * feeRate <= input.value);\n\n  const txSizeWithoutInputs =\n    TX_OVERHEAD + outputs.reduce((total, output) => total + getOutputSize(output, newTxType), 0);\n\n  const amountToSend = outputs.reduce((total, output) => total + output.value, 0);\n\n  let fees = txSizeWithoutInputs * feeRate;\n  let inputsValue = 0;\n  const inputsToUse: typeof inputs = [];\n\n  for (const input of filteredInputs) {\n    const inputSize = getInputSize(input);\n    const inputFee = feeRate * inputSize;\n\n    fees += inputFee;\n    inputsValue += input.value;\n\n    inputsToUse.push(input);\n\n    const totalCost = fees + amountToSend;\n\n    // we need more inputs\n    if (inputsValue < totalCost) continue;\n\n    const remainder = inputsValue - totalCost;\n\n    const feeForExtraOutput = feeRate * getOutputSize({ address: \"\", value: 0 }, newTxType);\n\n    // potential change address\n    if (remainder > feeForExtraOutput) {\n      const feeAfterExtraOutput = feeForExtraOutput + fees;\n      const remainderAfterExtraOutput = inputsValue - (amountToSend + feeAfterExtraOutput);\n\n      // is it worth a change output aka can we send it in the future?\n      if (\n        remainderAfterExtraOutput >\n        Math.max(getInputSize({} as UTXOType) * feeRate, getDustThreshold(chain))\n      ) {\n        return {\n          inputs: inputsToUse,\n          outputs: outputs.concat({ value: remainderAfterExtraOutput, address: \"\" }),\n          fee: feeAfterExtraOutput,\n        };\n      }\n    }\n    return {\n      inputs: inputsToUse,\n      outputs,\n      fee: fees,\n    };\n  }\n\n  // We don't have enough inputs, let's calculate transaction fee accrude to the last input\n  return { fee: feeRate * calculateTxSize({ inputs, outputs, feeRate }) };\n};\n",
    "import { opcodes, script } from \"bitcoinjs-lib\";\n\nimport type {\n  TargetOutput,\n  UTXOCalculateTxSizeParams,\n  UTXOInputWithScriptType,\n  UTXOType,\n} from \"../types/index.ts\";\n\n/**\n * Minimum transaction fee\n * 1000 satoshi/kB (similar to current `minrelaytxfee`)\n * @see https://github.com/bitcoin/bitcoin/blob/db88db47278d2e7208c50d16ab10cb355067d071/src/validation.h#L56\n */\nexport const MIN_TX_FEE = 1000;\nexport const TX_OVERHEAD = 4 + 1 + 1 + 4; //10\nexport const OP_RETURN_OVERHEAD = 1 + 8 + 1; //10\nconst TX_INPUT_BASE = 32 + 4 + 1 + 4; // 41\nconst TX_INPUT_PUBKEYHASH = 107;\n\nexport const compileMemo = (memo: string) => {\n  const data = Buffer.from(memo, \"utf8\"); // converts MEMO to buffer\n  return script.compile([opcodes.OP_RETURN as number, data]); // Compile OP_RETURN script\n};\n\nexport enum UTXOScriptType {\n  P2PKH = \"P2PKH\", // legacy\n  //   P2SH = 'P2SH', // multisig\n  P2WPKH = \"P2WPKH\", // bech32 - native segwit\n  //   P2TR = \"P2TR\", // taproot\n}\n\nexport const InputSizes: Record<UTXOScriptType, number> = {\n  [UTXOScriptType.P2PKH]: 148,\n  //   [UTXOScriptType.P2SH]: 91,\n  [UTXOScriptType.P2WPKH]: 68,\n};\n\nexport const OutputSizes: Record<UTXOScriptType, number> = {\n  [UTXOScriptType.P2PKH]: 34,\n  //   [UTXOScriptType.P2SH]: 91,\n  [UTXOScriptType.P2WPKH]: 31,\n};\n\nexport const getScriptTypeForAddress = (address: string) => {\n  if (address.startsWith(\"bc1\") || address.startsWith(\"ltc1\")) {\n    return UTXOScriptType.P2WPKH;\n  }\n  //   if (address.startsWith('3') || address.startsWith('M')) {\n  //     return UTXOScriptType.P2SH;\n  //   }\n  if (\n    address.startsWith(\"1\") ||\n    address.startsWith(\"3\") ||\n    address.startsWith(\"L\") ||\n    address.startsWith(\"M\") ||\n    address.startsWith(\"X\") ||\n    address.startsWith(\"D\") ||\n    address.startsWith(\"bitcoincash:q\") ||\n    address.startsWith(\"q\")\n  ) {\n    return UTXOScriptType.P2PKH;\n  }\n  throw new Error(\"Invalid address\");\n};\n\nexport const calculateTxSize = ({ inputs, outputs, feeRate }: UTXOCalculateTxSizeParams) => {\n  const newTxType =\n    inputs[0] && \"address\" in inputs[0] && inputs[0].address\n      ? getScriptTypeForAddress(inputs[0].address)\n      : UTXOScriptType.P2PKH;\n  const inputSize = inputs\n    .filter(\n      (utxo) =>\n        utxo.value >=\n        InputSizes[\"type\" in utxo ? utxo.type : UTXOScriptType.P2PKH] * Math.ceil(feeRate),\n    )\n    .reduce((total, utxo) => total + getInputSize(utxo), 0);\n\n  const outputSize =\n    outputs?.reduce((total, output) => total + getOutputSize(output), 0) || OutputSizes[newTxType];\n\n  return TX_OVERHEAD + inputSize + outputSize;\n};\n\nexport const getInputSize = (input: UTXOInputWithScriptType | UTXOType) => {\n  if (\"type\" in input) {\n    return InputSizes[input.type];\n  }\n  if (\"address\" in input && input.address) {\n    return InputSizes[getScriptTypeForAddress(input.address as string)];\n  }\n  return TX_INPUT_BASE + TX_INPUT_PUBKEYHASH;\n};\n\nexport const getOutputSize = (output: TargetOutput, scriptType?: UTXOScriptType) => {\n  if (output?.script) {\n    return OP_RETURN_OVERHEAD + output.script.length + (output.script.length >= 74 ? 2 : 1);\n  }\n  if (scriptType) {\n    return OutputSizes[scriptType];\n  }\n  return OutputSizes[UTXOScriptType.P2PKH];\n};\n",
    "import * as secp256k1 from \"@bitcoinerlab/secp256k1\";\nimport { HDKey } from \"@scure/bip32\";\nimport { mnemonicToSeedSync } from \"@scure/bip39\";\nimport {\n  AssetValue,\n  BaseDecimal,\n  Chain,\n  FeeOption,\n  SwapKitNumber,\n  type UTXOChain,\n} from \"@swapkit/helpers\";\nimport { Psbt, address as btcLibAddress, initEccLib, payments } from \"bitcoinjs-lib\";\nimport { ECPairFactory, type ECPairInterface } from \"ecpair\";\n\nimport type { BlockchairApiType } from \"../api/blockchairApi.ts\";\nimport type {\n  TargetOutput,\n  UTXOBaseToolboxParams,\n  UTXOBuildTxParams,\n  UTXOType,\n  UTXOWalletTransferParams,\n} from \"../types/common.ts\";\nimport {\n  UTXOScriptType,\n  accumulative,\n  calculateTxSize,\n  compileMemo,\n  getDustThreshold,\n  getInputSize,\n  getNetwork,\n  standardFeeRates,\n} from \"../utils/index.ts\";\nimport { validateAddress as validateBCHAddress } from \"./bitcoinCash.ts\";\nimport type { BCHToolbox, BTCToolbox, DASHToolbox, DOGEToolbox, LTCToolbox } from \"./index.ts\";\n\nexport const nonSegwitChains = [Chain.Dash, Chain.Dogecoin];\n\nconst createKeysForPath = ({\n  phrase,\n  wif,\n  derivationPath,\n  chain,\n}: {\n  phrase?: string;\n  wif?: string;\n  derivationPath: string;\n  chain: Chain;\n}) => {\n  if (!(wif || phrase)) throw new Error(\"Either phrase or wif must be provided\");\n\n  const factory = ECPairFactory(secp256k1);\n  const network = getNetwork(chain);\n\n  if (wif) return factory.fromWIF(wif, network);\n\n  const seed = mnemonicToSeedSync(phrase as string);\n  const master = HDKey.fromMasterSeed(seed, network).derive(derivationPath);\n  if (!master.privateKey) throw new Error(\"Could not get private key from phrase\");\n\n  return factory.fromPrivateKey(Buffer.from(master.privateKey), { network });\n};\n\nconst validateAddress = ({ address, chain }: { address: string; chain: UTXOChain }) => {\n  try {\n    initEccLib(secp256k1);\n    btcLibAddress.toOutputScript(address, getNetwork(chain));\n    return true;\n  } catch (_error) {\n    return false;\n  }\n};\n\nconst getAddressFromKeys = ({ keys, chain }: { keys: ECPairInterface } & UTXOBaseToolboxParams) => {\n  if (!keys) throw new Error(\"Keys must be provided\");\n\n  const method = nonSegwitChains.includes(chain) ? payments.p2pkh : payments.p2wpkh;\n  const { address } = method({ pubkey: keys.publicKey, network: getNetwork(chain) });\n  if (!address) throw new Error(\"Address not defined\");\n\n  return address;\n};\n\nconst transfer = async ({\n  signTransaction,\n  from,\n  memo,\n  recipient,\n  chain,\n  apiClient,\n  feeOptionKey,\n  broadcastTx,\n  feeRate,\n  assetValue,\n}: UTXOWalletTransferParams<Psbt, Psbt>) => {\n  if (!from) throw new Error(\"From address must be provided\");\n  if (!recipient) throw new Error(\"Recipient address must be provided\");\n  const txFeeRate = feeRate || (await getFeeRates(apiClient))[feeOptionKey || FeeOption.Fast];\n\n  const { psbt } = await buildTx({\n    recipient,\n    feeRate: txFeeRate,\n    sender: from,\n    fetchTxHex: nonSegwitChains.includes(chain),\n    chain,\n    apiClient,\n    assetValue,\n    memo,\n  });\n  const signedPsbt = await signTransaction(psbt);\n  signedPsbt.finalizeAllInputs(); // Finalise inputs\n  // TX extracted and formatted to hex\n  return broadcastTx(signedPsbt.extractTransaction().toHex());\n};\n\nconst getBalance = async ({\n  address,\n  chain,\n  apiClient,\n}: { address: string } & UTXOBaseToolboxParams) => {\n  const baseBalance = (await apiClient.getBalance(address)) || 0;\n\n  const balance = baseBalance / 10 ** BaseDecimal[chain];\n  const asset = await AssetValue.from({ asset: `${chain}.${chain}`, value: balance });\n\n  return [asset];\n};\n\nconst getFeeRates = async (apiClient: BlockchairApiType) =>\n  standardFeeRates(await apiClient.getSuggestedTxFee());\n\nconst getInputsAndTargetOutputs = async ({\n  assetValue,\n  recipient,\n  memo,\n  sender,\n  fetchTxHex = false,\n  apiClient,\n}: {\n  assetValue: AssetValue;\n  recipient: string;\n  memo?: string;\n  sender: string;\n  fetchTxHex?: boolean;\n  apiClient: BlockchairApiType;\n}) => {\n  const inputs = await apiClient.scanUTXOs({\n    address: sender,\n    fetchTxHex,\n  });\n\n  //1. add output amount and recipient to targets\n  //2. add output memo to targets (optional)\n\n  return {\n    inputs,\n    outputs: [\n      { address: recipient, value: Number(assetValue.bigIntValue) },\n      ...(memo ? [{ address: \"\", script: compileMemo(memo), value: 0 }] : []),\n    ],\n  };\n};\n\nconst buildTx = async ({\n  assetValue,\n  recipient,\n  memo,\n  feeRate,\n  sender,\n  fetchTxHex = false,\n  apiClient,\n  chain,\n}: UTXOBuildTxParams): Promise<{\n  psbt: Psbt;\n  utxos: UTXOType[];\n  inputs: UTXOType[];\n  // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: TODO: refactor\n}> => {\n  const compiledMemo = memo ? compileMemo(memo) : null;\n\n  const inputsAndOutputs = await getInputsAndTargetOutputs({\n    assetValue,\n    recipient,\n    memo,\n    sender,\n    fetchTxHex,\n    apiClient,\n  });\n\n  const { inputs, outputs } = accumulative({ ...inputsAndOutputs, feeRate, chain });\n\n  // .inputs and .outputs will be undefined if no solution was found\n  if (!(inputs && outputs)) throw new Error(\"Insufficient Balance for transaction\");\n  const psbt = new Psbt({ network: getNetwork(chain) }); // Network-specific\n\n  if (chain === Chain.Dogecoin) psbt.setMaximumFeeRate(650000000);\n\n  for (const utxo of inputs) {\n    psbt.addInput({\n      hash: utxo.hash,\n      index: utxo.index,\n      ...(!!utxo.witnessUtxo &&\n        !nonSegwitChains.includes(chain) && { witnessUtxo: utxo.witnessUtxo }),\n      ...(nonSegwitChains.includes(chain) && {\n        nonWitnessUtxo: utxo.txHex ? Buffer.from(utxo.txHex, \"hex\") : undefined,\n      }),\n    });\n  }\n\n  for (const output of outputs) {\n    const address = \"address\" in output && output.address ? output.address : sender;\n    const params = output.script\n      ? compiledMemo\n        ? { script: compiledMemo, value: 0 }\n        : undefined\n      : { address, value: output.value };\n\n    if (params) {\n      initEccLib(secp256k1);\n      psbt.addOutput(params);\n    }\n  }\n\n  return { psbt, utxos: inputsAndOutputs.inputs, inputs };\n};\n\nconst getInputsOutputsFee = async ({\n  assetValue,\n  apiClient,\n  chain,\n  feeOptionKey = FeeOption.Fast,\n  feeRate,\n  fetchTxHex = false,\n  memo,\n  recipient,\n  from,\n}: {\n  assetValue: AssetValue;\n  recipient: string;\n  memo?: string;\n  from: string;\n  feeOptionKey?: FeeOption;\n  feeRate?: number;\n  fetchTxHex?: boolean;\n  apiClient: BlockchairApiType;\n  chain: UTXOChain;\n}) => {\n  const inputsAndOutputs = await getInputsAndTargetOutputs({\n    assetValue,\n    recipient,\n    memo,\n    sender: from,\n    fetchTxHex,\n    apiClient,\n  });\n\n  const feeRateWhole = feeRate ? Math.floor(feeRate) : (await getFeeRates(apiClient))[feeOptionKey];\n\n  return accumulative({ ...inputsAndOutputs, feeRate: feeRateWhole, chain });\n};\n\nexport const estimateMaxSendableAmount = async ({\n  from,\n  memo,\n  feeRate,\n  feeOptionKey = FeeOption.Fast,\n  recipients = 1,\n  chain,\n  apiClient,\n}: UTXOBaseToolboxParams & {\n  recipients?: number | TargetOutput[];\n  memo?: string;\n  feeRate?: number;\n  feeOptionKey?: FeeOption;\n  from: string;\n}) => {\n  const addressData = await apiClient.getAddressData(from);\n  const feeRateWhole = feeRate ? Math.ceil(feeRate) : (await getFeeRates(apiClient))[feeOptionKey];\n  const inputs = addressData?.utxo\n    .map((utxo) => ({\n      ...utxo,\n      // type: utxo.witnessUtxo ? UTXOScriptType.P2WPKH : UTXOScriptType.P2PKH,\n      type: UTXOScriptType.P2PKH,\n      hash: \"\",\n    }))\n    .filter(\n      (utxo) => utxo.value > Math.max(getDustThreshold(chain), getInputSize(utxo) * feeRateWhole),\n    );\n\n  if (!inputs?.length) return AssetValue.from({ chain });\n\n  const balance = AssetValue.from({\n    chain,\n    value: inputs.reduce((sum, utxo) => sum + utxo.value, 0),\n  });\n\n  const outputs =\n    typeof recipients === \"number\"\n      ? (Array.from({ length: recipients }, () => ({ address: from, value: 0 })) as TargetOutput[])\n      : recipients;\n\n  if (memo) {\n    const compiledMemo = compileMemo(memo);\n    outputs.push({ address: from, script: compiledMemo, value: 0 });\n  }\n\n  const txSize = calculateTxSize({\n    inputs,\n    outputs,\n    feeRate: feeRateWhole,\n  });\n\n  const fee = txSize * feeRateWhole;\n\n  return balance.sub(fee);\n};\n\nexport const BaseUTXOToolbox = (\n  baseToolboxParams: UTXOBaseToolboxParams & { broadcastTx: (txHex: string) => Promise<string> },\n) => ({\n  accumulative,\n  apiClient: baseToolboxParams.apiClient,\n  broadcastTx: baseToolboxParams.broadcastTx,\n  calculateTxSize,\n  buildTx: (params: Todo) => buildTx({ ...params, ...baseToolboxParams }),\n  getAddressFromKeys: (keys: ECPairInterface) => getAddressFromKeys({ keys, ...baseToolboxParams }),\n  validateAddress: (address: string) => validateAddress({ address, ...baseToolboxParams }),\n  createKeysForPath: (params: Todo) => createKeysForPath({ ...params, ...baseToolboxParams }),\n\n  getPrivateKeyFromMnemonic: async (params: {\n    phrase: string;\n    derivationPath: string;\n  }) => createKeysForPath({ ...baseToolboxParams, ...params }).toWIF(),\n\n  getBalance: async (address: string, _potentialScamFilter?: boolean) =>\n    getBalance({ address, ...baseToolboxParams }),\n\n  getFeeRates: () => getFeeRates(baseToolboxParams.apiClient),\n\n  transfer: (params: Todo) => transfer({ ...params, ...baseToolboxParams }),\n\n  getInputsOutputsFee: (params: Todo) => getInputsOutputsFee({ ...params, ...baseToolboxParams }),\n\n  estimateTransactionFee: async (params: {\n    assetValue: AssetValue;\n    recipient: string;\n    from: string;\n    memo?: string;\n    feeOptionKey?: FeeOption;\n    feeRate?: number;\n    fetchTxHex?: boolean;\n  }) => {\n    return AssetValue.from({\n      chain: baseToolboxParams.chain,\n      value: SwapKitNumber.fromBigInt(\n        BigInt((await getInputsOutputsFee({ ...params, ...baseToolboxParams })).fee),\n        8,\n      ).getValue(\"string\"),\n    });\n  },\n\n  estimateMaxSendableAmount: async (params: Todo) =>\n    estimateMaxSendableAmount({ ...params, ...baseToolboxParams }),\n});\n\nexport const utxoValidateAddress = ({\n  chain,\n  address,\n}: {\n  chain: UTXOChain;\n  address: string;\n}) =>\n  chain === Chain.BitcoinCash\n    ? validateBCHAddress(address)\n    : validateAddress({\n        address,\n        chain,\n      });\n\nexport type BaseUTXOWallet = ReturnType<typeof BaseUTXOToolbox>;\ntype UTXOWalletType = {\n  [Chain.Bitcoin]: ReturnType<typeof BTCToolbox>;\n  [Chain.BitcoinCash]: ReturnType<typeof BCHToolbox>;\n  [Chain.Dogecoin]: ReturnType<typeof DOGEToolbox>;\n  [Chain.Litecoin]: ReturnType<typeof LTCToolbox>;\n  [Chain.Dash]: ReturnType<typeof DASHToolbox>;\n};\nexport type UTXOWallets = { [chain in UTXOChain]: BaseUTXOWallet & UTXOWalletType[chain] };\n"
  ],
  "mappings": "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",
  "debugId": "42B714AD1866C21364756E2164756E21",
  "names": []
}